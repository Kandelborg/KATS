### This file was autogenerated by Nexus 0.11.6
### Do not make changes to this file directly

type AuthPayload {
  token: String!
  user: User!
}

type Avatar {
  createdAt: DateTime!
  id: UUID!
  publicId: String
  src: String
  updatedAt: DateTime!
}

input AvatarCreateInput {
  publicId: String
  src: String
}

input AvatarCreateOneInput {
  connect: AvatarWhereUniqueInput
  create: AvatarCreateInput
}

input AvatarUpdateDataInput {
  publicId: String
  src: String
}

input AvatarUpdateOneRequiredInput {
  connect: AvatarWhereUniqueInput
  create: AvatarCreateInput
  update: AvatarUpdateDataInput
  upsert: AvatarUpsertNestedInput
}

input AvatarUpsertNestedInput {
  create: AvatarCreateInput!
  update: AvatarUpdateDataInput!
}

input AvatarWhereInput {
  AND: [AvatarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [AvatarWhereInput!]
  OR: [AvatarWhereInput!]
  publicId: String
  publicId_contains: String
  publicId_ends_with: String
  publicId_gt: String
  publicId_gte: String
  publicId_in: [String!]
  publicId_lt: String
  publicId_lte: String
  publicId_not: String
  publicId_not_contains: String
  publicId_not_ends_with: String
  publicId_not_in: [String!]
  publicId_not_starts_with: String
  publicId_starts_with: String
  src: String
  src_contains: String
  src_ends_with: String
  src_gt: String
  src_gte: String
  src_in: [String!]
  src_lt: String
  src_lte: String
  src_not: String
  src_not_contains: String
  src_not_ends_with: String
  src_not_in: [String!]
  src_not_starts_with: String
  src_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input AvatarWhereUniqueInput {
  id: UUID
}

type Comment {
  author: User!
  createdAt: DateTime!
  id: UUID!
  post: Post!
  updatedAt: DateTime!
}

input CommentCreateManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutAuthorInput!]
}

input CommentCreateManyWithoutPostInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutPostInput!]
}

input CommentCreateWithoutAuthorInput {
  post: PostCreateOneWithoutCommentsInput!
}

input CommentCreateWithoutPostInput {
  author: UserCreateOneWithoutCommentsInput!
}

enum CommentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input CommentUpdateManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutAuthorInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
}

input CommentUpdateManyWithoutPostInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
}

input CommentUpdateWithoutAuthorDataInput {
  post: PostUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateWithoutPostDataInput {
  author: UserUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  data: CommentUpdateWithoutAuthorDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  data: CommentUpdateWithoutPostDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  create: CommentCreateWithoutAuthorInput!
  update: CommentUpdateWithoutAuthorDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  create: CommentCreateWithoutPostInput!
  update: CommentUpdateWithoutPostDataInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  author: UserWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  post: PostWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input CommentWhereUniqueInput {
  id: UUID
}

scalar DateTime

type Mutation {
  likePost(id: ID!, userId: ID!): Post
  postCreate(data: PostCreateInput!): Post!
  postDelete(where: PostWhereUniqueInput!): Post
  postUpdate(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  projectCategoryCreate(data: ProjectCategoryCreateInput!): ProjectCategory!
  projectCategoryDelete(
    where: ProjectCategoryWhereUniqueInput!
  ): ProjectCategory
  projectCategoryUpdate(
    data: ProjectCategoryUpdateInput!
    where: ProjectCategoryWhereUniqueInput!
  ): ProjectCategory
  projectCreate(data: ProjectCreateInput!): Project!
  projectDelete(where: ProjectWhereUniqueInput!): Project
  projectUpdate(
    data: ProjectUpdateInput!
    where: ProjectWhereUniqueInput!
  ): Project
  userCreate(email: String!, name: String!, password: String!): AuthPayload
  userDelete(where: UserWhereUniqueInput!): User
  userLogin(email: String!, password: String!): AuthPayload
  userUpdate(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

type Post {
  author: User!
  comments(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: CommentOrderByInput
    skip: Int
    where: CommentWhereInput
  ): [Comment!]
  contents(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PostContentOrderByInput
    skip: Int
    where: PostContentWhereInput
  ): [PostContent!]
  createdAt: DateTime!
  id: UUID!
  imageSrc: String!
  isPublished: Boolean!
  likedBy(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: UserOrderByInput
    skip: Int
    where: UserWhereInput
  ): [User!]
  likes: Int
  slug: String!
  tags(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PostTagOrderByInput
    skip: Int
    where: PostTagWhereInput
  ): [PostTag!]
  updatedAt: DateTime!
}

type PostContent {
  createdAt: DateTime!
  id: UUID!
  imageAlt: String!
  language: PostLng!
  metaDescription: String
  metaTitle: String
  post: Post!
  text: String!
  title: String!
  updatedAt: DateTime!
}

input PostContentCreateManyWithoutPostInput {
  connect: [PostContentWhereUniqueInput!]
  create: [PostContentCreateWithoutPostInput!]
}

input PostContentCreateWithoutPostInput {
  imageAlt: String!
  language: PostLngCreateOneWithoutPostsInput!
  metaDescription: String
  metaTitle: String
  text: String!
  title: String!
}

enum PostContentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  imageAlt_ASC
  imageAlt_DESC
  metaDescription_ASC
  metaDescription_DESC
  metaTitle_ASC
  metaTitle_DESC
  text_ASC
  text_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PostContentScalarWhereInput {
  AND: [PostContentScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  imageAlt: String
  imageAlt_contains: String
  imageAlt_ends_with: String
  imageAlt_gt: String
  imageAlt_gte: String
  imageAlt_in: [String!]
  imageAlt_lt: String
  imageAlt_lte: String
  imageAlt_not: String
  imageAlt_not_contains: String
  imageAlt_not_ends_with: String
  imageAlt_not_in: [String!]
  imageAlt_not_starts_with: String
  imageAlt_starts_with: String
  metaDescription: String
  metaDescription_contains: String
  metaDescription_ends_with: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_not: String
  metaDescription_not_contains: String
  metaDescription_not_ends_with: String
  metaDescription_not_in: [String!]
  metaDescription_not_starts_with: String
  metaDescription_starts_with: String
  metaTitle: String
  metaTitle_contains: String
  metaTitle_ends_with: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_not: String
  metaTitle_not_contains: String
  metaTitle_not_ends_with: String
  metaTitle_not_in: [String!]
  metaTitle_not_starts_with: String
  metaTitle_starts_with: String
  NOT: [PostContentScalarWhereInput!]
  OR: [PostContentScalarWhereInput!]
  text: String
  text_contains: String
  text_ends_with: String
  text_gt: String
  text_gte: String
  text_in: [String!]
  text_lt: String
  text_lte: String
  text_not: String
  text_not_contains: String
  text_not_ends_with: String
  text_not_in: [String!]
  text_not_starts_with: String
  text_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PostContentUpdateManyDataInput {
  imageAlt: String
  metaDescription: String
  metaTitle: String
  text: String
  title: String
}

input PostContentUpdateManyWithoutPostInput {
  connect: [PostContentWhereUniqueInput!]
  create: [PostContentCreateWithoutPostInput!]
  delete: [PostContentWhereUniqueInput!]
  deleteMany: [PostContentScalarWhereInput!]
  disconnect: [PostContentWhereUniqueInput!]
  set: [PostContentWhereUniqueInput!]
  update: [PostContentUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [PostContentUpdateManyWithWhereNestedInput!]
  upsert: [PostContentUpsertWithWhereUniqueWithoutPostInput!]
}

input PostContentUpdateManyWithWhereNestedInput {
  data: PostContentUpdateManyDataInput!
  where: PostContentScalarWhereInput!
}

input PostContentUpdateWithoutPostDataInput {
  imageAlt: String
  language: PostLngUpdateOneRequiredWithoutPostsInput
  metaDescription: String
  metaTitle: String
  text: String
  title: String
}

input PostContentUpdateWithWhereUniqueWithoutPostInput {
  data: PostContentUpdateWithoutPostDataInput!
  where: PostContentWhereUniqueInput!
}

input PostContentUpsertWithWhereUniqueWithoutPostInput {
  create: PostContentCreateWithoutPostInput!
  update: PostContentUpdateWithoutPostDataInput!
  where: PostContentWhereUniqueInput!
}

input PostContentWhereInput {
  AND: [PostContentWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  imageAlt: String
  imageAlt_contains: String
  imageAlt_ends_with: String
  imageAlt_gt: String
  imageAlt_gte: String
  imageAlt_in: [String!]
  imageAlt_lt: String
  imageAlt_lte: String
  imageAlt_not: String
  imageAlt_not_contains: String
  imageAlt_not_ends_with: String
  imageAlt_not_in: [String!]
  imageAlt_not_starts_with: String
  imageAlt_starts_with: String
  language: PostLngWhereInput
  metaDescription: String
  metaDescription_contains: String
  metaDescription_ends_with: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_not: String
  metaDescription_not_contains: String
  metaDescription_not_ends_with: String
  metaDescription_not_in: [String!]
  metaDescription_not_starts_with: String
  metaDescription_starts_with: String
  metaTitle: String
  metaTitle_contains: String
  metaTitle_ends_with: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_not: String
  metaTitle_not_contains: String
  metaTitle_not_ends_with: String
  metaTitle_not_in: [String!]
  metaTitle_not_starts_with: String
  metaTitle_starts_with: String
  NOT: [PostContentWhereInput!]
  OR: [PostContentWhereInput!]
  post: PostWhereInput
  text: String
  text_contains: String
  text_ends_with: String
  text_gt: String
  text_gte: String
  text_in: [String!]
  text_lt: String
  text_lte: String
  text_not: String
  text_not_contains: String
  text_not_ends_with: String
  text_not_in: [String!]
  text_not_starts_with: String
  text_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PostContentWhereUniqueInput {
  id: UUID
}

input PostCreateInput {
  author: UserCreateOneWithoutPostsInput!
  comments: CommentCreateManyWithoutPostInput
  contents: PostContentCreateManyWithoutPostInput
  imageSrc: String!
  isPublished: Boolean
  likedBy: UserCreateManyWithoutPostLikesInput
  likes: Int
  slug: String!
  tags: PostTagCreateManyInput
}

input PostCreateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
}

input PostCreateManyWithoutLikedByInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutLikedByInput!]
}

input PostCreateOneWithoutCommentsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCommentsInput
}

input PostCreateWithoutAuthorInput {
  comments: CommentCreateManyWithoutPostInput
  contents: PostContentCreateManyWithoutPostInput
  imageSrc: String!
  isPublished: Boolean
  likedBy: UserCreateManyWithoutPostLikesInput
  likes: Int
  slug: String!
  tags: PostTagCreateManyInput
}

input PostCreateWithoutCommentsInput {
  author: UserCreateOneWithoutPostsInput!
  contents: PostContentCreateManyWithoutPostInput
  imageSrc: String!
  isPublished: Boolean
  likedBy: UserCreateManyWithoutPostLikesInput
  likes: Int
  slug: String!
  tags: PostTagCreateManyInput
}

input PostCreateWithoutLikedByInput {
  author: UserCreateOneWithoutPostsInput!
  comments: CommentCreateManyWithoutPostInput
  contents: PostContentCreateManyWithoutPostInput
  imageSrc: String!
  isPublished: Boolean
  likes: Int
  slug: String!
  tags: PostTagCreateManyInput
}

type PostLng {
  country: String!
  id: UUID!
  locale: String
  posts(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PostContentOrderByInput
    skip: Int
    where: PostContentWhereInput
  ): [PostContent!]
}

input PostLngCreateOneWithoutPostsInput {
  connect: PostLngWhereUniqueInput
  create: PostLngCreateWithoutPostsInput
}

input PostLngCreateWithoutPostsInput {
  country: String!
  locale: String
}

input PostLngUpdateOneRequiredWithoutPostsInput {
  connect: PostLngWhereUniqueInput
  create: PostLngCreateWithoutPostsInput
  update: PostLngUpdateWithoutPostsDataInput
  upsert: PostLngUpsertWithoutPostsInput
}

input PostLngUpdateWithoutPostsDataInput {
  country: String
  locale: String
}

input PostLngUpsertWithoutPostsInput {
  create: PostLngCreateWithoutPostsInput!
  update: PostLngUpdateWithoutPostsDataInput!
}

input PostLngWhereInput {
  AND: [PostLngWhereInput!]
  country: String
  country_contains: String
  country_ends_with: String
  country_gt: String
  country_gte: String
  country_in: [String!]
  country_lt: String
  country_lte: String
  country_not: String
  country_not_contains: String
  country_not_ends_with: String
  country_not_in: [String!]
  country_not_starts_with: String
  country_starts_with: String
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  locale: String
  locale_contains: String
  locale_ends_with: String
  locale_gt: String
  locale_gte: String
  locale_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_not: String
  locale_not_contains: String
  locale_not_ends_with: String
  locale_not_in: [String!]
  locale_not_starts_with: String
  locale_starts_with: String
  NOT: [PostLngWhereInput!]
  OR: [PostLngWhereInput!]
  posts_every: PostContentWhereInput
  posts_none: PostContentWhereInput
  posts_some: PostContentWhereInput
}

input PostLngWhereUniqueInput {
  country: String
  id: UUID
  locale: String
}

enum PostOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  imageSrc_ASC
  imageSrc_DESC
  isPublished_ASC
  isPublished_DESC
  likes_ASC
  likes_DESC
  slug_ASC
  slug_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  imageSrc: String
  imageSrc_contains: String
  imageSrc_ends_with: String
  imageSrc_gt: String
  imageSrc_gte: String
  imageSrc_in: [String!]
  imageSrc_lt: String
  imageSrc_lte: String
  imageSrc_not: String
  imageSrc_not_contains: String
  imageSrc_not_ends_with: String
  imageSrc_not_in: [String!]
  imageSrc_not_starts_with: String
  imageSrc_starts_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  likes: Int
  likes_gt: Int
  likes_gte: Int
  likes_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_not: Int
  likes_not_in: [Int!]
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  slug: String
  slug_contains: String
  slug_ends_with: String
  slug_gt: String
  slug_gte: String
  slug_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_not: String
  slug_not_contains: String
  slug_not_ends_with: String
  slug_not_in: [String!]
  slug_not_starts_with: String
  slug_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

type PostTag {
  color: String!
  contents: PostTagContent!
  createdAt: DateTime!
  id: UUID!
  language: PostTagLng!
  updatedAt: DateTime!
}

type PostTagContent {
  createdAt: DateTime!
  id: UUID!
  tag: PostTag!
  title: String!
  updatedAt: DateTime!
}

input PostTagContentCreateOneWithoutTagInput {
  connect: PostTagContentWhereUniqueInput
  create: PostTagContentCreateWithoutTagInput
}

input PostTagContentCreateWithoutTagInput {
  title: String!
}

input PostTagContentUpdateOneRequiredWithoutTagInput {
  connect: PostTagContentWhereUniqueInput
  create: PostTagContentCreateWithoutTagInput
  update: PostTagContentUpdateWithoutTagDataInput
  upsert: PostTagContentUpsertWithoutTagInput
}

input PostTagContentUpdateWithoutTagDataInput {
  title: String
}

input PostTagContentUpsertWithoutTagInput {
  create: PostTagContentCreateWithoutTagInput!
  update: PostTagContentUpdateWithoutTagDataInput!
}

input PostTagContentWhereInput {
  AND: [PostTagContentWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [PostTagContentWhereInput!]
  OR: [PostTagContentWhereInput!]
  tag: PostTagWhereInput
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PostTagContentWhereUniqueInput {
  id: UUID
}

input PostTagCreateInput {
  color: String!
  contents: PostTagContentCreateOneWithoutTagInput!
  language: PostTagLngCreateOneWithoutTagsInput!
}

input PostTagCreateManyInput {
  connect: [PostTagWhereUniqueInput!]
  create: [PostTagCreateInput!]
}

type PostTagLng {
  country: String!
  id: UUID!
  locale: String!
  tags(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PostTagOrderByInput
    skip: Int
    where: PostTagWhereInput
  ): [PostTag!]
}

input PostTagLngCreateOneWithoutTagsInput {
  connect: PostTagLngWhereUniqueInput
  create: PostTagLngCreateWithoutTagsInput
}

input PostTagLngCreateWithoutTagsInput {
  country: String!
  locale: String!
}

input PostTagLngUpdateOneRequiredWithoutTagsInput {
  connect: PostTagLngWhereUniqueInput
  create: PostTagLngCreateWithoutTagsInput
  update: PostTagLngUpdateWithoutTagsDataInput
  upsert: PostTagLngUpsertWithoutTagsInput
}

input PostTagLngUpdateWithoutTagsDataInput {
  country: String
  locale: String
}

input PostTagLngUpsertWithoutTagsInput {
  create: PostTagLngCreateWithoutTagsInput!
  update: PostTagLngUpdateWithoutTagsDataInput!
}

input PostTagLngWhereInput {
  AND: [PostTagLngWhereInput!]
  country: String
  country_contains: String
  country_ends_with: String
  country_gt: String
  country_gte: String
  country_in: [String!]
  country_lt: String
  country_lte: String
  country_not: String
  country_not_contains: String
  country_not_ends_with: String
  country_not_in: [String!]
  country_not_starts_with: String
  country_starts_with: String
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  locale: String
  locale_contains: String
  locale_ends_with: String
  locale_gt: String
  locale_gte: String
  locale_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_not: String
  locale_not_contains: String
  locale_not_ends_with: String
  locale_not_in: [String!]
  locale_not_starts_with: String
  locale_starts_with: String
  NOT: [PostTagLngWhereInput!]
  OR: [PostTagLngWhereInput!]
  tags_every: PostTagWhereInput
  tags_none: PostTagWhereInput
  tags_some: PostTagWhereInput
}

input PostTagLngWhereUniqueInput {
  id: UUID
}

enum PostTagOrderByInput {
  color_ASC
  color_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PostTagScalarWhereInput {
  AND: [PostTagScalarWhereInput!]
  color: String
  color_contains: String
  color_ends_with: String
  color_gt: String
  color_gte: String
  color_in: [String!]
  color_lt: String
  color_lte: String
  color_not: String
  color_not_contains: String
  color_not_ends_with: String
  color_not_in: [String!]
  color_not_starts_with: String
  color_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [PostTagScalarWhereInput!]
  OR: [PostTagScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PostTagUpdateDataInput {
  color: String
  contents: PostTagContentUpdateOneRequiredWithoutTagInput
  language: PostTagLngUpdateOneRequiredWithoutTagsInput
}

input PostTagUpdateManyDataInput {
  color: String
}

input PostTagUpdateManyInput {
  connect: [PostTagWhereUniqueInput!]
  create: [PostTagCreateInput!]
  delete: [PostTagWhereUniqueInput!]
  deleteMany: [PostTagScalarWhereInput!]
  disconnect: [PostTagWhereUniqueInput!]
  set: [PostTagWhereUniqueInput!]
  update: [PostTagUpdateWithWhereUniqueNestedInput!]
  updateMany: [PostTagUpdateManyWithWhereNestedInput!]
  upsert: [PostTagUpsertWithWhereUniqueNestedInput!]
}

input PostTagUpdateManyWithWhereNestedInput {
  data: PostTagUpdateManyDataInput!
  where: PostTagScalarWhereInput!
}

input PostTagUpdateWithWhereUniqueNestedInput {
  data: PostTagUpdateDataInput!
  where: PostTagWhereUniqueInput!
}

input PostTagUpsertWithWhereUniqueNestedInput {
  create: PostTagCreateInput!
  update: PostTagUpdateDataInput!
  where: PostTagWhereUniqueInput!
}

input PostTagWhereInput {
  AND: [PostTagWhereInput!]
  color: String
  color_contains: String
  color_ends_with: String
  color_gt: String
  color_gte: String
  color_in: [String!]
  color_lt: String
  color_lte: String
  color_not: String
  color_not_contains: String
  color_not_ends_with: String
  color_not_in: [String!]
  color_not_starts_with: String
  color_starts_with: String
  contents: PostTagContentWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  language: PostTagLngWhereInput
  NOT: [PostTagWhereInput!]
  OR: [PostTagWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PostTagWhereUniqueInput {
  id: UUID
}

input PostUpdateInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  contents: PostContentUpdateManyWithoutPostInput
  imageSrc: String
  isPublished: Boolean
  likedBy: UserUpdateManyWithoutPostLikesInput
  likes: Int
  slug: String
  tags: PostTagUpdateManyInput
}

input PostUpdateManyDataInput {
  imageSrc: String
  isPublished: Boolean
  likes: Int
  slug: String
}

input PostUpdateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateManyWithoutLikedByInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutLikedByInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutLikedByInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutLikedByInput!]
}

input PostUpdateManyWithWhereNestedInput {
  data: PostUpdateManyDataInput!
  where: PostScalarWhereInput!
}

input PostUpdateOneRequiredWithoutCommentsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
}

input PostUpdateWithoutAuthorDataInput {
  comments: CommentUpdateManyWithoutPostInput
  contents: PostContentUpdateManyWithoutPostInput
  imageSrc: String
  isPublished: Boolean
  likedBy: UserUpdateManyWithoutPostLikesInput
  likes: Int
  slug: String
  tags: PostTagUpdateManyInput
}

input PostUpdateWithoutCommentsDataInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  contents: PostContentUpdateManyWithoutPostInput
  imageSrc: String
  isPublished: Boolean
  likedBy: UserUpdateManyWithoutPostLikesInput
  likes: Int
  slug: String
  tags: PostTagUpdateManyInput
}

input PostUpdateWithoutLikedByDataInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  contents: PostContentUpdateManyWithoutPostInput
  imageSrc: String
  isPublished: Boolean
  likes: Int
  slug: String
  tags: PostTagUpdateManyInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithWhereUniqueWithoutLikedByInput {
  data: PostUpdateWithoutLikedByDataInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput!
  update: PostUpdateWithoutCommentsDataInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutLikedByInput {
  create: PostCreateWithoutLikedByInput!
  update: PostUpdateWithoutLikedByDataInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  author: UserWhereInput
  comments_every: CommentWhereInput
  comments_none: CommentWhereInput
  comments_some: CommentWhereInput
  contents_every: PostContentWhereInput
  contents_none: PostContentWhereInput
  contents_some: PostContentWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  imageSrc: String
  imageSrc_contains: String
  imageSrc_ends_with: String
  imageSrc_gt: String
  imageSrc_gte: String
  imageSrc_in: [String!]
  imageSrc_lt: String
  imageSrc_lte: String
  imageSrc_not: String
  imageSrc_not_contains: String
  imageSrc_not_ends_with: String
  imageSrc_not_in: [String!]
  imageSrc_not_starts_with: String
  imageSrc_starts_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  likedBy_every: UserWhereInput
  likedBy_none: UserWhereInput
  likedBy_some: UserWhereInput
  likes: Int
  likes_gt: Int
  likes_gte: Int
  likes_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_not: Int
  likes_not_in: [Int!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  slug: String
  slug_contains: String
  slug_ends_with: String
  slug_gt: String
  slug_gte: String
  slug_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_not: String
  slug_not_contains: String
  slug_not_ends_with: String
  slug_not_in: [String!]
  slug_not_starts_with: String
  slug_starts_with: String
  tags_every: PostTagWhereInput
  tags_none: PostTagWhereInput
  tags_some: PostTagWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PostWhereUniqueInput {
  id: UUID
  slug: String
}

type Profile {
  avatar: Avatar!
  bio: String!
  createdAt: DateTime!
  id: UUID!
  updatedAt: DateTime!
  user: User!
}

input ProfileCreateOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateWithoutUserInput
}

input ProfileCreateWithoutUserInput {
  avatar: AvatarCreateOneInput!
  bio: String!
}

input ProfileUpdateOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: ProfileUpdateWithoutUserDataInput
  upsert: ProfileUpsertWithoutUserInput
}

input ProfileUpdateWithoutUserDataInput {
  avatar: AvatarUpdateOneRequiredInput
  bio: String
}

input ProfileUpsertWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  update: ProfileUpdateWithoutUserDataInput!
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  avatar: AvatarWhereInput
  bio: String
  bio_contains: String
  bio_ends_with: String
  bio_gt: String
  bio_gte: String
  bio_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_not: String
  bio_not_contains: String
  bio_not_ends_with: String
  bio_not_in: [String!]
  bio_not_starts_with: String
  bio_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  user: UserWhereInput
}

input ProfileWhereUniqueInput {
  id: UUID
}

type Project {
  album: ProjectAlbum!
  author: User!
  category: ProjectCategory!
  contents(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectContentOrderByInput
    skip: Int
    where: ProjectContentWhereInput
  ): [ProjectContent!]
  createdAt: DateTime!
  id: UUID!
  slug: String!
  tags(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectTagOrderByInput
    skip: Int
    where: ProjectTagWhereInput
  ): [ProjectTag!]
  updatedAt: DateTime!
}

type ProjectAlbum {
  createdAt: DateTime!
  id: UUID!
  images(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectImageOrderByInput
    skip: Int
    where: ProjectImageWhereInput
  ): [ProjectImage!]
  project: Project!
  updatedAt: DateTime!
}

input ProjectAlbumCreateOneWithoutProjectInput {
  connect: ProjectAlbumWhereUniqueInput
  create: ProjectAlbumCreateWithoutProjectInput
}

input ProjectAlbumCreateWithoutProjectInput {
  images: ProjectImageCreateManyWithoutAlbumInput
}

input ProjectAlbumUpdateOneRequiredWithoutProjectInput {
  connect: ProjectAlbumWhereUniqueInput
  create: ProjectAlbumCreateWithoutProjectInput
  update: ProjectAlbumUpdateWithoutProjectDataInput
  upsert: ProjectAlbumUpsertWithoutProjectInput
}

input ProjectAlbumUpdateWithoutProjectDataInput {
  images: ProjectImageUpdateManyWithoutAlbumInput
}

input ProjectAlbumUpsertWithoutProjectInput {
  create: ProjectAlbumCreateWithoutProjectInput!
  update: ProjectAlbumUpdateWithoutProjectDataInput!
}

input ProjectAlbumWhereInput {
  AND: [ProjectAlbumWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  images_every: ProjectImageWhereInput
  images_none: ProjectImageWhereInput
  images_some: ProjectImageWhereInput
  NOT: [ProjectAlbumWhereInput!]
  OR: [ProjectAlbumWhereInput!]
  project: ProjectWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectAlbumWhereUniqueInput {
  id: UUID
}

type ProjectCategory {
  contents(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectCategoryContentOrderByInput
    skip: Int
    where: ProjectCategoryContentWhereInput
  ): [ProjectCategoryContent!]
  createdAt: DateTime!
  id: UUID!
  image: String!
  projects(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectOrderByInput
    skip: Int
    where: ProjectWhereInput
  ): [Project!]
  slug: String!
  updatedAt: DateTime!
}

type ProjectCategoryContent {
  category: ProjectCategory!
  createdAt: DateTime!
  id: UUID!
  imageAlt: String!
  language: ProjectCategoryLng!
  metaDescription: String
  metaTitle: String
  text: String!
  title: String!
  updatedAt: DateTime!
}

input ProjectCategoryContentCreateManyWithoutCategoryInput {
  connect: [ProjectCategoryContentWhereUniqueInput!]
  create: [ProjectCategoryContentCreateWithoutCategoryInput!]
}

input ProjectCategoryContentCreateWithoutCategoryInput {
  imageAlt: String!
  language: ProjectCategoryLngCreateOneWithoutCategoriesInput!
  metaDescription: String
  metaTitle: String
  text: String!
  title: String!
}

enum ProjectCategoryContentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  imageAlt_ASC
  imageAlt_DESC
  metaDescription_ASC
  metaDescription_DESC
  metaTitle_ASC
  metaTitle_DESC
  text_ASC
  text_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProjectCategoryContentScalarWhereInput {
  AND: [ProjectCategoryContentScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  imageAlt: String
  imageAlt_contains: String
  imageAlt_ends_with: String
  imageAlt_gt: String
  imageAlt_gte: String
  imageAlt_in: [String!]
  imageAlt_lt: String
  imageAlt_lte: String
  imageAlt_not: String
  imageAlt_not_contains: String
  imageAlt_not_ends_with: String
  imageAlt_not_in: [String!]
  imageAlt_not_starts_with: String
  imageAlt_starts_with: String
  metaDescription: String
  metaDescription_contains: String
  metaDescription_ends_with: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_not: String
  metaDescription_not_contains: String
  metaDescription_not_ends_with: String
  metaDescription_not_in: [String!]
  metaDescription_not_starts_with: String
  metaDescription_starts_with: String
  metaTitle: String
  metaTitle_contains: String
  metaTitle_ends_with: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_not: String
  metaTitle_not_contains: String
  metaTitle_not_ends_with: String
  metaTitle_not_in: [String!]
  metaTitle_not_starts_with: String
  metaTitle_starts_with: String
  NOT: [ProjectCategoryContentScalarWhereInput!]
  OR: [ProjectCategoryContentScalarWhereInput!]
  text: String
  text_contains: String
  text_ends_with: String
  text_gt: String
  text_gte: String
  text_in: [String!]
  text_lt: String
  text_lte: String
  text_not: String
  text_not_contains: String
  text_not_ends_with: String
  text_not_in: [String!]
  text_not_starts_with: String
  text_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectCategoryContentUpdateManyDataInput {
  imageAlt: String
  metaDescription: String
  metaTitle: String
  text: String
  title: String
}

input ProjectCategoryContentUpdateManyWithoutCategoryInput {
  connect: [ProjectCategoryContentWhereUniqueInput!]
  create: [ProjectCategoryContentCreateWithoutCategoryInput!]
  delete: [ProjectCategoryContentWhereUniqueInput!]
  deleteMany: [ProjectCategoryContentScalarWhereInput!]
  disconnect: [ProjectCategoryContentWhereUniqueInput!]
  set: [ProjectCategoryContentWhereUniqueInput!]
  update: [ProjectCategoryContentUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [ProjectCategoryContentUpdateManyWithWhereNestedInput!]
  upsert: [ProjectCategoryContentUpsertWithWhereUniqueWithoutCategoryInput!]
}

input ProjectCategoryContentUpdateManyWithWhereNestedInput {
  data: ProjectCategoryContentUpdateManyDataInput!
  where: ProjectCategoryContentScalarWhereInput!
}

input ProjectCategoryContentUpdateWithoutCategoryDataInput {
  imageAlt: String
  language: ProjectCategoryLngUpdateOneRequiredWithoutCategoriesInput
  metaDescription: String
  metaTitle: String
  text: String
  title: String
}

input ProjectCategoryContentUpdateWithWhereUniqueWithoutCategoryInput {
  data: ProjectCategoryContentUpdateWithoutCategoryDataInput!
  where: ProjectCategoryContentWhereUniqueInput!
}

input ProjectCategoryContentUpsertWithWhereUniqueWithoutCategoryInput {
  create: ProjectCategoryContentCreateWithoutCategoryInput!
  update: ProjectCategoryContentUpdateWithoutCategoryDataInput!
  where: ProjectCategoryContentWhereUniqueInput!
}

input ProjectCategoryContentWhereInput {
  AND: [ProjectCategoryContentWhereInput!]
  category: ProjectCategoryWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  imageAlt: String
  imageAlt_contains: String
  imageAlt_ends_with: String
  imageAlt_gt: String
  imageAlt_gte: String
  imageAlt_in: [String!]
  imageAlt_lt: String
  imageAlt_lte: String
  imageAlt_not: String
  imageAlt_not_contains: String
  imageAlt_not_ends_with: String
  imageAlt_not_in: [String!]
  imageAlt_not_starts_with: String
  imageAlt_starts_with: String
  language: ProjectCategoryLngWhereInput
  metaDescription: String
  metaDescription_contains: String
  metaDescription_ends_with: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_not: String
  metaDescription_not_contains: String
  metaDescription_not_ends_with: String
  metaDescription_not_in: [String!]
  metaDescription_not_starts_with: String
  metaDescription_starts_with: String
  metaTitle: String
  metaTitle_contains: String
  metaTitle_ends_with: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_not: String
  metaTitle_not_contains: String
  metaTitle_not_ends_with: String
  metaTitle_not_in: [String!]
  metaTitle_not_starts_with: String
  metaTitle_starts_with: String
  NOT: [ProjectCategoryContentWhereInput!]
  OR: [ProjectCategoryContentWhereInput!]
  text: String
  text_contains: String
  text_ends_with: String
  text_gt: String
  text_gte: String
  text_in: [String!]
  text_lt: String
  text_lte: String
  text_not: String
  text_not_contains: String
  text_not_ends_with: String
  text_not_in: [String!]
  text_not_starts_with: String
  text_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectCategoryContentWhereUniqueInput {
  id: UUID
}

input ProjectCategoryCreateInput {
  contents: ProjectCategoryContentCreateManyWithoutCategoryInput
  image: String!
  projects: ProjectCreateManyWithoutCategoryInput
  slug: String!
}

input ProjectCategoryCreateOneWithoutProjectsInput {
  connect: ProjectCategoryWhereUniqueInput
  create: ProjectCategoryCreateWithoutProjectsInput
}

input ProjectCategoryCreateWithoutProjectsInput {
  contents: ProjectCategoryContentCreateManyWithoutCategoryInput
  image: String!
  slug: String!
}

type ProjectCategoryLng {
  categories(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectCategoryContentOrderByInput
    skip: Int
    where: ProjectCategoryContentWhereInput
  ): [ProjectCategoryContent!]
  country: String!
  id: UUID!
  locale: String
}

input ProjectCategoryLngCreateOneWithoutCategoriesInput {
  connect: ProjectCategoryLngWhereUniqueInput
  create: ProjectCategoryLngCreateWithoutCategoriesInput
}

input ProjectCategoryLngCreateWithoutCategoriesInput {
  country: String!
  locale: String
}

input ProjectCategoryLngUpdateOneRequiredWithoutCategoriesInput {
  connect: ProjectCategoryLngWhereUniqueInput
  create: ProjectCategoryLngCreateWithoutCategoriesInput
  update: ProjectCategoryLngUpdateWithoutCategoriesDataInput
  upsert: ProjectCategoryLngUpsertWithoutCategoriesInput
}

input ProjectCategoryLngUpdateWithoutCategoriesDataInput {
  country: String
  locale: String
}

input ProjectCategoryLngUpsertWithoutCategoriesInput {
  create: ProjectCategoryLngCreateWithoutCategoriesInput!
  update: ProjectCategoryLngUpdateWithoutCategoriesDataInput!
}

input ProjectCategoryLngWhereInput {
  AND: [ProjectCategoryLngWhereInput!]
  categories_every: ProjectCategoryContentWhereInput
  categories_none: ProjectCategoryContentWhereInput
  categories_some: ProjectCategoryContentWhereInput
  country: String
  country_contains: String
  country_ends_with: String
  country_gt: String
  country_gte: String
  country_in: [String!]
  country_lt: String
  country_lte: String
  country_not: String
  country_not_contains: String
  country_not_ends_with: String
  country_not_in: [String!]
  country_not_starts_with: String
  country_starts_with: String
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  locale: String
  locale_contains: String
  locale_ends_with: String
  locale_gt: String
  locale_gte: String
  locale_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_not: String
  locale_not_contains: String
  locale_not_ends_with: String
  locale_not_in: [String!]
  locale_not_starts_with: String
  locale_starts_with: String
  NOT: [ProjectCategoryLngWhereInput!]
  OR: [ProjectCategoryLngWhereInput!]
}

input ProjectCategoryLngWhereUniqueInput {
  country: String
  id: UUID
  locale: String
}

enum ProjectCategoryOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  image_ASC
  image_DESC
  slug_ASC
  slug_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProjectCategoryUpdateInput {
  contents: ProjectCategoryContentUpdateManyWithoutCategoryInput
  image: String
  projects: ProjectUpdateManyWithoutCategoryInput
  slug: String
}

input ProjectCategoryUpdateOneRequiredWithoutProjectsInput {
  connect: ProjectCategoryWhereUniqueInput
  create: ProjectCategoryCreateWithoutProjectsInput
  update: ProjectCategoryUpdateWithoutProjectsDataInput
  upsert: ProjectCategoryUpsertWithoutProjectsInput
}

input ProjectCategoryUpdateWithoutProjectsDataInput {
  contents: ProjectCategoryContentUpdateManyWithoutCategoryInput
  image: String
  slug: String
}

input ProjectCategoryUpsertWithoutProjectsInput {
  create: ProjectCategoryCreateWithoutProjectsInput!
  update: ProjectCategoryUpdateWithoutProjectsDataInput!
}

input ProjectCategoryWhereInput {
  AND: [ProjectCategoryWhereInput!]
  contents_every: ProjectCategoryContentWhereInput
  contents_none: ProjectCategoryContentWhereInput
  contents_some: ProjectCategoryContentWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  image: String
  image_contains: String
  image_ends_with: String
  image_gt: String
  image_gte: String
  image_in: [String!]
  image_lt: String
  image_lte: String
  image_not: String
  image_not_contains: String
  image_not_ends_with: String
  image_not_in: [String!]
  image_not_starts_with: String
  image_starts_with: String
  NOT: [ProjectCategoryWhereInput!]
  OR: [ProjectCategoryWhereInput!]
  projects_every: ProjectWhereInput
  projects_none: ProjectWhereInput
  projects_some: ProjectWhereInput
  slug: String
  slug_contains: String
  slug_ends_with: String
  slug_gt: String
  slug_gte: String
  slug_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_not: String
  slug_not_contains: String
  slug_not_ends_with: String
  slug_not_in: [String!]
  slug_not_starts_with: String
  slug_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectCategoryWhereUniqueInput {
  id: UUID
  slug: String
}

type ProjectContent {
  createdAt: DateTime!
  id: UUID!
  isActive: Boolean!
  language: ProjectLng!
  metaDescription: String
  metaTitle: String
  project: Project!
  text: String!
  title: String!
  updatedAt: DateTime!
}

input ProjectContentCreateManyWithoutProjectInput {
  connect: [ProjectContentWhereUniqueInput!]
  create: [ProjectContentCreateWithoutProjectInput!]
}

input ProjectContentCreateWithoutProjectInput {
  isActive: Boolean
  language: ProjectLngCreateOneWithoutProjectsInput!
  metaDescription: String
  metaTitle: String
  text: String!
  title: String!
}

enum ProjectContentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  isActive_ASC
  isActive_DESC
  metaDescription_ASC
  metaDescription_DESC
  metaTitle_ASC
  metaTitle_DESC
  text_ASC
  text_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProjectContentScalarWhereInput {
  AND: [ProjectContentScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  isActive: Boolean
  isActive_not: Boolean
  metaDescription: String
  metaDescription_contains: String
  metaDescription_ends_with: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_not: String
  metaDescription_not_contains: String
  metaDescription_not_ends_with: String
  metaDescription_not_in: [String!]
  metaDescription_not_starts_with: String
  metaDescription_starts_with: String
  metaTitle: String
  metaTitle_contains: String
  metaTitle_ends_with: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_not: String
  metaTitle_not_contains: String
  metaTitle_not_ends_with: String
  metaTitle_not_in: [String!]
  metaTitle_not_starts_with: String
  metaTitle_starts_with: String
  NOT: [ProjectContentScalarWhereInput!]
  OR: [ProjectContentScalarWhereInput!]
  text: String
  text_contains: String
  text_ends_with: String
  text_gt: String
  text_gte: String
  text_in: [String!]
  text_lt: String
  text_lte: String
  text_not: String
  text_not_contains: String
  text_not_ends_with: String
  text_not_in: [String!]
  text_not_starts_with: String
  text_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectContentUpdateManyDataInput {
  isActive: Boolean
  metaDescription: String
  metaTitle: String
  text: String
  title: String
}

input ProjectContentUpdateManyWithoutProjectInput {
  connect: [ProjectContentWhereUniqueInput!]
  create: [ProjectContentCreateWithoutProjectInput!]
  delete: [ProjectContentWhereUniqueInput!]
  deleteMany: [ProjectContentScalarWhereInput!]
  disconnect: [ProjectContentWhereUniqueInput!]
  set: [ProjectContentWhereUniqueInput!]
  update: [ProjectContentUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [ProjectContentUpdateManyWithWhereNestedInput!]
  upsert: [ProjectContentUpsertWithWhereUniqueWithoutProjectInput!]
}

input ProjectContentUpdateManyWithWhereNestedInput {
  data: ProjectContentUpdateManyDataInput!
  where: ProjectContentScalarWhereInput!
}

input ProjectContentUpdateWithoutProjectDataInput {
  isActive: Boolean
  language: ProjectLngUpdateOneRequiredWithoutProjectsInput
  metaDescription: String
  metaTitle: String
  text: String
  title: String
}

input ProjectContentUpdateWithWhereUniqueWithoutProjectInput {
  data: ProjectContentUpdateWithoutProjectDataInput!
  where: ProjectContentWhereUniqueInput!
}

input ProjectContentUpsertWithWhereUniqueWithoutProjectInput {
  create: ProjectContentCreateWithoutProjectInput!
  update: ProjectContentUpdateWithoutProjectDataInput!
  where: ProjectContentWhereUniqueInput!
}

input ProjectContentWhereInput {
  AND: [ProjectContentWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  isActive: Boolean
  isActive_not: Boolean
  language: ProjectLngWhereInput
  metaDescription: String
  metaDescription_contains: String
  metaDescription_ends_with: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_not: String
  metaDescription_not_contains: String
  metaDescription_not_ends_with: String
  metaDescription_not_in: [String!]
  metaDescription_not_starts_with: String
  metaDescription_starts_with: String
  metaTitle: String
  metaTitle_contains: String
  metaTitle_ends_with: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_not: String
  metaTitle_not_contains: String
  metaTitle_not_ends_with: String
  metaTitle_not_in: [String!]
  metaTitle_not_starts_with: String
  metaTitle_starts_with: String
  NOT: [ProjectContentWhereInput!]
  OR: [ProjectContentWhereInput!]
  project: ProjectWhereInput
  text: String
  text_contains: String
  text_ends_with: String
  text_gt: String
  text_gte: String
  text_in: [String!]
  text_lt: String
  text_lte: String
  text_not: String
  text_not_contains: String
  text_not_ends_with: String
  text_not_in: [String!]
  text_not_starts_with: String
  text_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectContentWhereUniqueInput {
  id: UUID
}

input ProjectCreateInput {
  album: ProjectAlbumCreateOneWithoutProjectInput!
  author: UserCreateOneWithoutProjectsInput!
  category: ProjectCategoryCreateOneWithoutProjectsInput!
  contents: ProjectContentCreateManyWithoutProjectInput
  slug: String!
  tags: ProjectTagCreateManyInput
}

input ProjectCreateManyWithoutAuthorInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutAuthorInput!]
}

input ProjectCreateManyWithoutCategoryInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutCategoryInput!]
}

input ProjectCreateWithoutAuthorInput {
  album: ProjectAlbumCreateOneWithoutProjectInput!
  category: ProjectCategoryCreateOneWithoutProjectsInput!
  contents: ProjectContentCreateManyWithoutProjectInput
  slug: String!
  tags: ProjectTagCreateManyInput
}

input ProjectCreateWithoutCategoryInput {
  album: ProjectAlbumCreateOneWithoutProjectInput!
  author: UserCreateOneWithoutProjectsInput!
  contents: ProjectContentCreateManyWithoutProjectInput
  slug: String!
  tags: ProjectTagCreateManyInput
}

type ProjectImage {
  album: ProjectAlbum!
  contents: ProjectImageContent!
  createdAt: DateTime!
  id: UUID!
  publicId: String!
  src: String!
  updatedAt: DateTime!
}

type ProjectImageContent {
  alt: String!
  createdAt: DateTime!
  id: UUID!
  image: ProjectImage!
  language: ProjectImageLng!
  updatedAt: DateTime!
}

input ProjectImageContentCreateOneWithoutImageInput {
  connect: ProjectImageContentWhereUniqueInput
  create: ProjectImageContentCreateWithoutImageInput
}

input ProjectImageContentCreateWithoutImageInput {
  alt: String!
  language: ProjectImageLngCreateOneWithoutImagesInput!
}

enum ProjectImageContentOrderByInput {
  alt_ASC
  alt_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProjectImageContentUpdateOneRequiredWithoutImageInput {
  connect: ProjectImageContentWhereUniqueInput
  create: ProjectImageContentCreateWithoutImageInput
  update: ProjectImageContentUpdateWithoutImageDataInput
  upsert: ProjectImageContentUpsertWithoutImageInput
}

input ProjectImageContentUpdateWithoutImageDataInput {
  alt: String
  language: ProjectImageLngUpdateOneRequiredWithoutImagesInput
}

input ProjectImageContentUpsertWithoutImageInput {
  create: ProjectImageContentCreateWithoutImageInput!
  update: ProjectImageContentUpdateWithoutImageDataInput!
}

input ProjectImageContentWhereInput {
  alt: String
  alt_contains: String
  alt_ends_with: String
  alt_gt: String
  alt_gte: String
  alt_in: [String!]
  alt_lt: String
  alt_lte: String
  alt_not: String
  alt_not_contains: String
  alt_not_ends_with: String
  alt_not_in: [String!]
  alt_not_starts_with: String
  alt_starts_with: String
  AND: [ProjectImageContentWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  image: ProjectImageWhereInput
  language: ProjectImageLngWhereInput
  NOT: [ProjectImageContentWhereInput!]
  OR: [ProjectImageContentWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectImageContentWhereUniqueInput {
  id: UUID
}

input ProjectImageCreateManyWithoutAlbumInput {
  connect: [ProjectImageWhereUniqueInput!]
  create: [ProjectImageCreateWithoutAlbumInput!]
}

input ProjectImageCreateWithoutAlbumInput {
  contents: ProjectImageContentCreateOneWithoutImageInput!
  publicId: String!
  src: String!
}

type ProjectImageLng {
  country: String!
  id: UUID!
  images(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectImageContentOrderByInput
    skip: Int
    where: ProjectImageContentWhereInput
  ): [ProjectImageContent!]
  locale: String
}

input ProjectImageLngCreateOneWithoutImagesInput {
  connect: ProjectImageLngWhereUniqueInput
  create: ProjectImageLngCreateWithoutImagesInput
}

input ProjectImageLngCreateWithoutImagesInput {
  country: String!
  locale: String
}

input ProjectImageLngUpdateOneRequiredWithoutImagesInput {
  connect: ProjectImageLngWhereUniqueInput
  create: ProjectImageLngCreateWithoutImagesInput
  update: ProjectImageLngUpdateWithoutImagesDataInput
  upsert: ProjectImageLngUpsertWithoutImagesInput
}

input ProjectImageLngUpdateWithoutImagesDataInput {
  country: String
  locale: String
}

input ProjectImageLngUpsertWithoutImagesInput {
  create: ProjectImageLngCreateWithoutImagesInput!
  update: ProjectImageLngUpdateWithoutImagesDataInput!
}

input ProjectImageLngWhereInput {
  AND: [ProjectImageLngWhereInput!]
  country: String
  country_contains: String
  country_ends_with: String
  country_gt: String
  country_gte: String
  country_in: [String!]
  country_lt: String
  country_lte: String
  country_not: String
  country_not_contains: String
  country_not_ends_with: String
  country_not_in: [String!]
  country_not_starts_with: String
  country_starts_with: String
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  images_every: ProjectImageContentWhereInput
  images_none: ProjectImageContentWhereInput
  images_some: ProjectImageContentWhereInput
  locale: String
  locale_contains: String
  locale_ends_with: String
  locale_gt: String
  locale_gte: String
  locale_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_not: String
  locale_not_contains: String
  locale_not_ends_with: String
  locale_not_in: [String!]
  locale_not_starts_with: String
  locale_starts_with: String
  NOT: [ProjectImageLngWhereInput!]
  OR: [ProjectImageLngWhereInput!]
}

input ProjectImageLngWhereUniqueInput {
  country: String
  id: UUID
  locale: String
}

enum ProjectImageOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  publicId_ASC
  publicId_DESC
  src_ASC
  src_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProjectImageScalarWhereInput {
  AND: [ProjectImageScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [ProjectImageScalarWhereInput!]
  OR: [ProjectImageScalarWhereInput!]
  publicId: String
  publicId_contains: String
  publicId_ends_with: String
  publicId_gt: String
  publicId_gte: String
  publicId_in: [String!]
  publicId_lt: String
  publicId_lte: String
  publicId_not: String
  publicId_not_contains: String
  publicId_not_ends_with: String
  publicId_not_in: [String!]
  publicId_not_starts_with: String
  publicId_starts_with: String
  src: String
  src_contains: String
  src_ends_with: String
  src_gt: String
  src_gte: String
  src_in: [String!]
  src_lt: String
  src_lte: String
  src_not: String
  src_not_contains: String
  src_not_ends_with: String
  src_not_in: [String!]
  src_not_starts_with: String
  src_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectImageUpdateManyDataInput {
  publicId: String
  src: String
}

input ProjectImageUpdateManyWithoutAlbumInput {
  connect: [ProjectImageWhereUniqueInput!]
  create: [ProjectImageCreateWithoutAlbumInput!]
  delete: [ProjectImageWhereUniqueInput!]
  deleteMany: [ProjectImageScalarWhereInput!]
  disconnect: [ProjectImageWhereUniqueInput!]
  set: [ProjectImageWhereUniqueInput!]
  update: [ProjectImageUpdateWithWhereUniqueWithoutAlbumInput!]
  updateMany: [ProjectImageUpdateManyWithWhereNestedInput!]
  upsert: [ProjectImageUpsertWithWhereUniqueWithoutAlbumInput!]
}

input ProjectImageUpdateManyWithWhereNestedInput {
  data: ProjectImageUpdateManyDataInput!
  where: ProjectImageScalarWhereInput!
}

input ProjectImageUpdateWithoutAlbumDataInput {
  contents: ProjectImageContentUpdateOneRequiredWithoutImageInput
  publicId: String
  src: String
}

input ProjectImageUpdateWithWhereUniqueWithoutAlbumInput {
  data: ProjectImageUpdateWithoutAlbumDataInput!
  where: ProjectImageWhereUniqueInput!
}

input ProjectImageUpsertWithWhereUniqueWithoutAlbumInput {
  create: ProjectImageCreateWithoutAlbumInput!
  update: ProjectImageUpdateWithoutAlbumDataInput!
  where: ProjectImageWhereUniqueInput!
}

input ProjectImageWhereInput {
  album: ProjectAlbumWhereInput
  AND: [ProjectImageWhereInput!]
  contents: ProjectImageContentWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [ProjectImageWhereInput!]
  OR: [ProjectImageWhereInput!]
  publicId: String
  publicId_contains: String
  publicId_ends_with: String
  publicId_gt: String
  publicId_gte: String
  publicId_in: [String!]
  publicId_lt: String
  publicId_lte: String
  publicId_not: String
  publicId_not_contains: String
  publicId_not_ends_with: String
  publicId_not_in: [String!]
  publicId_not_starts_with: String
  publicId_starts_with: String
  src: String
  src_contains: String
  src_ends_with: String
  src_gt: String
  src_gte: String
  src_in: [String!]
  src_lt: String
  src_lte: String
  src_not: String
  src_not_contains: String
  src_not_ends_with: String
  src_not_in: [String!]
  src_not_starts_with: String
  src_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectImageWhereUniqueInput {
  id: UUID
}

type ProjectLng {
  country: String!
  id: UUID!
  locale: String
  projects(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectContentOrderByInput
    skip: Int
    where: ProjectContentWhereInput
  ): [ProjectContent!]
}

input ProjectLngCreateOneWithoutProjectsInput {
  connect: ProjectLngWhereUniqueInput
  create: ProjectLngCreateWithoutProjectsInput
}

input ProjectLngCreateWithoutProjectsInput {
  country: String!
  locale: String
}

input ProjectLngUpdateOneRequiredWithoutProjectsInput {
  connect: ProjectLngWhereUniqueInput
  create: ProjectLngCreateWithoutProjectsInput
  update: ProjectLngUpdateWithoutProjectsDataInput
  upsert: ProjectLngUpsertWithoutProjectsInput
}

input ProjectLngUpdateWithoutProjectsDataInput {
  country: String
  locale: String
}

input ProjectLngUpsertWithoutProjectsInput {
  create: ProjectLngCreateWithoutProjectsInput!
  update: ProjectLngUpdateWithoutProjectsDataInput!
}

input ProjectLngWhereInput {
  AND: [ProjectLngWhereInput!]
  country: String
  country_contains: String
  country_ends_with: String
  country_gt: String
  country_gte: String
  country_in: [String!]
  country_lt: String
  country_lte: String
  country_not: String
  country_not_contains: String
  country_not_ends_with: String
  country_not_in: [String!]
  country_not_starts_with: String
  country_starts_with: String
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  locale: String
  locale_contains: String
  locale_ends_with: String
  locale_gt: String
  locale_gte: String
  locale_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_not: String
  locale_not_contains: String
  locale_not_ends_with: String
  locale_not_in: [String!]
  locale_not_starts_with: String
  locale_starts_with: String
  NOT: [ProjectLngWhereInput!]
  OR: [ProjectLngWhereInput!]
  projects_every: ProjectContentWhereInput
  projects_none: ProjectContentWhereInput
  projects_some: ProjectContentWhereInput
}

input ProjectLngWhereUniqueInput {
  country: String
  id: UUID
  locale: String
}

enum ProjectOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProjectScalarWhereInput {
  AND: [ProjectScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  slug: String
  slug_contains: String
  slug_ends_with: String
  slug_gt: String
  slug_gte: String
  slug_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_not: String
  slug_not_contains: String
  slug_not_ends_with: String
  slug_not_in: [String!]
  slug_not_starts_with: String
  slug_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

type ProjectTag {
  color: String
  contents: ProjectTagContent!
  createdAt: DateTime!
  id: UUID!
  language: ProjectTagLng!
  title: String!
  updatedAt: DateTime!
}

type ProjectTagContent {
  createdAt: DateTime!
  id: UUID!
  tag: ProjectTag!
  title: String
  updatedAt: DateTime!
}

input ProjectTagContentCreateOneWithoutTagInput {
  connect: ProjectTagContentWhereUniqueInput
  create: ProjectTagContentCreateWithoutTagInput
}

input ProjectTagContentCreateWithoutTagInput {
  title: String
}

input ProjectTagContentUpdateOneRequiredWithoutTagInput {
  connect: ProjectTagContentWhereUniqueInput
  create: ProjectTagContentCreateWithoutTagInput
  update: ProjectTagContentUpdateWithoutTagDataInput
  upsert: ProjectTagContentUpsertWithoutTagInput
}

input ProjectTagContentUpdateWithoutTagDataInput {
  title: String
}

input ProjectTagContentUpsertWithoutTagInput {
  create: ProjectTagContentCreateWithoutTagInput!
  update: ProjectTagContentUpdateWithoutTagDataInput!
}

input ProjectTagContentWhereInput {
  AND: [ProjectTagContentWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [ProjectTagContentWhereInput!]
  OR: [ProjectTagContentWhereInput!]
  tag: ProjectTagWhereInput
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectTagContentWhereUniqueInput {
  id: UUID
}

input ProjectTagCreateInput {
  color: String
  contents: ProjectTagContentCreateOneWithoutTagInput!
  language: ProjectTagLngCreateOneWithoutTagsInput!
  title: String!
}

input ProjectTagCreateManyInput {
  connect: [ProjectTagWhereUniqueInput!]
  create: [ProjectTagCreateInput!]
}

type ProjectTagLng {
  country: String!
  id: UUID!
  locale: String!
  tags(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectTagOrderByInput
    skip: Int
    where: ProjectTagWhereInput
  ): [ProjectTag!]
}

input ProjectTagLngCreateOneWithoutTagsInput {
  connect: ProjectTagLngWhereUniqueInput
  create: ProjectTagLngCreateWithoutTagsInput
}

input ProjectTagLngCreateWithoutTagsInput {
  country: String!
  locale: String!
}

input ProjectTagLngUpdateOneRequiredWithoutTagsInput {
  connect: ProjectTagLngWhereUniqueInput
  create: ProjectTagLngCreateWithoutTagsInput
  update: ProjectTagLngUpdateWithoutTagsDataInput
  upsert: ProjectTagLngUpsertWithoutTagsInput
}

input ProjectTagLngUpdateWithoutTagsDataInput {
  country: String
  locale: String
}

input ProjectTagLngUpsertWithoutTagsInput {
  create: ProjectTagLngCreateWithoutTagsInput!
  update: ProjectTagLngUpdateWithoutTagsDataInput!
}

input ProjectTagLngWhereInput {
  AND: [ProjectTagLngWhereInput!]
  country: String
  country_contains: String
  country_ends_with: String
  country_gt: String
  country_gte: String
  country_in: [String!]
  country_lt: String
  country_lte: String
  country_not: String
  country_not_contains: String
  country_not_ends_with: String
  country_not_in: [String!]
  country_not_starts_with: String
  country_starts_with: String
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  locale: String
  locale_contains: String
  locale_ends_with: String
  locale_gt: String
  locale_gte: String
  locale_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_not: String
  locale_not_contains: String
  locale_not_ends_with: String
  locale_not_in: [String!]
  locale_not_starts_with: String
  locale_starts_with: String
  NOT: [ProjectTagLngWhereInput!]
  OR: [ProjectTagLngWhereInput!]
  tags_every: ProjectTagWhereInput
  tags_none: ProjectTagWhereInput
  tags_some: ProjectTagWhereInput
}

input ProjectTagLngWhereUniqueInput {
  id: UUID
}

enum ProjectTagOrderByInput {
  color_ASC
  color_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProjectTagScalarWhereInput {
  AND: [ProjectTagScalarWhereInput!]
  color: String
  color_contains: String
  color_ends_with: String
  color_gt: String
  color_gte: String
  color_in: [String!]
  color_lt: String
  color_lte: String
  color_not: String
  color_not_contains: String
  color_not_ends_with: String
  color_not_in: [String!]
  color_not_starts_with: String
  color_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [ProjectTagScalarWhereInput!]
  OR: [ProjectTagScalarWhereInput!]
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectTagUpdateDataInput {
  color: String
  contents: ProjectTagContentUpdateOneRequiredWithoutTagInput
  language: ProjectTagLngUpdateOneRequiredWithoutTagsInput
  title: String
}

input ProjectTagUpdateManyDataInput {
  color: String
  title: String
}

input ProjectTagUpdateManyInput {
  connect: [ProjectTagWhereUniqueInput!]
  create: [ProjectTagCreateInput!]
  delete: [ProjectTagWhereUniqueInput!]
  deleteMany: [ProjectTagScalarWhereInput!]
  disconnect: [ProjectTagWhereUniqueInput!]
  set: [ProjectTagWhereUniqueInput!]
  update: [ProjectTagUpdateWithWhereUniqueNestedInput!]
  updateMany: [ProjectTagUpdateManyWithWhereNestedInput!]
  upsert: [ProjectTagUpsertWithWhereUniqueNestedInput!]
}

input ProjectTagUpdateManyWithWhereNestedInput {
  data: ProjectTagUpdateManyDataInput!
  where: ProjectTagScalarWhereInput!
}

input ProjectTagUpdateWithWhereUniqueNestedInput {
  data: ProjectTagUpdateDataInput!
  where: ProjectTagWhereUniqueInput!
}

input ProjectTagUpsertWithWhereUniqueNestedInput {
  create: ProjectTagCreateInput!
  update: ProjectTagUpdateDataInput!
  where: ProjectTagWhereUniqueInput!
}

input ProjectTagWhereInput {
  AND: [ProjectTagWhereInput!]
  color: String
  color_contains: String
  color_ends_with: String
  color_gt: String
  color_gte: String
  color_in: [String!]
  color_lt: String
  color_lte: String
  color_not: String
  color_not_contains: String
  color_not_ends_with: String
  color_not_in: [String!]
  color_not_starts_with: String
  color_starts_with: String
  contents: ProjectTagContentWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  language: ProjectTagLngWhereInput
  NOT: [ProjectTagWhereInput!]
  OR: [ProjectTagWhereInput!]
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectTagWhereUniqueInput {
  id: UUID
}

input ProjectUpdateInput {
  album: ProjectAlbumUpdateOneRequiredWithoutProjectInput
  author: UserUpdateOneRequiredWithoutProjectsInput
  category: ProjectCategoryUpdateOneRequiredWithoutProjectsInput
  contents: ProjectContentUpdateManyWithoutProjectInput
  slug: String
  tags: ProjectTagUpdateManyInput
}

input ProjectUpdateManyDataInput {
  slug: String
}

input ProjectUpdateManyWithoutAuthorInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutAuthorInput!]
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutAuthorInput!]
}

input ProjectUpdateManyWithoutCategoryInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutCategoryInput!]
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutCategoryInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  data: ProjectUpdateManyDataInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateWithoutAuthorDataInput {
  album: ProjectAlbumUpdateOneRequiredWithoutProjectInput
  category: ProjectCategoryUpdateOneRequiredWithoutProjectsInput
  contents: ProjectContentUpdateManyWithoutProjectInput
  slug: String
  tags: ProjectTagUpdateManyInput
}

input ProjectUpdateWithoutCategoryDataInput {
  album: ProjectAlbumUpdateOneRequiredWithoutProjectInput
  author: UserUpdateOneRequiredWithoutProjectsInput
  contents: ProjectContentUpdateManyWithoutProjectInput
  slug: String
  tags: ProjectTagUpdateManyInput
}

input ProjectUpdateWithWhereUniqueWithoutAuthorInput {
  data: ProjectUpdateWithoutAuthorDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithWhereUniqueWithoutCategoryInput {
  data: ProjectUpdateWithoutCategoryDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithWhereUniqueWithoutAuthorInput {
  create: ProjectCreateWithoutAuthorInput!
  update: ProjectUpdateWithoutAuthorDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithWhereUniqueWithoutCategoryInput {
  create: ProjectCreateWithoutCategoryInput!
  update: ProjectUpdateWithoutCategoryDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectWhereInput {
  album: ProjectAlbumWhereInput
  AND: [ProjectWhereInput!]
  author: UserWhereInput
  category: ProjectCategoryWhereInput
  contents_every: ProjectContentWhereInput
  contents_none: ProjectContentWhereInput
  contents_some: ProjectContentWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  slug: String
  slug_contains: String
  slug_ends_with: String
  slug_gt: String
  slug_gte: String
  slug_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_not: String
  slug_not_contains: String
  slug_not_ends_with: String
  slug_not_in: [String!]
  slug_not_starts_with: String
  slug_starts_with: String
  tags_every: ProjectTagWhereInput
  tags_none: ProjectTagWhereInput
  tags_some: ProjectTagWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProjectWhereUniqueInput {
  id: UUID
  slug: String
}

type Query {
  me: User
  postBySlug(slug: String!): Post
  postFeed: [Post!]
  posts(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PostOrderByInput
    skip: Int
    where: PostWhereInput
  ): [Post!]!
  postsAll: [Post!]
  postsByIsPublished(
    after: String
    before: String
    first: Int
    isPublished: Boolean!
    last: Int
    orderBy: PostOrderByInput
    skip: Int
  ): [Post!]
  postsByUser(id: ID!): [Post!]!
  postTag(where: PostTagWhereUniqueInput!): PostTag
  project(where: ProjectWhereUniqueInput!): Project
  projectById(id: ID!): Project
  projectBySlug(slug: String!): Project
  projectCategories(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectCategoryOrderByInput
    skip: Int
    where: ProjectCategoryWhereInput
  ): [ProjectCategory!]!
  projectCategoriesAll(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectCategoryOrderByInput
    skip: Int
  ): [ProjectCategory!]
  projectCategory(where: ProjectCategoryWhereUniqueInput!): ProjectCategory
  projectCategoryById(id: ID!): ProjectCategory
  projectCategoryBySlug(slug: String!): ProjectCategory
  projects(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectOrderByInput
    skip: Int
    where: ProjectWhereInput
  ): [Project!]!
  projectTag(where: ProjectTagWhereUniqueInput!): ProjectTag
  user(where: UserWhereUniqueInput!): User
}

enum Role {
  ADMIN
  SITEMANAGER
  USER
}

type User {
  comments(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: CommentOrderByInput
    skip: Int
    where: CommentWhereInput
  ): [Comment!]
  createdAt: DateTime!
  email: String
  id: UUID!
  name: String!
  password: String!
  postLikes(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PostOrderByInput
    skip: Int
    where: PostWhereInput
  ): [Post!]
  posts(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PostOrderByInput
    skip: Int
    where: PostWhereInput
  ): [Post!]
  profile: Profile
  projects(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectOrderByInput
    skip: Int
    where: ProjectWhereInput
  ): [Project!]
  role: Role!
  updatedAt: DateTime!
}

input UserCreateManyWithoutPostLikesInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutPostLikesInput!]
}

input UserCreateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
}

input UserCreateOneWithoutProjectsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutProjectsInput
}

input UserCreateWithoutCommentsInput {
  email: String
  name: String!
  password: String!
  postLikes: PostCreateManyWithoutLikedByInput
  posts: PostCreateManyWithoutAuthorInput
  profile: ProfileCreateOneWithoutUserInput
  projects: ProjectCreateManyWithoutAuthorInput
  role: Role
}

input UserCreateWithoutPostLikesInput {
  comments: CommentCreateManyWithoutAuthorInput
  email: String
  name: String!
  password: String!
  posts: PostCreateManyWithoutAuthorInput
  profile: ProfileCreateOneWithoutUserInput
  projects: ProjectCreateManyWithoutAuthorInput
  role: Role
}

input UserCreateWithoutPostsInput {
  comments: CommentCreateManyWithoutAuthorInput
  email: String
  name: String!
  password: String!
  postLikes: PostCreateManyWithoutLikedByInput
  profile: ProfileCreateOneWithoutUserInput
  projects: ProjectCreateManyWithoutAuthorInput
  role: Role
}

input UserCreateWithoutProjectsInput {
  comments: CommentCreateManyWithoutAuthorInput
  email: String
  name: String!
  password: String!
  postLikes: PostCreateManyWithoutLikedByInput
  posts: PostCreateManyWithoutAuthorInput
  profile: ProfileCreateOneWithoutUserInput
  role: Role
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  role: Role
  role_in: [Role!]
  role_not: Role
  role_not_in: [Role!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input UserUpdateInput {
  comments: CommentUpdateManyWithoutAuthorInput
  email: String
  name: String
  password: String
  postLikes: PostUpdateManyWithoutLikedByInput
  posts: PostUpdateManyWithoutAuthorInput
  profile: ProfileUpdateOneWithoutUserInput
  projects: ProjectUpdateManyWithoutAuthorInput
  role: Role
}

input UserUpdateManyDataInput {
  email: String
  name: String
  password: String
  role: Role
}

input UserUpdateManyWithoutPostLikesInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutPostLikesInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutPostLikesInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutPostLikesInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateOneRequiredWithoutCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateOneRequiredWithoutPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateOneRequiredWithoutProjectsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutProjectsInput
  update: UserUpdateWithoutProjectsDataInput
  upsert: UserUpsertWithoutProjectsInput
}

input UserUpdateWithoutCommentsDataInput {
  email: String
  name: String
  password: String
  postLikes: PostUpdateManyWithoutLikedByInput
  posts: PostUpdateManyWithoutAuthorInput
  profile: ProfileUpdateOneWithoutUserInput
  projects: ProjectUpdateManyWithoutAuthorInput
  role: Role
}

input UserUpdateWithoutPostLikesDataInput {
  comments: CommentUpdateManyWithoutAuthorInput
  email: String
  name: String
  password: String
  posts: PostUpdateManyWithoutAuthorInput
  profile: ProfileUpdateOneWithoutUserInput
  projects: ProjectUpdateManyWithoutAuthorInput
  role: Role
}

input UserUpdateWithoutPostsDataInput {
  comments: CommentUpdateManyWithoutAuthorInput
  email: String
  name: String
  password: String
  postLikes: PostUpdateManyWithoutLikedByInput
  profile: ProfileUpdateOneWithoutUserInput
  projects: ProjectUpdateManyWithoutAuthorInput
  role: Role
}

input UserUpdateWithoutProjectsDataInput {
  comments: CommentUpdateManyWithoutAuthorInput
  email: String
  name: String
  password: String
  postLikes: PostUpdateManyWithoutLikedByInput
  posts: PostUpdateManyWithoutAuthorInput
  profile: ProfileUpdateOneWithoutUserInput
  role: Role
}

input UserUpdateWithWhereUniqueWithoutPostLikesInput {
  data: UserUpdateWithoutPostLikesDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsDataInput!
}

input UserUpsertWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  update: UserUpdateWithoutPostsDataInput!
}

input UserUpsertWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  update: UserUpdateWithoutProjectsDataInput!
}

input UserUpsertWithWhereUniqueWithoutPostLikesInput {
  create: UserCreateWithoutPostLikesInput!
  update: UserUpdateWithoutPostLikesDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  comments_every: CommentWhereInput
  comments_none: CommentWhereInput
  comments_some: CommentWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: UUID
  id_contains: UUID
  id_ends_with: UUID
  id_gt: UUID
  id_gte: UUID
  id_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_not: UUID
  id_not_contains: UUID
  id_not_ends_with: UUID
  id_not_in: [UUID!]
  id_not_starts_with: UUID
  id_starts_with: UUID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  postLikes_every: PostWhereInput
  postLikes_none: PostWhereInput
  postLikes_some: PostWhereInput
  posts_every: PostWhereInput
  posts_none: PostWhereInput
  posts_some: PostWhereInput
  profile: ProfileWhereInput
  projects_every: ProjectWhereInput
  projects_none: ProjectWhereInput
  projects_some: ProjectWhereInput
  role: Role
  role_in: [Role!]
  role_not: Role
  role_not_in: [Role!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input UserWhereUniqueInput {
  email: String
  id: UUID
}

scalar UUID
