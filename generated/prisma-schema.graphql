type AggregateAvatar {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregatePostContent {
  count: Int!
}

type AggregatePostLng {
  count: Int!
}

type AggregatePostTag {
  count: Int!
}

type AggregatePostTagContent {
  count: Int!
}

type AggregatePostTagLng {
  count: Int!
}

type AggregateProfile {
  count: Int!
}

type AggregateProject {
  count: Int!
}

type AggregateProjectAlbum {
  count: Int!
}

type AggregateProjectCategory {
  count: Int!
}

type AggregateProjectCategoryContent {
  count: Int!
}

type AggregateProjectCategoryLng {
  count: Int!
}

type AggregateProjectContent {
  count: Int!
}

type AggregateProjectImage {
  count: Int!
}

type AggregateProjectImageContent {
  count: Int!
}

type AggregateProjectImageLng {
  count: Int!
}

type AggregateProjectLng {
  count: Int!
}

type AggregateProjectTag {
  count: Int!
}

type AggregateProjectTagContent {
  count: Int!
}

type AggregateProjectTagLng {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Avatar {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  publicId: String
  src: String
}

type AvatarConnection {
  pageInfo: PageInfo!
  edges: [AvatarEdge]!
  aggregate: AggregateAvatar!
}

input AvatarCreateInput {
  id: UUID
  publicId: String
  src: String
}

input AvatarCreateOneInput {
  create: AvatarCreateInput
  connect: AvatarWhereUniqueInput
}

type AvatarEdge {
  node: Avatar!
  cursor: String!
}

enum AvatarOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  publicId_ASC
  publicId_DESC
  src_ASC
  src_DESC
}

type AvatarPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  publicId: String
  src: String
}

type AvatarSubscriptionPayload {
  mutation: MutationType!
  node: Avatar
  updatedFields: [String!]
  previousValues: AvatarPreviousValues
}

input AvatarSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AvatarWhereInput
  AND: [AvatarSubscriptionWhereInput!]
  OR: [AvatarSubscriptionWhereInput!]
  NOT: [AvatarSubscriptionWhereInput!]
}

input AvatarUpdateDataInput {
  publicId: String
  src: String
}

input AvatarUpdateInput {
  publicId: String
  src: String
}

input AvatarUpdateManyMutationInput {
  publicId: String
  src: String
}

input AvatarUpdateOneRequiredInput {
  create: AvatarCreateInput
  update: AvatarUpdateDataInput
  upsert: AvatarUpsertNestedInput
  connect: AvatarWhereUniqueInput
}

input AvatarUpsertNestedInput {
  update: AvatarUpdateDataInput!
  create: AvatarCreateInput!
}

input AvatarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  publicId: String
  publicId_not: String
  publicId_in: [String!]
  publicId_not_in: [String!]
  publicId_lt: String
  publicId_lte: String
  publicId_gt: String
  publicId_gte: String
  publicId_contains: String
  publicId_not_contains: String
  publicId_starts_with: String
  publicId_not_starts_with: String
  publicId_ends_with: String
  publicId_not_ends_with: String
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  AND: [AvatarWhereInput!]
  OR: [AvatarWhereInput!]
  NOT: [AvatarWhereInput!]
}

input AvatarWhereUniqueInput {
  id: UUID
}

type BatchPayload {
  count: Long!
}

type Comment {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  author: User!
  post: Post!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: UUID
  author: UserCreateOneWithoutCommentsInput!
  post: PostCreateOneWithoutCommentsInput!
}

input CommentCreateManyWithoutAuthorInput {
  create: [CommentCreateWithoutAuthorInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutAuthorInput {
  id: UUID
  post: PostCreateOneWithoutCommentsInput!
}

input CommentCreateWithoutPostInput {
  id: UUID
  author: UserCreateOneWithoutCommentsInput!
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CommentPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CommentScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  author: UserUpdateOneRequiredWithoutCommentsInput
  post: PostUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateManyWithoutAuthorInput {
  create: [CommentCreateWithoutAuthorInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpdateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpdateWithoutAuthorDataInput {
  post: PostUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateWithoutPostDataInput {
  author: UserUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutAuthorDataInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPostDataInput!
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutAuthorDataInput!
  create: CommentCreateWithoutAuthorInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPostDataInput!
  create: CommentCreateWithoutPostInput!
}

input CommentWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  author: UserWhereInput
  post: PostWhereInput
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: UUID
}

scalar DateTime

scalar Long

type Mutation {
  createAvatar(data: AvatarCreateInput!): Avatar!
  updateAvatar(data: AvatarUpdateInput!, where: AvatarWhereUniqueInput!): Avatar
  updateManyAvatars(data: AvatarUpdateManyMutationInput!, where: AvatarWhereInput): BatchPayload!
  upsertAvatar(where: AvatarWhereUniqueInput!, create: AvatarCreateInput!, update: AvatarUpdateInput!): Avatar!
  deleteAvatar(where: AvatarWhereUniqueInput!): Avatar
  deleteManyAvatars(where: AvatarWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createPostContent(data: PostContentCreateInput!): PostContent!
  updatePostContent(data: PostContentUpdateInput!, where: PostContentWhereUniqueInput!): PostContent
  updateManyPostContents(data: PostContentUpdateManyMutationInput!, where: PostContentWhereInput): BatchPayload!
  upsertPostContent(where: PostContentWhereUniqueInput!, create: PostContentCreateInput!, update: PostContentUpdateInput!): PostContent!
  deletePostContent(where: PostContentWhereUniqueInput!): PostContent
  deleteManyPostContents(where: PostContentWhereInput): BatchPayload!
  createPostLng(data: PostLngCreateInput!): PostLng!
  updatePostLng(data: PostLngUpdateInput!, where: PostLngWhereUniqueInput!): PostLng
  updateManyPostLngs(data: PostLngUpdateManyMutationInput!, where: PostLngWhereInput): BatchPayload!
  upsertPostLng(where: PostLngWhereUniqueInput!, create: PostLngCreateInput!, update: PostLngUpdateInput!): PostLng!
  deletePostLng(where: PostLngWhereUniqueInput!): PostLng
  deleteManyPostLngs(where: PostLngWhereInput): BatchPayload!
  createPostTag(data: PostTagCreateInput!): PostTag!
  updatePostTag(data: PostTagUpdateInput!, where: PostTagWhereUniqueInput!): PostTag
  updateManyPostTags(data: PostTagUpdateManyMutationInput!, where: PostTagWhereInput): BatchPayload!
  upsertPostTag(where: PostTagWhereUniqueInput!, create: PostTagCreateInput!, update: PostTagUpdateInput!): PostTag!
  deletePostTag(where: PostTagWhereUniqueInput!): PostTag
  deleteManyPostTags(where: PostTagWhereInput): BatchPayload!
  createPostTagContent(data: PostTagContentCreateInput!): PostTagContent!
  updatePostTagContent(data: PostTagContentUpdateInput!, where: PostTagContentWhereUniqueInput!): PostTagContent
  updateManyPostTagContents(data: PostTagContentUpdateManyMutationInput!, where: PostTagContentWhereInput): BatchPayload!
  upsertPostTagContent(where: PostTagContentWhereUniqueInput!, create: PostTagContentCreateInput!, update: PostTagContentUpdateInput!): PostTagContent!
  deletePostTagContent(where: PostTagContentWhereUniqueInput!): PostTagContent
  deleteManyPostTagContents(where: PostTagContentWhereInput): BatchPayload!
  createPostTagLng(data: PostTagLngCreateInput!): PostTagLng!
  updatePostTagLng(data: PostTagLngUpdateInput!, where: PostTagLngWhereUniqueInput!): PostTagLng
  updateManyPostTagLngs(data: PostTagLngUpdateManyMutationInput!, where: PostTagLngWhereInput): BatchPayload!
  upsertPostTagLng(where: PostTagLngWhereUniqueInput!, create: PostTagLngCreateInput!, update: PostTagLngUpdateInput!): PostTagLng!
  deletePostTagLng(where: PostTagLngWhereUniqueInput!): PostTagLng
  deleteManyPostTagLngs(where: PostTagLngWhereInput): BatchPayload!
  createProfile(data: ProfileCreateInput!): Profile!
  updateProfile(data: ProfileUpdateInput!, where: ProfileWhereUniqueInput!): Profile
  updateManyProfiles(data: ProfileUpdateManyMutationInput!, where: ProfileWhereInput): BatchPayload!
  upsertProfile(where: ProfileWhereUniqueInput!, create: ProfileCreateInput!, update: ProfileUpdateInput!): Profile!
  deleteProfile(where: ProfileWhereUniqueInput!): Profile
  deleteManyProfiles(where: ProfileWhereInput): BatchPayload!
  createProject(data: ProjectCreateInput!): Project!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  upsertProject(where: ProjectWhereUniqueInput!, create: ProjectCreateInput!, update: ProjectUpdateInput!): Project!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  createProjectAlbum(data: ProjectAlbumCreateInput!): ProjectAlbum!
  updateProjectAlbum(data: ProjectAlbumUpdateInput!, where: ProjectAlbumWhereUniqueInput!): ProjectAlbum
  upsertProjectAlbum(where: ProjectAlbumWhereUniqueInput!, create: ProjectAlbumCreateInput!, update: ProjectAlbumUpdateInput!): ProjectAlbum!
  deleteProjectAlbum(where: ProjectAlbumWhereUniqueInput!): ProjectAlbum
  deleteManyProjectAlbums(where: ProjectAlbumWhereInput): BatchPayload!
  createProjectCategory(data: ProjectCategoryCreateInput!): ProjectCategory!
  updateProjectCategory(data: ProjectCategoryUpdateInput!, where: ProjectCategoryWhereUniqueInput!): ProjectCategory
  updateManyProjectCategories(data: ProjectCategoryUpdateManyMutationInput!, where: ProjectCategoryWhereInput): BatchPayload!
  upsertProjectCategory(where: ProjectCategoryWhereUniqueInput!, create: ProjectCategoryCreateInput!, update: ProjectCategoryUpdateInput!): ProjectCategory!
  deleteProjectCategory(where: ProjectCategoryWhereUniqueInput!): ProjectCategory
  deleteManyProjectCategories(where: ProjectCategoryWhereInput): BatchPayload!
  createProjectCategoryContent(data: ProjectCategoryContentCreateInput!): ProjectCategoryContent!
  updateProjectCategoryContent(data: ProjectCategoryContentUpdateInput!, where: ProjectCategoryContentWhereUniqueInput!): ProjectCategoryContent
  updateManyProjectCategoryContents(data: ProjectCategoryContentUpdateManyMutationInput!, where: ProjectCategoryContentWhereInput): BatchPayload!
  upsertProjectCategoryContent(where: ProjectCategoryContentWhereUniqueInput!, create: ProjectCategoryContentCreateInput!, update: ProjectCategoryContentUpdateInput!): ProjectCategoryContent!
  deleteProjectCategoryContent(where: ProjectCategoryContentWhereUniqueInput!): ProjectCategoryContent
  deleteManyProjectCategoryContents(where: ProjectCategoryContentWhereInput): BatchPayload!
  createProjectCategoryLng(data: ProjectCategoryLngCreateInput!): ProjectCategoryLng!
  updateProjectCategoryLng(data: ProjectCategoryLngUpdateInput!, where: ProjectCategoryLngWhereUniqueInput!): ProjectCategoryLng
  updateManyProjectCategoryLngs(data: ProjectCategoryLngUpdateManyMutationInput!, where: ProjectCategoryLngWhereInput): BatchPayload!
  upsertProjectCategoryLng(where: ProjectCategoryLngWhereUniqueInput!, create: ProjectCategoryLngCreateInput!, update: ProjectCategoryLngUpdateInput!): ProjectCategoryLng!
  deleteProjectCategoryLng(where: ProjectCategoryLngWhereUniqueInput!): ProjectCategoryLng
  deleteManyProjectCategoryLngs(where: ProjectCategoryLngWhereInput): BatchPayload!
  createProjectContent(data: ProjectContentCreateInput!): ProjectContent!
  updateProjectContent(data: ProjectContentUpdateInput!, where: ProjectContentWhereUniqueInput!): ProjectContent
  updateManyProjectContents(data: ProjectContentUpdateManyMutationInput!, where: ProjectContentWhereInput): BatchPayload!
  upsertProjectContent(where: ProjectContentWhereUniqueInput!, create: ProjectContentCreateInput!, update: ProjectContentUpdateInput!): ProjectContent!
  deleteProjectContent(where: ProjectContentWhereUniqueInput!): ProjectContent
  deleteManyProjectContents(where: ProjectContentWhereInput): BatchPayload!
  createProjectImage(data: ProjectImageCreateInput!): ProjectImage!
  updateProjectImage(data: ProjectImageUpdateInput!, where: ProjectImageWhereUniqueInput!): ProjectImage
  updateManyProjectImages(data: ProjectImageUpdateManyMutationInput!, where: ProjectImageWhereInput): BatchPayload!
  upsertProjectImage(where: ProjectImageWhereUniqueInput!, create: ProjectImageCreateInput!, update: ProjectImageUpdateInput!): ProjectImage!
  deleteProjectImage(where: ProjectImageWhereUniqueInput!): ProjectImage
  deleteManyProjectImages(where: ProjectImageWhereInput): BatchPayload!
  createProjectImageContent(data: ProjectImageContentCreateInput!): ProjectImageContent!
  updateProjectImageContent(data: ProjectImageContentUpdateInput!, where: ProjectImageContentWhereUniqueInput!): ProjectImageContent
  updateManyProjectImageContents(data: ProjectImageContentUpdateManyMutationInput!, where: ProjectImageContentWhereInput): BatchPayload!
  upsertProjectImageContent(where: ProjectImageContentWhereUniqueInput!, create: ProjectImageContentCreateInput!, update: ProjectImageContentUpdateInput!): ProjectImageContent!
  deleteProjectImageContent(where: ProjectImageContentWhereUniqueInput!): ProjectImageContent
  deleteManyProjectImageContents(where: ProjectImageContentWhereInput): BatchPayload!
  createProjectImageLng(data: ProjectImageLngCreateInput!): ProjectImageLng!
  updateProjectImageLng(data: ProjectImageLngUpdateInput!, where: ProjectImageLngWhereUniqueInput!): ProjectImageLng
  updateManyProjectImageLngs(data: ProjectImageLngUpdateManyMutationInput!, where: ProjectImageLngWhereInput): BatchPayload!
  upsertProjectImageLng(where: ProjectImageLngWhereUniqueInput!, create: ProjectImageLngCreateInput!, update: ProjectImageLngUpdateInput!): ProjectImageLng!
  deleteProjectImageLng(where: ProjectImageLngWhereUniqueInput!): ProjectImageLng
  deleteManyProjectImageLngs(where: ProjectImageLngWhereInput): BatchPayload!
  createProjectLng(data: ProjectLngCreateInput!): ProjectLng!
  updateProjectLng(data: ProjectLngUpdateInput!, where: ProjectLngWhereUniqueInput!): ProjectLng
  updateManyProjectLngs(data: ProjectLngUpdateManyMutationInput!, where: ProjectLngWhereInput): BatchPayload!
  upsertProjectLng(where: ProjectLngWhereUniqueInput!, create: ProjectLngCreateInput!, update: ProjectLngUpdateInput!): ProjectLng!
  deleteProjectLng(where: ProjectLngWhereUniqueInput!): ProjectLng
  deleteManyProjectLngs(where: ProjectLngWhereInput): BatchPayload!
  createProjectTag(data: ProjectTagCreateInput!): ProjectTag!
  updateProjectTag(data: ProjectTagUpdateInput!, where: ProjectTagWhereUniqueInput!): ProjectTag
  updateManyProjectTags(data: ProjectTagUpdateManyMutationInput!, where: ProjectTagWhereInput): BatchPayload!
  upsertProjectTag(where: ProjectTagWhereUniqueInput!, create: ProjectTagCreateInput!, update: ProjectTagUpdateInput!): ProjectTag!
  deleteProjectTag(where: ProjectTagWhereUniqueInput!): ProjectTag
  deleteManyProjectTags(where: ProjectTagWhereInput): BatchPayload!
  createProjectTagContent(data: ProjectTagContentCreateInput!): ProjectTagContent!
  updateProjectTagContent(data: ProjectTagContentUpdateInput!, where: ProjectTagContentWhereUniqueInput!): ProjectTagContent
  updateManyProjectTagContents(data: ProjectTagContentUpdateManyMutationInput!, where: ProjectTagContentWhereInput): BatchPayload!
  upsertProjectTagContent(where: ProjectTagContentWhereUniqueInput!, create: ProjectTagContentCreateInput!, update: ProjectTagContentUpdateInput!): ProjectTagContent!
  deleteProjectTagContent(where: ProjectTagContentWhereUniqueInput!): ProjectTagContent
  deleteManyProjectTagContents(where: ProjectTagContentWhereInput): BatchPayload!
  createProjectTagLng(data: ProjectTagLngCreateInput!): ProjectTagLng!
  updateProjectTagLng(data: ProjectTagLngUpdateInput!, where: ProjectTagLngWhereUniqueInput!): ProjectTagLng
  updateManyProjectTagLngs(data: ProjectTagLngUpdateManyMutationInput!, where: ProjectTagLngWhereInput): BatchPayload!
  upsertProjectTagLng(where: ProjectTagLngWhereUniqueInput!, create: ProjectTagLngCreateInput!, update: ProjectTagLngUpdateInput!): ProjectTagLng!
  deleteProjectTagLng(where: ProjectTagLngWhereUniqueInput!): ProjectTagLng
  deleteManyProjectTagLngs(where: ProjectTagLngWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Post {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  author: User!
  slug: String!
  isPublished: Boolean!
  imageSrc: String!
  contents(where: PostContentWhereInput, orderBy: PostContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostContent!]
  tags(where: PostTagWhereInput, orderBy: PostTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostTag!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  likes: Int
  likedBy(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

type PostContent {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  language: PostLng!
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  imageAlt: String!
  post: Post!
}

type PostContentConnection {
  pageInfo: PageInfo!
  edges: [PostContentEdge]!
  aggregate: AggregatePostContent!
}

input PostContentCreateInput {
  id: UUID
  language: PostLngCreateOneWithoutPostsInput!
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  imageAlt: String!
  post: PostCreateOneWithoutContentsInput!
}

input PostContentCreateManyWithoutLanguageInput {
  create: [PostContentCreateWithoutLanguageInput!]
  connect: [PostContentWhereUniqueInput!]
}

input PostContentCreateManyWithoutPostInput {
  create: [PostContentCreateWithoutPostInput!]
  connect: [PostContentWhereUniqueInput!]
}

input PostContentCreateWithoutLanguageInput {
  id: UUID
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  imageAlt: String!
  post: PostCreateOneWithoutContentsInput!
}

input PostContentCreateWithoutPostInput {
  id: UUID
  language: PostLngCreateOneWithoutPostsInput!
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  imageAlt: String!
}

type PostContentEdge {
  node: PostContent!
  cursor: String!
}

enum PostContentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  text_ASC
  text_DESC
  metaTitle_ASC
  metaTitle_DESC
  metaDescription_ASC
  metaDescription_DESC
  imageAlt_ASC
  imageAlt_DESC
}

type PostContentPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  imageAlt: String!
}

input PostContentScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  metaTitle: String
  metaTitle_not: String
  metaTitle_in: [String!]
  metaTitle_not_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_contains: String
  metaTitle_not_contains: String
  metaTitle_starts_with: String
  metaTitle_not_starts_with: String
  metaTitle_ends_with: String
  metaTitle_not_ends_with: String
  metaDescription: String
  metaDescription_not: String
  metaDescription_in: [String!]
  metaDescription_not_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_contains: String
  metaDescription_not_contains: String
  metaDescription_starts_with: String
  metaDescription_not_starts_with: String
  metaDescription_ends_with: String
  metaDescription_not_ends_with: String
  imageAlt: String
  imageAlt_not: String
  imageAlt_in: [String!]
  imageAlt_not_in: [String!]
  imageAlt_lt: String
  imageAlt_lte: String
  imageAlt_gt: String
  imageAlt_gte: String
  imageAlt_contains: String
  imageAlt_not_contains: String
  imageAlt_starts_with: String
  imageAlt_not_starts_with: String
  imageAlt_ends_with: String
  imageAlt_not_ends_with: String
  AND: [PostContentScalarWhereInput!]
  OR: [PostContentScalarWhereInput!]
  NOT: [PostContentScalarWhereInput!]
}

type PostContentSubscriptionPayload {
  mutation: MutationType!
  node: PostContent
  updatedFields: [String!]
  previousValues: PostContentPreviousValues
}

input PostContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostContentWhereInput
  AND: [PostContentSubscriptionWhereInput!]
  OR: [PostContentSubscriptionWhereInput!]
  NOT: [PostContentSubscriptionWhereInput!]
}

input PostContentUpdateInput {
  language: PostLngUpdateOneRequiredWithoutPostsInput
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  imageAlt: String
  post: PostUpdateOneRequiredWithoutContentsInput
}

input PostContentUpdateManyDataInput {
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  imageAlt: String
}

input PostContentUpdateManyMutationInput {
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  imageAlt: String
}

input PostContentUpdateManyWithoutLanguageInput {
  create: [PostContentCreateWithoutLanguageInput!]
  delete: [PostContentWhereUniqueInput!]
  connect: [PostContentWhereUniqueInput!]
  set: [PostContentWhereUniqueInput!]
  disconnect: [PostContentWhereUniqueInput!]
  update: [PostContentUpdateWithWhereUniqueWithoutLanguageInput!]
  upsert: [PostContentUpsertWithWhereUniqueWithoutLanguageInput!]
  deleteMany: [PostContentScalarWhereInput!]
  updateMany: [PostContentUpdateManyWithWhereNestedInput!]
}

input PostContentUpdateManyWithoutPostInput {
  create: [PostContentCreateWithoutPostInput!]
  delete: [PostContentWhereUniqueInput!]
  connect: [PostContentWhereUniqueInput!]
  set: [PostContentWhereUniqueInput!]
  disconnect: [PostContentWhereUniqueInput!]
  update: [PostContentUpdateWithWhereUniqueWithoutPostInput!]
  upsert: [PostContentUpsertWithWhereUniqueWithoutPostInput!]
  deleteMany: [PostContentScalarWhereInput!]
  updateMany: [PostContentUpdateManyWithWhereNestedInput!]
}

input PostContentUpdateManyWithWhereNestedInput {
  where: PostContentScalarWhereInput!
  data: PostContentUpdateManyDataInput!
}

input PostContentUpdateWithoutLanguageDataInput {
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  imageAlt: String
  post: PostUpdateOneRequiredWithoutContentsInput
}

input PostContentUpdateWithoutPostDataInput {
  language: PostLngUpdateOneRequiredWithoutPostsInput
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  imageAlt: String
}

input PostContentUpdateWithWhereUniqueWithoutLanguageInput {
  where: PostContentWhereUniqueInput!
  data: PostContentUpdateWithoutLanguageDataInput!
}

input PostContentUpdateWithWhereUniqueWithoutPostInput {
  where: PostContentWhereUniqueInput!
  data: PostContentUpdateWithoutPostDataInput!
}

input PostContentUpsertWithWhereUniqueWithoutLanguageInput {
  where: PostContentWhereUniqueInput!
  update: PostContentUpdateWithoutLanguageDataInput!
  create: PostContentCreateWithoutLanguageInput!
}

input PostContentUpsertWithWhereUniqueWithoutPostInput {
  where: PostContentWhereUniqueInput!
  update: PostContentUpdateWithoutPostDataInput!
  create: PostContentCreateWithoutPostInput!
}

input PostContentWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  language: PostLngWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  metaTitle: String
  metaTitle_not: String
  metaTitle_in: [String!]
  metaTitle_not_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_contains: String
  metaTitle_not_contains: String
  metaTitle_starts_with: String
  metaTitle_not_starts_with: String
  metaTitle_ends_with: String
  metaTitle_not_ends_with: String
  metaDescription: String
  metaDescription_not: String
  metaDescription_in: [String!]
  metaDescription_not_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_contains: String
  metaDescription_not_contains: String
  metaDescription_starts_with: String
  metaDescription_not_starts_with: String
  metaDescription_ends_with: String
  metaDescription_not_ends_with: String
  imageAlt: String
  imageAlt_not: String
  imageAlt_in: [String!]
  imageAlt_not_in: [String!]
  imageAlt_lt: String
  imageAlt_lte: String
  imageAlt_gt: String
  imageAlt_gte: String
  imageAlt_contains: String
  imageAlt_not_contains: String
  imageAlt_starts_with: String
  imageAlt_not_starts_with: String
  imageAlt_ends_with: String
  imageAlt_not_ends_with: String
  post: PostWhereInput
  AND: [PostContentWhereInput!]
  OR: [PostContentWhereInput!]
  NOT: [PostContentWhereInput!]
}

input PostContentWhereUniqueInput {
  id: UUID
}

input PostCreateInput {
  id: UUID
  author: UserCreateOneWithoutPostsInput!
  slug: String!
  isPublished: Boolean
  imageSrc: String!
  contents: PostContentCreateManyWithoutPostInput
  tags: PostTagCreateManyInput
  comments: CommentCreateManyWithoutPostInput
  likes: Int
  likedBy: UserCreateManyWithoutPostLikesInput
}

input PostCreateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateManyWithoutLikedByInput {
  create: [PostCreateWithoutLikedByInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostCreateOneWithoutContentsInput {
  create: PostCreateWithoutContentsInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutAuthorInput {
  id: UUID
  slug: String!
  isPublished: Boolean
  imageSrc: String!
  contents: PostContentCreateManyWithoutPostInput
  tags: PostTagCreateManyInput
  comments: CommentCreateManyWithoutPostInput
  likes: Int
  likedBy: UserCreateManyWithoutPostLikesInput
}

input PostCreateWithoutCommentsInput {
  id: UUID
  author: UserCreateOneWithoutPostsInput!
  slug: String!
  isPublished: Boolean
  imageSrc: String!
  contents: PostContentCreateManyWithoutPostInput
  tags: PostTagCreateManyInput
  likes: Int
  likedBy: UserCreateManyWithoutPostLikesInput
}

input PostCreateWithoutContentsInput {
  id: UUID
  author: UserCreateOneWithoutPostsInput!
  slug: String!
  isPublished: Boolean
  imageSrc: String!
  tags: PostTagCreateManyInput
  comments: CommentCreateManyWithoutPostInput
  likes: Int
  likedBy: UserCreateManyWithoutPostLikesInput
}

input PostCreateWithoutLikedByInput {
  id: UUID
  author: UserCreateOneWithoutPostsInput!
  slug: String!
  isPublished: Boolean
  imageSrc: String!
  contents: PostContentCreateManyWithoutPostInput
  tags: PostTagCreateManyInput
  comments: CommentCreateManyWithoutPostInput
  likes: Int
}

type PostEdge {
  node: Post!
  cursor: String!
}

type PostLng {
  id: UUID!
  posts(where: PostContentWhereInput, orderBy: PostContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostContent!]
  country: String!
  locale: String
}

type PostLngConnection {
  pageInfo: PageInfo!
  edges: [PostLngEdge]!
  aggregate: AggregatePostLng!
}

input PostLngCreateInput {
  id: UUID
  posts: PostContentCreateManyWithoutLanguageInput
  country: String!
  locale: String
}

input PostLngCreateOneWithoutPostsInput {
  create: PostLngCreateWithoutPostsInput
  connect: PostLngWhereUniqueInput
}

input PostLngCreateWithoutPostsInput {
  id: UUID
  country: String!
  locale: String
}

type PostLngEdge {
  node: PostLng!
  cursor: String!
}

enum PostLngOrderByInput {
  id_ASC
  id_DESC
  country_ASC
  country_DESC
  locale_ASC
  locale_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PostLngPreviousValues {
  id: UUID!
  country: String!
  locale: String
}

type PostLngSubscriptionPayload {
  mutation: MutationType!
  node: PostLng
  updatedFields: [String!]
  previousValues: PostLngPreviousValues
}

input PostLngSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostLngWhereInput
  AND: [PostLngSubscriptionWhereInput!]
  OR: [PostLngSubscriptionWhereInput!]
  NOT: [PostLngSubscriptionWhereInput!]
}

input PostLngUpdateInput {
  posts: PostContentUpdateManyWithoutLanguageInput
  country: String
  locale: String
}

input PostLngUpdateManyMutationInput {
  country: String
  locale: String
}

input PostLngUpdateOneRequiredWithoutPostsInput {
  create: PostLngCreateWithoutPostsInput
  update: PostLngUpdateWithoutPostsDataInput
  upsert: PostLngUpsertWithoutPostsInput
  connect: PostLngWhereUniqueInput
}

input PostLngUpdateWithoutPostsDataInput {
  country: String
  locale: String
}

input PostLngUpsertWithoutPostsInput {
  update: PostLngUpdateWithoutPostsDataInput!
  create: PostLngCreateWithoutPostsInput!
}

input PostLngWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  posts_every: PostContentWhereInput
  posts_some: PostContentWhereInput
  posts_none: PostContentWhereInput
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  locale: String
  locale_not: String
  locale_in: [String!]
  locale_not_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_gt: String
  locale_gte: String
  locale_contains: String
  locale_not_contains: String
  locale_starts_with: String
  locale_not_starts_with: String
  locale_ends_with: String
  locale_not_ends_with: String
  AND: [PostLngWhereInput!]
  OR: [PostLngWhereInput!]
  NOT: [PostLngWhereInput!]
}

input PostLngWhereUniqueInput {
  id: UUID
  country: String
  locale: String
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  slug_ASC
  slug_DESC
  isPublished_ASC
  isPublished_DESC
  imageSrc_ASC
  imageSrc_DESC
  likes_ASC
  likes_DESC
}

type PostPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  slug: String!
  isPublished: Boolean!
  imageSrc: String!
  likes: Int
}

input PostScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  imageSrc: String
  imageSrc_not: String
  imageSrc_in: [String!]
  imageSrc_not_in: [String!]
  imageSrc_lt: String
  imageSrc_lte: String
  imageSrc_gt: String
  imageSrc_gte: String
  imageSrc_contains: String
  imageSrc_not_contains: String
  imageSrc_starts_with: String
  imageSrc_not_starts_with: String
  imageSrc_ends_with: String
  imageSrc_not_ends_with: String
  likes: Int
  likes_not: Int
  likes_in: [Int!]
  likes_not_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_gt: Int
  likes_gte: Int
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

type PostTag {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  color: String!
  language: PostTagLng!
  contents: PostTagContent!
}

type PostTagConnection {
  pageInfo: PageInfo!
  edges: [PostTagEdge]!
  aggregate: AggregatePostTag!
}

type PostTagContent {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  tag: PostTag!
  title: String!
}

type PostTagContentConnection {
  pageInfo: PageInfo!
  edges: [PostTagContentEdge]!
  aggregate: AggregatePostTagContent!
}

input PostTagContentCreateInput {
  id: UUID
  tag: PostTagCreateOneWithoutContentsInput!
  title: String!
}

input PostTagContentCreateOneWithoutTagInput {
  create: PostTagContentCreateWithoutTagInput
  connect: PostTagContentWhereUniqueInput
}

input PostTagContentCreateWithoutTagInput {
  id: UUID
  title: String!
}

type PostTagContentEdge {
  node: PostTagContent!
  cursor: String!
}

enum PostTagContentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
}

type PostTagContentPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
}

type PostTagContentSubscriptionPayload {
  mutation: MutationType!
  node: PostTagContent
  updatedFields: [String!]
  previousValues: PostTagContentPreviousValues
}

input PostTagContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostTagContentWhereInput
  AND: [PostTagContentSubscriptionWhereInput!]
  OR: [PostTagContentSubscriptionWhereInput!]
  NOT: [PostTagContentSubscriptionWhereInput!]
}

input PostTagContentUpdateInput {
  tag: PostTagUpdateOneRequiredWithoutContentsInput
  title: String
}

input PostTagContentUpdateManyMutationInput {
  title: String
}

input PostTagContentUpdateOneRequiredWithoutTagInput {
  create: PostTagContentCreateWithoutTagInput
  update: PostTagContentUpdateWithoutTagDataInput
  upsert: PostTagContentUpsertWithoutTagInput
  connect: PostTagContentWhereUniqueInput
}

input PostTagContentUpdateWithoutTagDataInput {
  title: String
}

input PostTagContentUpsertWithoutTagInput {
  update: PostTagContentUpdateWithoutTagDataInput!
  create: PostTagContentCreateWithoutTagInput!
}

input PostTagContentWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  tag: PostTagWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [PostTagContentWhereInput!]
  OR: [PostTagContentWhereInput!]
  NOT: [PostTagContentWhereInput!]
}

input PostTagContentWhereUniqueInput {
  id: UUID
}

input PostTagCreateInput {
  id: UUID
  color: String!
  language: PostTagLngCreateOneWithoutTagsInput!
  contents: PostTagContentCreateOneWithoutTagInput!
}

input PostTagCreateManyInput {
  create: [PostTagCreateInput!]
  connect: [PostTagWhereUniqueInput!]
}

input PostTagCreateManyWithoutLanguageInput {
  create: [PostTagCreateWithoutLanguageInput!]
  connect: [PostTagWhereUniqueInput!]
}

input PostTagCreateOneWithoutContentsInput {
  create: PostTagCreateWithoutContentsInput
  connect: PostTagWhereUniqueInput
}

input PostTagCreateWithoutContentsInput {
  id: UUID
  color: String!
  language: PostTagLngCreateOneWithoutTagsInput!
}

input PostTagCreateWithoutLanguageInput {
  id: UUID
  color: String!
  contents: PostTagContentCreateOneWithoutTagInput!
}

type PostTagEdge {
  node: PostTag!
  cursor: String!
}

type PostTagLng {
  id: UUID!
  tags(where: PostTagWhereInput, orderBy: PostTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostTag!]
  country: String!
  locale: String!
}

type PostTagLngConnection {
  pageInfo: PageInfo!
  edges: [PostTagLngEdge]!
  aggregate: AggregatePostTagLng!
}

input PostTagLngCreateInput {
  id: UUID
  tags: PostTagCreateManyWithoutLanguageInput
  country: String!
  locale: String!
}

input PostTagLngCreateOneWithoutTagsInput {
  create: PostTagLngCreateWithoutTagsInput
  connect: PostTagLngWhereUniqueInput
}

input PostTagLngCreateWithoutTagsInput {
  id: UUID
  country: String!
  locale: String!
}

type PostTagLngEdge {
  node: PostTagLng!
  cursor: String!
}

enum PostTagLngOrderByInput {
  id_ASC
  id_DESC
  country_ASC
  country_DESC
  locale_ASC
  locale_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PostTagLngPreviousValues {
  id: UUID!
  country: String!
  locale: String!
}

type PostTagLngSubscriptionPayload {
  mutation: MutationType!
  node: PostTagLng
  updatedFields: [String!]
  previousValues: PostTagLngPreviousValues
}

input PostTagLngSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostTagLngWhereInput
  AND: [PostTagLngSubscriptionWhereInput!]
  OR: [PostTagLngSubscriptionWhereInput!]
  NOT: [PostTagLngSubscriptionWhereInput!]
}

input PostTagLngUpdateInput {
  tags: PostTagUpdateManyWithoutLanguageInput
  country: String
  locale: String
}

input PostTagLngUpdateManyMutationInput {
  country: String
  locale: String
}

input PostTagLngUpdateOneRequiredWithoutTagsInput {
  create: PostTagLngCreateWithoutTagsInput
  update: PostTagLngUpdateWithoutTagsDataInput
  upsert: PostTagLngUpsertWithoutTagsInput
  connect: PostTagLngWhereUniqueInput
}

input PostTagLngUpdateWithoutTagsDataInput {
  country: String
  locale: String
}

input PostTagLngUpsertWithoutTagsInput {
  update: PostTagLngUpdateWithoutTagsDataInput!
  create: PostTagLngCreateWithoutTagsInput!
}

input PostTagLngWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  tags_every: PostTagWhereInput
  tags_some: PostTagWhereInput
  tags_none: PostTagWhereInput
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  locale: String
  locale_not: String
  locale_in: [String!]
  locale_not_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_gt: String
  locale_gte: String
  locale_contains: String
  locale_not_contains: String
  locale_starts_with: String
  locale_not_starts_with: String
  locale_ends_with: String
  locale_not_ends_with: String
  AND: [PostTagLngWhereInput!]
  OR: [PostTagLngWhereInput!]
  NOT: [PostTagLngWhereInput!]
}

input PostTagLngWhereUniqueInput {
  id: UUID
}

enum PostTagOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  color_ASC
  color_DESC
}

type PostTagPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  color: String!
}

input PostTagScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  color: String
  color_not: String
  color_in: [String!]
  color_not_in: [String!]
  color_lt: String
  color_lte: String
  color_gt: String
  color_gte: String
  color_contains: String
  color_not_contains: String
  color_starts_with: String
  color_not_starts_with: String
  color_ends_with: String
  color_not_ends_with: String
  AND: [PostTagScalarWhereInput!]
  OR: [PostTagScalarWhereInput!]
  NOT: [PostTagScalarWhereInput!]
}

type PostTagSubscriptionPayload {
  mutation: MutationType!
  node: PostTag
  updatedFields: [String!]
  previousValues: PostTagPreviousValues
}

input PostTagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostTagWhereInput
  AND: [PostTagSubscriptionWhereInput!]
  OR: [PostTagSubscriptionWhereInput!]
  NOT: [PostTagSubscriptionWhereInput!]
}

input PostTagUpdateDataInput {
  color: String
  language: PostTagLngUpdateOneRequiredWithoutTagsInput
  contents: PostTagContentUpdateOneRequiredWithoutTagInput
}

input PostTagUpdateInput {
  color: String
  language: PostTagLngUpdateOneRequiredWithoutTagsInput
  contents: PostTagContentUpdateOneRequiredWithoutTagInput
}

input PostTagUpdateManyDataInput {
  color: String
}

input PostTagUpdateManyInput {
  create: [PostTagCreateInput!]
  update: [PostTagUpdateWithWhereUniqueNestedInput!]
  upsert: [PostTagUpsertWithWhereUniqueNestedInput!]
  delete: [PostTagWhereUniqueInput!]
  connect: [PostTagWhereUniqueInput!]
  set: [PostTagWhereUniqueInput!]
  disconnect: [PostTagWhereUniqueInput!]
  deleteMany: [PostTagScalarWhereInput!]
  updateMany: [PostTagUpdateManyWithWhereNestedInput!]
}

input PostTagUpdateManyMutationInput {
  color: String
}

input PostTagUpdateManyWithoutLanguageInput {
  create: [PostTagCreateWithoutLanguageInput!]
  delete: [PostTagWhereUniqueInput!]
  connect: [PostTagWhereUniqueInput!]
  set: [PostTagWhereUniqueInput!]
  disconnect: [PostTagWhereUniqueInput!]
  update: [PostTagUpdateWithWhereUniqueWithoutLanguageInput!]
  upsert: [PostTagUpsertWithWhereUniqueWithoutLanguageInput!]
  deleteMany: [PostTagScalarWhereInput!]
  updateMany: [PostTagUpdateManyWithWhereNestedInput!]
}

input PostTagUpdateManyWithWhereNestedInput {
  where: PostTagScalarWhereInput!
  data: PostTagUpdateManyDataInput!
}

input PostTagUpdateOneRequiredWithoutContentsInput {
  create: PostTagCreateWithoutContentsInput
  update: PostTagUpdateWithoutContentsDataInput
  upsert: PostTagUpsertWithoutContentsInput
  connect: PostTagWhereUniqueInput
}

input PostTagUpdateWithoutContentsDataInput {
  color: String
  language: PostTagLngUpdateOneRequiredWithoutTagsInput
}

input PostTagUpdateWithoutLanguageDataInput {
  color: String
  contents: PostTagContentUpdateOneRequiredWithoutTagInput
}

input PostTagUpdateWithWhereUniqueNestedInput {
  where: PostTagWhereUniqueInput!
  data: PostTagUpdateDataInput!
}

input PostTagUpdateWithWhereUniqueWithoutLanguageInput {
  where: PostTagWhereUniqueInput!
  data: PostTagUpdateWithoutLanguageDataInput!
}

input PostTagUpsertWithoutContentsInput {
  update: PostTagUpdateWithoutContentsDataInput!
  create: PostTagCreateWithoutContentsInput!
}

input PostTagUpsertWithWhereUniqueNestedInput {
  where: PostTagWhereUniqueInput!
  update: PostTagUpdateDataInput!
  create: PostTagCreateInput!
}

input PostTagUpsertWithWhereUniqueWithoutLanguageInput {
  where: PostTagWhereUniqueInput!
  update: PostTagUpdateWithoutLanguageDataInput!
  create: PostTagCreateWithoutLanguageInput!
}

input PostTagWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  color: String
  color_not: String
  color_in: [String!]
  color_not_in: [String!]
  color_lt: String
  color_lte: String
  color_gt: String
  color_gte: String
  color_contains: String
  color_not_contains: String
  color_starts_with: String
  color_not_starts_with: String
  color_ends_with: String
  color_not_ends_with: String
  language: PostTagLngWhereInput
  contents: PostTagContentWhereInput
  AND: [PostTagWhereInput!]
  OR: [PostTagWhereInput!]
  NOT: [PostTagWhereInput!]
}

input PostTagWhereUniqueInput {
  id: UUID
}

input PostUpdateInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  slug: String
  isPublished: Boolean
  imageSrc: String
  contents: PostContentUpdateManyWithoutPostInput
  tags: PostTagUpdateManyInput
  comments: CommentUpdateManyWithoutPostInput
  likes: Int
  likedBy: UserUpdateManyWithoutPostLikesInput
}

input PostUpdateManyDataInput {
  slug: String
  isPublished: Boolean
  imageSrc: String
  likes: Int
}

input PostUpdateManyMutationInput {
  slug: String
  isPublished: Boolean
  imageSrc: String
  likes: Int
}

input PostUpdateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithoutLikedByInput {
  create: [PostCreateWithoutLikedByInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutLikedByInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutLikedByInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyDataInput!
}

input PostUpdateOneRequiredWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostUpdateOneRequiredWithoutContentsInput {
  create: PostCreateWithoutContentsInput
  update: PostUpdateWithoutContentsDataInput
  upsert: PostUpsertWithoutContentsInput
  connect: PostWhereUniqueInput
}

input PostUpdateWithoutAuthorDataInput {
  slug: String
  isPublished: Boolean
  imageSrc: String
  contents: PostContentUpdateManyWithoutPostInput
  tags: PostTagUpdateManyInput
  comments: CommentUpdateManyWithoutPostInput
  likes: Int
  likedBy: UserUpdateManyWithoutPostLikesInput
}

input PostUpdateWithoutCommentsDataInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  slug: String
  isPublished: Boolean
  imageSrc: String
  contents: PostContentUpdateManyWithoutPostInput
  tags: PostTagUpdateManyInput
  likes: Int
  likedBy: UserUpdateManyWithoutPostLikesInput
}

input PostUpdateWithoutContentsDataInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  slug: String
  isPublished: Boolean
  imageSrc: String
  tags: PostTagUpdateManyInput
  comments: CommentUpdateManyWithoutPostInput
  likes: Int
  likedBy: UserUpdateManyWithoutPostLikesInput
}

input PostUpdateWithoutLikedByDataInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  slug: String
  isPublished: Boolean
  imageSrc: String
  contents: PostContentUpdateManyWithoutPostInput
  tags: PostTagUpdateManyInput
  comments: CommentUpdateManyWithoutPostInput
  likes: Int
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutAuthorDataInput!
}

input PostUpdateWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutLikedByDataInput!
}

input PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput!
  create: PostCreateWithoutCommentsInput!
}

input PostUpsertWithoutContentsInput {
  update: PostUpdateWithoutContentsDataInput!
  create: PostCreateWithoutContentsInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutAuthorDataInput!
  create: PostCreateWithoutAuthorInput!
}

input PostUpsertWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutLikedByDataInput!
  create: PostCreateWithoutLikedByInput!
}

input PostWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  author: UserWhereInput
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  imageSrc: String
  imageSrc_not: String
  imageSrc_in: [String!]
  imageSrc_not_in: [String!]
  imageSrc_lt: String
  imageSrc_lte: String
  imageSrc_gt: String
  imageSrc_gte: String
  imageSrc_contains: String
  imageSrc_not_contains: String
  imageSrc_starts_with: String
  imageSrc_not_starts_with: String
  imageSrc_ends_with: String
  imageSrc_not_ends_with: String
  contents_every: PostContentWhereInput
  contents_some: PostContentWhereInput
  contents_none: PostContentWhereInput
  tags_every: PostTagWhereInput
  tags_some: PostTagWhereInput
  tags_none: PostTagWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  likes: Int
  likes_not: Int
  likes_in: [Int!]
  likes_not_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_gt: Int
  likes_gte: Int
  likedBy_every: UserWhereInput
  likedBy_some: UserWhereInput
  likedBy_none: UserWhereInput
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: UUID
  slug: String
}

type Profile {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  bio: String!
  avatar: Avatar!
}

type ProfileConnection {
  pageInfo: PageInfo!
  edges: [ProfileEdge]!
  aggregate: AggregateProfile!
}

input ProfileCreateInput {
  id: UUID
  user: UserCreateOneWithoutProfileInput!
  bio: String!
  avatar: AvatarCreateOneInput!
}

input ProfileCreateOneWithoutUserInput {
  create: ProfileCreateWithoutUserInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateWithoutUserInput {
  id: UUID
  bio: String!
  avatar: AvatarCreateOneInput!
}

type ProfileEdge {
  node: Profile!
  cursor: String!
}

enum ProfileOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  bio_ASC
  bio_DESC
}

type ProfilePreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  bio: String!
}

type ProfileSubscriptionPayload {
  mutation: MutationType!
  node: Profile
  updatedFields: [String!]
  previousValues: ProfilePreviousValues
}

input ProfileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProfileWhereInput
  AND: [ProfileSubscriptionWhereInput!]
  OR: [ProfileSubscriptionWhereInput!]
  NOT: [ProfileSubscriptionWhereInput!]
}

input ProfileUpdateInput {
  user: UserUpdateOneRequiredWithoutProfileInput
  bio: String
  avatar: AvatarUpdateOneRequiredInput
}

input ProfileUpdateManyMutationInput {
  bio: String
}

input ProfileUpdateOneWithoutUserInput {
  create: ProfileCreateWithoutUserInput
  update: ProfileUpdateWithoutUserDataInput
  upsert: ProfileUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateWithoutUserDataInput {
  bio: String
  avatar: AvatarUpdateOneRequiredInput
}

input ProfileUpsertWithoutUserInput {
  update: ProfileUpdateWithoutUserDataInput!
  create: ProfileCreateWithoutUserInput!
}

input ProfileWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  user: UserWhereInput
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  avatar: AvatarWhereInput
  AND: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
}

input ProfileWhereUniqueInput {
  id: UUID
}

type Project {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  slug: String!
  category: ProjectCategory!
  author: User!
  album: ProjectAlbum!
  contents(where: ProjectContentWhereInput, orderBy: ProjectContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectContent!]
  tags(where: ProjectTagWhereInput, orderBy: ProjectTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectTag!]
}

type ProjectAlbum {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  project: Project!
  images(where: ProjectImageWhereInput, orderBy: ProjectImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectImage!]
}

type ProjectAlbumConnection {
  pageInfo: PageInfo!
  edges: [ProjectAlbumEdge]!
  aggregate: AggregateProjectAlbum!
}

input ProjectAlbumCreateInput {
  id: UUID
  project: ProjectCreateOneWithoutAlbumInput!
  images: ProjectImageCreateManyWithoutAlbumInput
}

input ProjectAlbumCreateOneWithoutImagesInput {
  create: ProjectAlbumCreateWithoutImagesInput
  connect: ProjectAlbumWhereUniqueInput
}

input ProjectAlbumCreateOneWithoutProjectInput {
  create: ProjectAlbumCreateWithoutProjectInput
  connect: ProjectAlbumWhereUniqueInput
}

input ProjectAlbumCreateWithoutImagesInput {
  id: UUID
  project: ProjectCreateOneWithoutAlbumInput!
}

input ProjectAlbumCreateWithoutProjectInput {
  id: UUID
  images: ProjectImageCreateManyWithoutAlbumInput
}

type ProjectAlbumEdge {
  node: ProjectAlbum!
  cursor: String!
}

enum ProjectAlbumOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectAlbumPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectAlbumSubscriptionPayload {
  mutation: MutationType!
  node: ProjectAlbum
  updatedFields: [String!]
  previousValues: ProjectAlbumPreviousValues
}

input ProjectAlbumSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectAlbumWhereInput
  AND: [ProjectAlbumSubscriptionWhereInput!]
  OR: [ProjectAlbumSubscriptionWhereInput!]
  NOT: [ProjectAlbumSubscriptionWhereInput!]
}

input ProjectAlbumUpdateInput {
  project: ProjectUpdateOneRequiredWithoutAlbumInput
  images: ProjectImageUpdateManyWithoutAlbumInput
}

input ProjectAlbumUpdateOneRequiredWithoutImagesInput {
  create: ProjectAlbumCreateWithoutImagesInput
  update: ProjectAlbumUpdateWithoutImagesDataInput
  upsert: ProjectAlbumUpsertWithoutImagesInput
  connect: ProjectAlbumWhereUniqueInput
}

input ProjectAlbumUpdateOneRequiredWithoutProjectInput {
  create: ProjectAlbumCreateWithoutProjectInput
  update: ProjectAlbumUpdateWithoutProjectDataInput
  upsert: ProjectAlbumUpsertWithoutProjectInput
  connect: ProjectAlbumWhereUniqueInput
}

input ProjectAlbumUpdateWithoutImagesDataInput {
  project: ProjectUpdateOneRequiredWithoutAlbumInput
}

input ProjectAlbumUpdateWithoutProjectDataInput {
  images: ProjectImageUpdateManyWithoutAlbumInput
}

input ProjectAlbumUpsertWithoutImagesInput {
  update: ProjectAlbumUpdateWithoutImagesDataInput!
  create: ProjectAlbumCreateWithoutImagesInput!
}

input ProjectAlbumUpsertWithoutProjectInput {
  update: ProjectAlbumUpdateWithoutProjectDataInput!
  create: ProjectAlbumCreateWithoutProjectInput!
}

input ProjectAlbumWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  project: ProjectWhereInput
  images_every: ProjectImageWhereInput
  images_some: ProjectImageWhereInput
  images_none: ProjectImageWhereInput
  AND: [ProjectAlbumWhereInput!]
  OR: [ProjectAlbumWhereInput!]
  NOT: [ProjectAlbumWhereInput!]
}

input ProjectAlbumWhereUniqueInput {
  id: UUID
}

type ProjectCategory {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  contents(where: ProjectCategoryContentWhereInput, orderBy: ProjectCategoryContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectCategoryContent!]
  slug: String!
  image: String!
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project!]
}

type ProjectCategoryConnection {
  pageInfo: PageInfo!
  edges: [ProjectCategoryEdge]!
  aggregate: AggregateProjectCategory!
}

type ProjectCategoryContent {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  category: ProjectCategory!
  language: ProjectCategoryLng!
  title: String!
  text: String!
  imageAlt: String!
  metaTitle: String
  metaDescription: String
}

type ProjectCategoryContentConnection {
  pageInfo: PageInfo!
  edges: [ProjectCategoryContentEdge]!
  aggregate: AggregateProjectCategoryContent!
}

input ProjectCategoryContentCreateInput {
  id: UUID
  category: ProjectCategoryCreateOneWithoutContentsInput!
  language: ProjectCategoryLngCreateOneWithoutCategoriesInput!
  title: String!
  text: String!
  imageAlt: String!
  metaTitle: String
  metaDescription: String
}

input ProjectCategoryContentCreateManyWithoutCategoryInput {
  create: [ProjectCategoryContentCreateWithoutCategoryInput!]
  connect: [ProjectCategoryContentWhereUniqueInput!]
}

input ProjectCategoryContentCreateManyWithoutLanguageInput {
  create: [ProjectCategoryContentCreateWithoutLanguageInput!]
  connect: [ProjectCategoryContentWhereUniqueInput!]
}

input ProjectCategoryContentCreateWithoutCategoryInput {
  id: UUID
  language: ProjectCategoryLngCreateOneWithoutCategoriesInput!
  title: String!
  text: String!
  imageAlt: String!
  metaTitle: String
  metaDescription: String
}

input ProjectCategoryContentCreateWithoutLanguageInput {
  id: UUID
  category: ProjectCategoryCreateOneWithoutContentsInput!
  title: String!
  text: String!
  imageAlt: String!
  metaTitle: String
  metaDescription: String
}

type ProjectCategoryContentEdge {
  node: ProjectCategoryContent!
  cursor: String!
}

enum ProjectCategoryContentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  text_ASC
  text_DESC
  imageAlt_ASC
  imageAlt_DESC
  metaTitle_ASC
  metaTitle_DESC
  metaDescription_ASC
  metaDescription_DESC
}

type ProjectCategoryContentPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  text: String!
  imageAlt: String!
  metaTitle: String
  metaDescription: String
}

input ProjectCategoryContentScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  imageAlt: String
  imageAlt_not: String
  imageAlt_in: [String!]
  imageAlt_not_in: [String!]
  imageAlt_lt: String
  imageAlt_lte: String
  imageAlt_gt: String
  imageAlt_gte: String
  imageAlt_contains: String
  imageAlt_not_contains: String
  imageAlt_starts_with: String
  imageAlt_not_starts_with: String
  imageAlt_ends_with: String
  imageAlt_not_ends_with: String
  metaTitle: String
  metaTitle_not: String
  metaTitle_in: [String!]
  metaTitle_not_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_contains: String
  metaTitle_not_contains: String
  metaTitle_starts_with: String
  metaTitle_not_starts_with: String
  metaTitle_ends_with: String
  metaTitle_not_ends_with: String
  metaDescription: String
  metaDescription_not: String
  metaDescription_in: [String!]
  metaDescription_not_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_contains: String
  metaDescription_not_contains: String
  metaDescription_starts_with: String
  metaDescription_not_starts_with: String
  metaDescription_ends_with: String
  metaDescription_not_ends_with: String
  AND: [ProjectCategoryContentScalarWhereInput!]
  OR: [ProjectCategoryContentScalarWhereInput!]
  NOT: [ProjectCategoryContentScalarWhereInput!]
}

type ProjectCategoryContentSubscriptionPayload {
  mutation: MutationType!
  node: ProjectCategoryContent
  updatedFields: [String!]
  previousValues: ProjectCategoryContentPreviousValues
}

input ProjectCategoryContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectCategoryContentWhereInput
  AND: [ProjectCategoryContentSubscriptionWhereInput!]
  OR: [ProjectCategoryContentSubscriptionWhereInput!]
  NOT: [ProjectCategoryContentSubscriptionWhereInput!]
}

input ProjectCategoryContentUpdateInput {
  category: ProjectCategoryUpdateOneRequiredWithoutContentsInput
  language: ProjectCategoryLngUpdateOneRequiredWithoutCategoriesInput
  title: String
  text: String
  imageAlt: String
  metaTitle: String
  metaDescription: String
}

input ProjectCategoryContentUpdateManyDataInput {
  title: String
  text: String
  imageAlt: String
  metaTitle: String
  metaDescription: String
}

input ProjectCategoryContentUpdateManyMutationInput {
  title: String
  text: String
  imageAlt: String
  metaTitle: String
  metaDescription: String
}

input ProjectCategoryContentUpdateManyWithoutCategoryInput {
  create: [ProjectCategoryContentCreateWithoutCategoryInput!]
  delete: [ProjectCategoryContentWhereUniqueInput!]
  connect: [ProjectCategoryContentWhereUniqueInput!]
  set: [ProjectCategoryContentWhereUniqueInput!]
  disconnect: [ProjectCategoryContentWhereUniqueInput!]
  update: [ProjectCategoryContentUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [ProjectCategoryContentUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [ProjectCategoryContentScalarWhereInput!]
  updateMany: [ProjectCategoryContentUpdateManyWithWhereNestedInput!]
}

input ProjectCategoryContentUpdateManyWithoutLanguageInput {
  create: [ProjectCategoryContentCreateWithoutLanguageInput!]
  delete: [ProjectCategoryContentWhereUniqueInput!]
  connect: [ProjectCategoryContentWhereUniqueInput!]
  set: [ProjectCategoryContentWhereUniqueInput!]
  disconnect: [ProjectCategoryContentWhereUniqueInput!]
  update: [ProjectCategoryContentUpdateWithWhereUniqueWithoutLanguageInput!]
  upsert: [ProjectCategoryContentUpsertWithWhereUniqueWithoutLanguageInput!]
  deleteMany: [ProjectCategoryContentScalarWhereInput!]
  updateMany: [ProjectCategoryContentUpdateManyWithWhereNestedInput!]
}

input ProjectCategoryContentUpdateManyWithWhereNestedInput {
  where: ProjectCategoryContentScalarWhereInput!
  data: ProjectCategoryContentUpdateManyDataInput!
}

input ProjectCategoryContentUpdateWithoutCategoryDataInput {
  language: ProjectCategoryLngUpdateOneRequiredWithoutCategoriesInput
  title: String
  text: String
  imageAlt: String
  metaTitle: String
  metaDescription: String
}

input ProjectCategoryContentUpdateWithoutLanguageDataInput {
  category: ProjectCategoryUpdateOneRequiredWithoutContentsInput
  title: String
  text: String
  imageAlt: String
  metaTitle: String
  metaDescription: String
}

input ProjectCategoryContentUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProjectCategoryContentWhereUniqueInput!
  data: ProjectCategoryContentUpdateWithoutCategoryDataInput!
}

input ProjectCategoryContentUpdateWithWhereUniqueWithoutLanguageInput {
  where: ProjectCategoryContentWhereUniqueInput!
  data: ProjectCategoryContentUpdateWithoutLanguageDataInput!
}

input ProjectCategoryContentUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProjectCategoryContentWhereUniqueInput!
  update: ProjectCategoryContentUpdateWithoutCategoryDataInput!
  create: ProjectCategoryContentCreateWithoutCategoryInput!
}

input ProjectCategoryContentUpsertWithWhereUniqueWithoutLanguageInput {
  where: ProjectCategoryContentWhereUniqueInput!
  update: ProjectCategoryContentUpdateWithoutLanguageDataInput!
  create: ProjectCategoryContentCreateWithoutLanguageInput!
}

input ProjectCategoryContentWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  category: ProjectCategoryWhereInput
  language: ProjectCategoryLngWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  imageAlt: String
  imageAlt_not: String
  imageAlt_in: [String!]
  imageAlt_not_in: [String!]
  imageAlt_lt: String
  imageAlt_lte: String
  imageAlt_gt: String
  imageAlt_gte: String
  imageAlt_contains: String
  imageAlt_not_contains: String
  imageAlt_starts_with: String
  imageAlt_not_starts_with: String
  imageAlt_ends_with: String
  imageAlt_not_ends_with: String
  metaTitle: String
  metaTitle_not: String
  metaTitle_in: [String!]
  metaTitle_not_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_contains: String
  metaTitle_not_contains: String
  metaTitle_starts_with: String
  metaTitle_not_starts_with: String
  metaTitle_ends_with: String
  metaTitle_not_ends_with: String
  metaDescription: String
  metaDescription_not: String
  metaDescription_in: [String!]
  metaDescription_not_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_contains: String
  metaDescription_not_contains: String
  metaDescription_starts_with: String
  metaDescription_not_starts_with: String
  metaDescription_ends_with: String
  metaDescription_not_ends_with: String
  AND: [ProjectCategoryContentWhereInput!]
  OR: [ProjectCategoryContentWhereInput!]
  NOT: [ProjectCategoryContentWhereInput!]
}

input ProjectCategoryContentWhereUniqueInput {
  id: UUID
}

input ProjectCategoryCreateInput {
  id: UUID
  contents: ProjectCategoryContentCreateManyWithoutCategoryInput
  slug: String!
  image: String!
  projects: ProjectCreateManyWithoutCategoryInput
}

input ProjectCategoryCreateOneWithoutContentsInput {
  create: ProjectCategoryCreateWithoutContentsInput
  connect: ProjectCategoryWhereUniqueInput
}

input ProjectCategoryCreateOneWithoutProjectsInput {
  create: ProjectCategoryCreateWithoutProjectsInput
  connect: ProjectCategoryWhereUniqueInput
}

input ProjectCategoryCreateWithoutContentsInput {
  id: UUID
  slug: String!
  image: String!
  projects: ProjectCreateManyWithoutCategoryInput
}

input ProjectCategoryCreateWithoutProjectsInput {
  id: UUID
  contents: ProjectCategoryContentCreateManyWithoutCategoryInput
  slug: String!
  image: String!
}

type ProjectCategoryEdge {
  node: ProjectCategory!
  cursor: String!
}

type ProjectCategoryLng {
  id: UUID!
  categories(where: ProjectCategoryContentWhereInput, orderBy: ProjectCategoryContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectCategoryContent!]
  country: String!
  locale: String
}

type ProjectCategoryLngConnection {
  pageInfo: PageInfo!
  edges: [ProjectCategoryLngEdge]!
  aggregate: AggregateProjectCategoryLng!
}

input ProjectCategoryLngCreateInput {
  id: UUID
  categories: ProjectCategoryContentCreateManyWithoutLanguageInput
  country: String!
  locale: String
}

input ProjectCategoryLngCreateOneWithoutCategoriesInput {
  create: ProjectCategoryLngCreateWithoutCategoriesInput
  connect: ProjectCategoryLngWhereUniqueInput
}

input ProjectCategoryLngCreateWithoutCategoriesInput {
  id: UUID
  country: String!
  locale: String
}

type ProjectCategoryLngEdge {
  node: ProjectCategoryLng!
  cursor: String!
}

enum ProjectCategoryLngOrderByInput {
  id_ASC
  id_DESC
  country_ASC
  country_DESC
  locale_ASC
  locale_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectCategoryLngPreviousValues {
  id: UUID!
  country: String!
  locale: String
}

type ProjectCategoryLngSubscriptionPayload {
  mutation: MutationType!
  node: ProjectCategoryLng
  updatedFields: [String!]
  previousValues: ProjectCategoryLngPreviousValues
}

input ProjectCategoryLngSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectCategoryLngWhereInput
  AND: [ProjectCategoryLngSubscriptionWhereInput!]
  OR: [ProjectCategoryLngSubscriptionWhereInput!]
  NOT: [ProjectCategoryLngSubscriptionWhereInput!]
}

input ProjectCategoryLngUpdateInput {
  categories: ProjectCategoryContentUpdateManyWithoutLanguageInput
  country: String
  locale: String
}

input ProjectCategoryLngUpdateManyMutationInput {
  country: String
  locale: String
}

input ProjectCategoryLngUpdateOneRequiredWithoutCategoriesInput {
  create: ProjectCategoryLngCreateWithoutCategoriesInput
  update: ProjectCategoryLngUpdateWithoutCategoriesDataInput
  upsert: ProjectCategoryLngUpsertWithoutCategoriesInput
  connect: ProjectCategoryLngWhereUniqueInput
}

input ProjectCategoryLngUpdateWithoutCategoriesDataInput {
  country: String
  locale: String
}

input ProjectCategoryLngUpsertWithoutCategoriesInput {
  update: ProjectCategoryLngUpdateWithoutCategoriesDataInput!
  create: ProjectCategoryLngCreateWithoutCategoriesInput!
}

input ProjectCategoryLngWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  categories_every: ProjectCategoryContentWhereInput
  categories_some: ProjectCategoryContentWhereInput
  categories_none: ProjectCategoryContentWhereInput
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  locale: String
  locale_not: String
  locale_in: [String!]
  locale_not_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_gt: String
  locale_gte: String
  locale_contains: String
  locale_not_contains: String
  locale_starts_with: String
  locale_not_starts_with: String
  locale_ends_with: String
  locale_not_ends_with: String
  AND: [ProjectCategoryLngWhereInput!]
  OR: [ProjectCategoryLngWhereInput!]
  NOT: [ProjectCategoryLngWhereInput!]
}

input ProjectCategoryLngWhereUniqueInput {
  id: UUID
  country: String
  locale: String
}

enum ProjectCategoryOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  slug_ASC
  slug_DESC
  image_ASC
  image_DESC
}

type ProjectCategoryPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  slug: String!
  image: String!
}

type ProjectCategorySubscriptionPayload {
  mutation: MutationType!
  node: ProjectCategory
  updatedFields: [String!]
  previousValues: ProjectCategoryPreviousValues
}

input ProjectCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectCategoryWhereInput
  AND: [ProjectCategorySubscriptionWhereInput!]
  OR: [ProjectCategorySubscriptionWhereInput!]
  NOT: [ProjectCategorySubscriptionWhereInput!]
}

input ProjectCategoryUpdateInput {
  contents: ProjectCategoryContentUpdateManyWithoutCategoryInput
  slug: String
  image: String
  projects: ProjectUpdateManyWithoutCategoryInput
}

input ProjectCategoryUpdateManyMutationInput {
  slug: String
  image: String
}

input ProjectCategoryUpdateOneRequiredWithoutContentsInput {
  create: ProjectCategoryCreateWithoutContentsInput
  update: ProjectCategoryUpdateWithoutContentsDataInput
  upsert: ProjectCategoryUpsertWithoutContentsInput
  connect: ProjectCategoryWhereUniqueInput
}

input ProjectCategoryUpdateOneRequiredWithoutProjectsInput {
  create: ProjectCategoryCreateWithoutProjectsInput
  update: ProjectCategoryUpdateWithoutProjectsDataInput
  upsert: ProjectCategoryUpsertWithoutProjectsInput
  connect: ProjectCategoryWhereUniqueInput
}

input ProjectCategoryUpdateWithoutContentsDataInput {
  slug: String
  image: String
  projects: ProjectUpdateManyWithoutCategoryInput
}

input ProjectCategoryUpdateWithoutProjectsDataInput {
  contents: ProjectCategoryContentUpdateManyWithoutCategoryInput
  slug: String
  image: String
}

input ProjectCategoryUpsertWithoutContentsInput {
  update: ProjectCategoryUpdateWithoutContentsDataInput!
  create: ProjectCategoryCreateWithoutContentsInput!
}

input ProjectCategoryUpsertWithoutProjectsInput {
  update: ProjectCategoryUpdateWithoutProjectsDataInput!
  create: ProjectCategoryCreateWithoutProjectsInput!
}

input ProjectCategoryWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  contents_every: ProjectCategoryContentWhereInput
  contents_some: ProjectCategoryContentWhereInput
  contents_none: ProjectCategoryContentWhereInput
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  projects_every: ProjectWhereInput
  projects_some: ProjectWhereInput
  projects_none: ProjectWhereInput
  AND: [ProjectCategoryWhereInput!]
  OR: [ProjectCategoryWhereInput!]
  NOT: [ProjectCategoryWhereInput!]
}

input ProjectCategoryWhereUniqueInput {
  id: UUID
  slug: String
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]!
  aggregate: AggregateProject!
}

type ProjectContent {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  project: Project!
  language: ProjectLng!
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  isActive: Boolean!
}

type ProjectContentConnection {
  pageInfo: PageInfo!
  edges: [ProjectContentEdge]!
  aggregate: AggregateProjectContent!
}

input ProjectContentCreateInput {
  id: UUID
  project: ProjectCreateOneWithoutContentsInput!
  language: ProjectLngCreateOneWithoutProjectsInput!
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  isActive: Boolean
}

input ProjectContentCreateManyWithoutLanguageInput {
  create: [ProjectContentCreateWithoutLanguageInput!]
  connect: [ProjectContentWhereUniqueInput!]
}

input ProjectContentCreateManyWithoutProjectInput {
  create: [ProjectContentCreateWithoutProjectInput!]
  connect: [ProjectContentWhereUniqueInput!]
}

input ProjectContentCreateWithoutLanguageInput {
  id: UUID
  project: ProjectCreateOneWithoutContentsInput!
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  isActive: Boolean
}

input ProjectContentCreateWithoutProjectInput {
  id: UUID
  language: ProjectLngCreateOneWithoutProjectsInput!
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  isActive: Boolean
}

type ProjectContentEdge {
  node: ProjectContent!
  cursor: String!
}

enum ProjectContentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  text_ASC
  text_DESC
  metaTitle_ASC
  metaTitle_DESC
  metaDescription_ASC
  metaDescription_DESC
  isActive_ASC
  isActive_DESC
}

type ProjectContentPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  text: String!
  metaTitle: String
  metaDescription: String
  isActive: Boolean!
}

input ProjectContentScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  metaTitle: String
  metaTitle_not: String
  metaTitle_in: [String!]
  metaTitle_not_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_contains: String
  metaTitle_not_contains: String
  metaTitle_starts_with: String
  metaTitle_not_starts_with: String
  metaTitle_ends_with: String
  metaTitle_not_ends_with: String
  metaDescription: String
  metaDescription_not: String
  metaDescription_in: [String!]
  metaDescription_not_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_contains: String
  metaDescription_not_contains: String
  metaDescription_starts_with: String
  metaDescription_not_starts_with: String
  metaDescription_ends_with: String
  metaDescription_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  AND: [ProjectContentScalarWhereInput!]
  OR: [ProjectContentScalarWhereInput!]
  NOT: [ProjectContentScalarWhereInput!]
}

type ProjectContentSubscriptionPayload {
  mutation: MutationType!
  node: ProjectContent
  updatedFields: [String!]
  previousValues: ProjectContentPreviousValues
}

input ProjectContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectContentWhereInput
  AND: [ProjectContentSubscriptionWhereInput!]
  OR: [ProjectContentSubscriptionWhereInput!]
  NOT: [ProjectContentSubscriptionWhereInput!]
}

input ProjectContentUpdateInput {
  project: ProjectUpdateOneRequiredWithoutContentsInput
  language: ProjectLngUpdateOneRequiredWithoutProjectsInput
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  isActive: Boolean
}

input ProjectContentUpdateManyDataInput {
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  isActive: Boolean
}

input ProjectContentUpdateManyMutationInput {
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  isActive: Boolean
}

input ProjectContentUpdateManyWithoutLanguageInput {
  create: [ProjectContentCreateWithoutLanguageInput!]
  delete: [ProjectContentWhereUniqueInput!]
  connect: [ProjectContentWhereUniqueInput!]
  set: [ProjectContentWhereUniqueInput!]
  disconnect: [ProjectContentWhereUniqueInput!]
  update: [ProjectContentUpdateWithWhereUniqueWithoutLanguageInput!]
  upsert: [ProjectContentUpsertWithWhereUniqueWithoutLanguageInput!]
  deleteMany: [ProjectContentScalarWhereInput!]
  updateMany: [ProjectContentUpdateManyWithWhereNestedInput!]
}

input ProjectContentUpdateManyWithoutProjectInput {
  create: [ProjectContentCreateWithoutProjectInput!]
  delete: [ProjectContentWhereUniqueInput!]
  connect: [ProjectContentWhereUniqueInput!]
  set: [ProjectContentWhereUniqueInput!]
  disconnect: [ProjectContentWhereUniqueInput!]
  update: [ProjectContentUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [ProjectContentUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [ProjectContentScalarWhereInput!]
  updateMany: [ProjectContentUpdateManyWithWhereNestedInput!]
}

input ProjectContentUpdateManyWithWhereNestedInput {
  where: ProjectContentScalarWhereInput!
  data: ProjectContentUpdateManyDataInput!
}

input ProjectContentUpdateWithoutLanguageDataInput {
  project: ProjectUpdateOneRequiredWithoutContentsInput
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  isActive: Boolean
}

input ProjectContentUpdateWithoutProjectDataInput {
  language: ProjectLngUpdateOneRequiredWithoutProjectsInput
  title: String
  text: String
  metaTitle: String
  metaDescription: String
  isActive: Boolean
}

input ProjectContentUpdateWithWhereUniqueWithoutLanguageInput {
  where: ProjectContentWhereUniqueInput!
  data: ProjectContentUpdateWithoutLanguageDataInput!
}

input ProjectContentUpdateWithWhereUniqueWithoutProjectInput {
  where: ProjectContentWhereUniqueInput!
  data: ProjectContentUpdateWithoutProjectDataInput!
}

input ProjectContentUpsertWithWhereUniqueWithoutLanguageInput {
  where: ProjectContentWhereUniqueInput!
  update: ProjectContentUpdateWithoutLanguageDataInput!
  create: ProjectContentCreateWithoutLanguageInput!
}

input ProjectContentUpsertWithWhereUniqueWithoutProjectInput {
  where: ProjectContentWhereUniqueInput!
  update: ProjectContentUpdateWithoutProjectDataInput!
  create: ProjectContentCreateWithoutProjectInput!
}

input ProjectContentWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  project: ProjectWhereInput
  language: ProjectLngWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  metaTitle: String
  metaTitle_not: String
  metaTitle_in: [String!]
  metaTitle_not_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_contains: String
  metaTitle_not_contains: String
  metaTitle_starts_with: String
  metaTitle_not_starts_with: String
  metaTitle_ends_with: String
  metaTitle_not_ends_with: String
  metaDescription: String
  metaDescription_not: String
  metaDescription_in: [String!]
  metaDescription_not_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_contains: String
  metaDescription_not_contains: String
  metaDescription_starts_with: String
  metaDescription_not_starts_with: String
  metaDescription_ends_with: String
  metaDescription_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  AND: [ProjectContentWhereInput!]
  OR: [ProjectContentWhereInput!]
  NOT: [ProjectContentWhereInput!]
}

input ProjectContentWhereUniqueInput {
  id: UUID
}

input ProjectCreateInput {
  id: UUID
  slug: String!
  category: ProjectCategoryCreateOneWithoutProjectsInput!
  author: UserCreateOneWithoutProjectsInput!
  album: ProjectAlbumCreateOneWithoutProjectInput!
  contents: ProjectContentCreateManyWithoutProjectInput
  tags: ProjectTagCreateManyInput
}

input ProjectCreateManyWithoutAuthorInput {
  create: [ProjectCreateWithoutAuthorInput!]
  connect: [ProjectWhereUniqueInput!]
}

input ProjectCreateManyWithoutCategoryInput {
  create: [ProjectCreateWithoutCategoryInput!]
  connect: [ProjectWhereUniqueInput!]
}

input ProjectCreateOneWithoutAlbumInput {
  create: ProjectCreateWithoutAlbumInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateOneWithoutContentsInput {
  create: ProjectCreateWithoutContentsInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateWithoutAlbumInput {
  id: UUID
  slug: String!
  category: ProjectCategoryCreateOneWithoutProjectsInput!
  author: UserCreateOneWithoutProjectsInput!
  contents: ProjectContentCreateManyWithoutProjectInput
  tags: ProjectTagCreateManyInput
}

input ProjectCreateWithoutAuthorInput {
  id: UUID
  slug: String!
  category: ProjectCategoryCreateOneWithoutProjectsInput!
  album: ProjectAlbumCreateOneWithoutProjectInput!
  contents: ProjectContentCreateManyWithoutProjectInput
  tags: ProjectTagCreateManyInput
}

input ProjectCreateWithoutCategoryInput {
  id: UUID
  slug: String!
  author: UserCreateOneWithoutProjectsInput!
  album: ProjectAlbumCreateOneWithoutProjectInput!
  contents: ProjectContentCreateManyWithoutProjectInput
  tags: ProjectTagCreateManyInput
}

input ProjectCreateWithoutContentsInput {
  id: UUID
  slug: String!
  category: ProjectCategoryCreateOneWithoutProjectsInput!
  author: UserCreateOneWithoutProjectsInput!
  album: ProjectAlbumCreateOneWithoutProjectInput!
  tags: ProjectTagCreateManyInput
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

type ProjectImage {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  album: ProjectAlbum!
  publicId: String!
  src: String!
  contents: ProjectImageContent!
}

type ProjectImageConnection {
  pageInfo: PageInfo!
  edges: [ProjectImageEdge]!
  aggregate: AggregateProjectImage!
}

type ProjectImageContent {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  image: ProjectImage!
  language: ProjectImageLng!
  alt: String!
}

type ProjectImageContentConnection {
  pageInfo: PageInfo!
  edges: [ProjectImageContentEdge]!
  aggregate: AggregateProjectImageContent!
}

input ProjectImageContentCreateInput {
  id: UUID
  image: ProjectImageCreateOneWithoutContentsInput!
  language: ProjectImageLngCreateOneWithoutImagesInput!
  alt: String!
}

input ProjectImageContentCreateManyWithoutLanguageInput {
  create: [ProjectImageContentCreateWithoutLanguageInput!]
  connect: [ProjectImageContentWhereUniqueInput!]
}

input ProjectImageContentCreateOneWithoutImageInput {
  create: ProjectImageContentCreateWithoutImageInput
  connect: ProjectImageContentWhereUniqueInput
}

input ProjectImageContentCreateWithoutImageInput {
  id: UUID
  language: ProjectImageLngCreateOneWithoutImagesInput!
  alt: String!
}

input ProjectImageContentCreateWithoutLanguageInput {
  id: UUID
  image: ProjectImageCreateOneWithoutContentsInput!
  alt: String!
}

type ProjectImageContentEdge {
  node: ProjectImageContent!
  cursor: String!
}

enum ProjectImageContentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  alt_ASC
  alt_DESC
}

type ProjectImageContentPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  alt: String!
}

input ProjectImageContentScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  alt: String
  alt_not: String
  alt_in: [String!]
  alt_not_in: [String!]
  alt_lt: String
  alt_lte: String
  alt_gt: String
  alt_gte: String
  alt_contains: String
  alt_not_contains: String
  alt_starts_with: String
  alt_not_starts_with: String
  alt_ends_with: String
  alt_not_ends_with: String
  AND: [ProjectImageContentScalarWhereInput!]
  OR: [ProjectImageContentScalarWhereInput!]
  NOT: [ProjectImageContentScalarWhereInput!]
}

type ProjectImageContentSubscriptionPayload {
  mutation: MutationType!
  node: ProjectImageContent
  updatedFields: [String!]
  previousValues: ProjectImageContentPreviousValues
}

input ProjectImageContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectImageContentWhereInput
  AND: [ProjectImageContentSubscriptionWhereInput!]
  OR: [ProjectImageContentSubscriptionWhereInput!]
  NOT: [ProjectImageContentSubscriptionWhereInput!]
}

input ProjectImageContentUpdateInput {
  image: ProjectImageUpdateOneRequiredWithoutContentsInput
  language: ProjectImageLngUpdateOneRequiredWithoutImagesInput
  alt: String
}

input ProjectImageContentUpdateManyDataInput {
  alt: String
}

input ProjectImageContentUpdateManyMutationInput {
  alt: String
}

input ProjectImageContentUpdateManyWithoutLanguageInput {
  create: [ProjectImageContentCreateWithoutLanguageInput!]
  delete: [ProjectImageContentWhereUniqueInput!]
  connect: [ProjectImageContentWhereUniqueInput!]
  set: [ProjectImageContentWhereUniqueInput!]
  disconnect: [ProjectImageContentWhereUniqueInput!]
  update: [ProjectImageContentUpdateWithWhereUniqueWithoutLanguageInput!]
  upsert: [ProjectImageContentUpsertWithWhereUniqueWithoutLanguageInput!]
  deleteMany: [ProjectImageContentScalarWhereInput!]
  updateMany: [ProjectImageContentUpdateManyWithWhereNestedInput!]
}

input ProjectImageContentUpdateManyWithWhereNestedInput {
  where: ProjectImageContentScalarWhereInput!
  data: ProjectImageContentUpdateManyDataInput!
}

input ProjectImageContentUpdateOneRequiredWithoutImageInput {
  create: ProjectImageContentCreateWithoutImageInput
  update: ProjectImageContentUpdateWithoutImageDataInput
  upsert: ProjectImageContentUpsertWithoutImageInput
  connect: ProjectImageContentWhereUniqueInput
}

input ProjectImageContentUpdateWithoutImageDataInput {
  language: ProjectImageLngUpdateOneRequiredWithoutImagesInput
  alt: String
}

input ProjectImageContentUpdateWithoutLanguageDataInput {
  image: ProjectImageUpdateOneRequiredWithoutContentsInput
  alt: String
}

input ProjectImageContentUpdateWithWhereUniqueWithoutLanguageInput {
  where: ProjectImageContentWhereUniqueInput!
  data: ProjectImageContentUpdateWithoutLanguageDataInput!
}

input ProjectImageContentUpsertWithoutImageInput {
  update: ProjectImageContentUpdateWithoutImageDataInput!
  create: ProjectImageContentCreateWithoutImageInput!
}

input ProjectImageContentUpsertWithWhereUniqueWithoutLanguageInput {
  where: ProjectImageContentWhereUniqueInput!
  update: ProjectImageContentUpdateWithoutLanguageDataInput!
  create: ProjectImageContentCreateWithoutLanguageInput!
}

input ProjectImageContentWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  image: ProjectImageWhereInput
  language: ProjectImageLngWhereInput
  alt: String
  alt_not: String
  alt_in: [String!]
  alt_not_in: [String!]
  alt_lt: String
  alt_lte: String
  alt_gt: String
  alt_gte: String
  alt_contains: String
  alt_not_contains: String
  alt_starts_with: String
  alt_not_starts_with: String
  alt_ends_with: String
  alt_not_ends_with: String
  AND: [ProjectImageContentWhereInput!]
  OR: [ProjectImageContentWhereInput!]
  NOT: [ProjectImageContentWhereInput!]
}

input ProjectImageContentWhereUniqueInput {
  id: UUID
}

input ProjectImageCreateInput {
  id: UUID
  album: ProjectAlbumCreateOneWithoutImagesInput!
  publicId: String!
  src: String!
  contents: ProjectImageContentCreateOneWithoutImageInput!
}

input ProjectImageCreateManyWithoutAlbumInput {
  create: [ProjectImageCreateWithoutAlbumInput!]
  connect: [ProjectImageWhereUniqueInput!]
}

input ProjectImageCreateOneWithoutContentsInput {
  create: ProjectImageCreateWithoutContentsInput
  connect: ProjectImageWhereUniqueInput
}

input ProjectImageCreateWithoutAlbumInput {
  id: UUID
  publicId: String!
  src: String!
  contents: ProjectImageContentCreateOneWithoutImageInput!
}

input ProjectImageCreateWithoutContentsInput {
  id: UUID
  album: ProjectAlbumCreateOneWithoutImagesInput!
  publicId: String!
  src: String!
}

type ProjectImageEdge {
  node: ProjectImage!
  cursor: String!
}

type ProjectImageLng {
  id: UUID!
  images(where: ProjectImageContentWhereInput, orderBy: ProjectImageContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectImageContent!]
  country: String!
  locale: String
}

type ProjectImageLngConnection {
  pageInfo: PageInfo!
  edges: [ProjectImageLngEdge]!
  aggregate: AggregateProjectImageLng!
}

input ProjectImageLngCreateInput {
  id: UUID
  images: ProjectImageContentCreateManyWithoutLanguageInput
  country: String!
  locale: String
}

input ProjectImageLngCreateOneWithoutImagesInput {
  create: ProjectImageLngCreateWithoutImagesInput
  connect: ProjectImageLngWhereUniqueInput
}

input ProjectImageLngCreateWithoutImagesInput {
  id: UUID
  country: String!
  locale: String
}

type ProjectImageLngEdge {
  node: ProjectImageLng!
  cursor: String!
}

enum ProjectImageLngOrderByInput {
  id_ASC
  id_DESC
  country_ASC
  country_DESC
  locale_ASC
  locale_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectImageLngPreviousValues {
  id: UUID!
  country: String!
  locale: String
}

type ProjectImageLngSubscriptionPayload {
  mutation: MutationType!
  node: ProjectImageLng
  updatedFields: [String!]
  previousValues: ProjectImageLngPreviousValues
}

input ProjectImageLngSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectImageLngWhereInput
  AND: [ProjectImageLngSubscriptionWhereInput!]
  OR: [ProjectImageLngSubscriptionWhereInput!]
  NOT: [ProjectImageLngSubscriptionWhereInput!]
}

input ProjectImageLngUpdateInput {
  images: ProjectImageContentUpdateManyWithoutLanguageInput
  country: String
  locale: String
}

input ProjectImageLngUpdateManyMutationInput {
  country: String
  locale: String
}

input ProjectImageLngUpdateOneRequiredWithoutImagesInput {
  create: ProjectImageLngCreateWithoutImagesInput
  update: ProjectImageLngUpdateWithoutImagesDataInput
  upsert: ProjectImageLngUpsertWithoutImagesInput
  connect: ProjectImageLngWhereUniqueInput
}

input ProjectImageLngUpdateWithoutImagesDataInput {
  country: String
  locale: String
}

input ProjectImageLngUpsertWithoutImagesInput {
  update: ProjectImageLngUpdateWithoutImagesDataInput!
  create: ProjectImageLngCreateWithoutImagesInput!
}

input ProjectImageLngWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  images_every: ProjectImageContentWhereInput
  images_some: ProjectImageContentWhereInput
  images_none: ProjectImageContentWhereInput
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  locale: String
  locale_not: String
  locale_in: [String!]
  locale_not_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_gt: String
  locale_gte: String
  locale_contains: String
  locale_not_contains: String
  locale_starts_with: String
  locale_not_starts_with: String
  locale_ends_with: String
  locale_not_ends_with: String
  AND: [ProjectImageLngWhereInput!]
  OR: [ProjectImageLngWhereInput!]
  NOT: [ProjectImageLngWhereInput!]
}

input ProjectImageLngWhereUniqueInput {
  id: UUID
  country: String
  locale: String
}

enum ProjectImageOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  publicId_ASC
  publicId_DESC
  src_ASC
  src_DESC
}

type ProjectImagePreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  publicId: String!
  src: String!
}

input ProjectImageScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  publicId: String
  publicId_not: String
  publicId_in: [String!]
  publicId_not_in: [String!]
  publicId_lt: String
  publicId_lte: String
  publicId_gt: String
  publicId_gte: String
  publicId_contains: String
  publicId_not_contains: String
  publicId_starts_with: String
  publicId_not_starts_with: String
  publicId_ends_with: String
  publicId_not_ends_with: String
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  AND: [ProjectImageScalarWhereInput!]
  OR: [ProjectImageScalarWhereInput!]
  NOT: [ProjectImageScalarWhereInput!]
}

type ProjectImageSubscriptionPayload {
  mutation: MutationType!
  node: ProjectImage
  updatedFields: [String!]
  previousValues: ProjectImagePreviousValues
}

input ProjectImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectImageWhereInput
  AND: [ProjectImageSubscriptionWhereInput!]
  OR: [ProjectImageSubscriptionWhereInput!]
  NOT: [ProjectImageSubscriptionWhereInput!]
}

input ProjectImageUpdateInput {
  album: ProjectAlbumUpdateOneRequiredWithoutImagesInput
  publicId: String
  src: String
  contents: ProjectImageContentUpdateOneRequiredWithoutImageInput
}

input ProjectImageUpdateManyDataInput {
  publicId: String
  src: String
}

input ProjectImageUpdateManyMutationInput {
  publicId: String
  src: String
}

input ProjectImageUpdateManyWithoutAlbumInput {
  create: [ProjectImageCreateWithoutAlbumInput!]
  delete: [ProjectImageWhereUniqueInput!]
  connect: [ProjectImageWhereUniqueInput!]
  set: [ProjectImageWhereUniqueInput!]
  disconnect: [ProjectImageWhereUniqueInput!]
  update: [ProjectImageUpdateWithWhereUniqueWithoutAlbumInput!]
  upsert: [ProjectImageUpsertWithWhereUniqueWithoutAlbumInput!]
  deleteMany: [ProjectImageScalarWhereInput!]
  updateMany: [ProjectImageUpdateManyWithWhereNestedInput!]
}

input ProjectImageUpdateManyWithWhereNestedInput {
  where: ProjectImageScalarWhereInput!
  data: ProjectImageUpdateManyDataInput!
}

input ProjectImageUpdateOneRequiredWithoutContentsInput {
  create: ProjectImageCreateWithoutContentsInput
  update: ProjectImageUpdateWithoutContentsDataInput
  upsert: ProjectImageUpsertWithoutContentsInput
  connect: ProjectImageWhereUniqueInput
}

input ProjectImageUpdateWithoutAlbumDataInput {
  publicId: String
  src: String
  contents: ProjectImageContentUpdateOneRequiredWithoutImageInput
}

input ProjectImageUpdateWithoutContentsDataInput {
  album: ProjectAlbumUpdateOneRequiredWithoutImagesInput
  publicId: String
  src: String
}

input ProjectImageUpdateWithWhereUniqueWithoutAlbumInput {
  where: ProjectImageWhereUniqueInput!
  data: ProjectImageUpdateWithoutAlbumDataInput!
}

input ProjectImageUpsertWithoutContentsInput {
  update: ProjectImageUpdateWithoutContentsDataInput!
  create: ProjectImageCreateWithoutContentsInput!
}

input ProjectImageUpsertWithWhereUniqueWithoutAlbumInput {
  where: ProjectImageWhereUniqueInput!
  update: ProjectImageUpdateWithoutAlbumDataInput!
  create: ProjectImageCreateWithoutAlbumInput!
}

input ProjectImageWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  album: ProjectAlbumWhereInput
  publicId: String
  publicId_not: String
  publicId_in: [String!]
  publicId_not_in: [String!]
  publicId_lt: String
  publicId_lte: String
  publicId_gt: String
  publicId_gte: String
  publicId_contains: String
  publicId_not_contains: String
  publicId_starts_with: String
  publicId_not_starts_with: String
  publicId_ends_with: String
  publicId_not_ends_with: String
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  contents: ProjectImageContentWhereInput
  AND: [ProjectImageWhereInput!]
  OR: [ProjectImageWhereInput!]
  NOT: [ProjectImageWhereInput!]
}

input ProjectImageWhereUniqueInput {
  id: UUID
}

type ProjectLng {
  id: UUID!
  projects(where: ProjectContentWhereInput, orderBy: ProjectContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectContent!]
  country: String!
  locale: String
}

type ProjectLngConnection {
  pageInfo: PageInfo!
  edges: [ProjectLngEdge]!
  aggregate: AggregateProjectLng!
}

input ProjectLngCreateInput {
  id: UUID
  projects: ProjectContentCreateManyWithoutLanguageInput
  country: String!
  locale: String
}

input ProjectLngCreateOneWithoutProjectsInput {
  create: ProjectLngCreateWithoutProjectsInput
  connect: ProjectLngWhereUniqueInput
}

input ProjectLngCreateWithoutProjectsInput {
  id: UUID
  country: String!
  locale: String
}

type ProjectLngEdge {
  node: ProjectLng!
  cursor: String!
}

enum ProjectLngOrderByInput {
  id_ASC
  id_DESC
  country_ASC
  country_DESC
  locale_ASC
  locale_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectLngPreviousValues {
  id: UUID!
  country: String!
  locale: String
}

type ProjectLngSubscriptionPayload {
  mutation: MutationType!
  node: ProjectLng
  updatedFields: [String!]
  previousValues: ProjectLngPreviousValues
}

input ProjectLngSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectLngWhereInput
  AND: [ProjectLngSubscriptionWhereInput!]
  OR: [ProjectLngSubscriptionWhereInput!]
  NOT: [ProjectLngSubscriptionWhereInput!]
}

input ProjectLngUpdateInput {
  projects: ProjectContentUpdateManyWithoutLanguageInput
  country: String
  locale: String
}

input ProjectLngUpdateManyMutationInput {
  country: String
  locale: String
}

input ProjectLngUpdateOneRequiredWithoutProjectsInput {
  create: ProjectLngCreateWithoutProjectsInput
  update: ProjectLngUpdateWithoutProjectsDataInput
  upsert: ProjectLngUpsertWithoutProjectsInput
  connect: ProjectLngWhereUniqueInput
}

input ProjectLngUpdateWithoutProjectsDataInput {
  country: String
  locale: String
}

input ProjectLngUpsertWithoutProjectsInput {
  update: ProjectLngUpdateWithoutProjectsDataInput!
  create: ProjectLngCreateWithoutProjectsInput!
}

input ProjectLngWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  projects_every: ProjectContentWhereInput
  projects_some: ProjectContentWhereInput
  projects_none: ProjectContentWhereInput
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  locale: String
  locale_not: String
  locale_in: [String!]
  locale_not_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_gt: String
  locale_gte: String
  locale_contains: String
  locale_not_contains: String
  locale_starts_with: String
  locale_not_starts_with: String
  locale_ends_with: String
  locale_not_ends_with: String
  AND: [ProjectLngWhereInput!]
  OR: [ProjectLngWhereInput!]
  NOT: [ProjectLngWhereInput!]
}

input ProjectLngWhereUniqueInput {
  id: UUID
  country: String
  locale: String
}

enum ProjectOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  slug_ASC
  slug_DESC
}

type ProjectPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  slug: String!
}

input ProjectScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  AND: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
}

type ProjectSubscriptionPayload {
  mutation: MutationType!
  node: Project
  updatedFields: [String!]
  previousValues: ProjectPreviousValues
}

input ProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectWhereInput
  AND: [ProjectSubscriptionWhereInput!]
  OR: [ProjectSubscriptionWhereInput!]
  NOT: [ProjectSubscriptionWhereInput!]
}

type ProjectTag {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  language: ProjectTagLng!
  contents: ProjectTagContent!
  title: String!
  color: String
}

type ProjectTagConnection {
  pageInfo: PageInfo!
  edges: [ProjectTagEdge]!
  aggregate: AggregateProjectTag!
}

type ProjectTagContent {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  tag: ProjectTag!
  title: String
}

type ProjectTagContentConnection {
  pageInfo: PageInfo!
  edges: [ProjectTagContentEdge]!
  aggregate: AggregateProjectTagContent!
}

input ProjectTagContentCreateInput {
  id: UUID
  tag: ProjectTagCreateOneWithoutContentsInput!
  title: String
}

input ProjectTagContentCreateOneWithoutTagInput {
  create: ProjectTagContentCreateWithoutTagInput
  connect: ProjectTagContentWhereUniqueInput
}

input ProjectTagContentCreateWithoutTagInput {
  id: UUID
  title: String
}

type ProjectTagContentEdge {
  node: ProjectTagContent!
  cursor: String!
}

enum ProjectTagContentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
}

type ProjectTagContentPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String
}

type ProjectTagContentSubscriptionPayload {
  mutation: MutationType!
  node: ProjectTagContent
  updatedFields: [String!]
  previousValues: ProjectTagContentPreviousValues
}

input ProjectTagContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectTagContentWhereInput
  AND: [ProjectTagContentSubscriptionWhereInput!]
  OR: [ProjectTagContentSubscriptionWhereInput!]
  NOT: [ProjectTagContentSubscriptionWhereInput!]
}

input ProjectTagContentUpdateInput {
  tag: ProjectTagUpdateOneRequiredWithoutContentsInput
  title: String
}

input ProjectTagContentUpdateManyMutationInput {
  title: String
}

input ProjectTagContentUpdateOneRequiredWithoutTagInput {
  create: ProjectTagContentCreateWithoutTagInput
  update: ProjectTagContentUpdateWithoutTagDataInput
  upsert: ProjectTagContentUpsertWithoutTagInput
  connect: ProjectTagContentWhereUniqueInput
}

input ProjectTagContentUpdateWithoutTagDataInput {
  title: String
}

input ProjectTagContentUpsertWithoutTagInput {
  update: ProjectTagContentUpdateWithoutTagDataInput!
  create: ProjectTagContentCreateWithoutTagInput!
}

input ProjectTagContentWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  tag: ProjectTagWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [ProjectTagContentWhereInput!]
  OR: [ProjectTagContentWhereInput!]
  NOT: [ProjectTagContentWhereInput!]
}

input ProjectTagContentWhereUniqueInput {
  id: UUID
}

input ProjectTagCreateInput {
  id: UUID
  language: ProjectTagLngCreateOneWithoutTagsInput!
  contents: ProjectTagContentCreateOneWithoutTagInput!
  title: String!
  color: String
}

input ProjectTagCreateManyInput {
  create: [ProjectTagCreateInput!]
  connect: [ProjectTagWhereUniqueInput!]
}

input ProjectTagCreateManyWithoutLanguageInput {
  create: [ProjectTagCreateWithoutLanguageInput!]
  connect: [ProjectTagWhereUniqueInput!]
}

input ProjectTagCreateOneWithoutContentsInput {
  create: ProjectTagCreateWithoutContentsInput
  connect: ProjectTagWhereUniqueInput
}

input ProjectTagCreateWithoutContentsInput {
  id: UUID
  language: ProjectTagLngCreateOneWithoutTagsInput!
  title: String!
  color: String
}

input ProjectTagCreateWithoutLanguageInput {
  id: UUID
  contents: ProjectTagContentCreateOneWithoutTagInput!
  title: String!
  color: String
}

type ProjectTagEdge {
  node: ProjectTag!
  cursor: String!
}

type ProjectTagLng {
  id: UUID!
  tags(where: ProjectTagWhereInput, orderBy: ProjectTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectTag!]
  country: String!
  locale: String!
}

type ProjectTagLngConnection {
  pageInfo: PageInfo!
  edges: [ProjectTagLngEdge]!
  aggregate: AggregateProjectTagLng!
}

input ProjectTagLngCreateInput {
  id: UUID
  tags: ProjectTagCreateManyWithoutLanguageInput
  country: String!
  locale: String!
}

input ProjectTagLngCreateOneWithoutTagsInput {
  create: ProjectTagLngCreateWithoutTagsInput
  connect: ProjectTagLngWhereUniqueInput
}

input ProjectTagLngCreateWithoutTagsInput {
  id: UUID
  country: String!
  locale: String!
}

type ProjectTagLngEdge {
  node: ProjectTagLng!
  cursor: String!
}

enum ProjectTagLngOrderByInput {
  id_ASC
  id_DESC
  country_ASC
  country_DESC
  locale_ASC
  locale_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectTagLngPreviousValues {
  id: UUID!
  country: String!
  locale: String!
}

type ProjectTagLngSubscriptionPayload {
  mutation: MutationType!
  node: ProjectTagLng
  updatedFields: [String!]
  previousValues: ProjectTagLngPreviousValues
}

input ProjectTagLngSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectTagLngWhereInput
  AND: [ProjectTagLngSubscriptionWhereInput!]
  OR: [ProjectTagLngSubscriptionWhereInput!]
  NOT: [ProjectTagLngSubscriptionWhereInput!]
}

input ProjectTagLngUpdateInput {
  tags: ProjectTagUpdateManyWithoutLanguageInput
  country: String
  locale: String
}

input ProjectTagLngUpdateManyMutationInput {
  country: String
  locale: String
}

input ProjectTagLngUpdateOneRequiredWithoutTagsInput {
  create: ProjectTagLngCreateWithoutTagsInput
  update: ProjectTagLngUpdateWithoutTagsDataInput
  upsert: ProjectTagLngUpsertWithoutTagsInput
  connect: ProjectTagLngWhereUniqueInput
}

input ProjectTagLngUpdateWithoutTagsDataInput {
  country: String
  locale: String
}

input ProjectTagLngUpsertWithoutTagsInput {
  update: ProjectTagLngUpdateWithoutTagsDataInput!
  create: ProjectTagLngCreateWithoutTagsInput!
}

input ProjectTagLngWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  tags_every: ProjectTagWhereInput
  tags_some: ProjectTagWhereInput
  tags_none: ProjectTagWhereInput
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  locale: String
  locale_not: String
  locale_in: [String!]
  locale_not_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_gt: String
  locale_gte: String
  locale_contains: String
  locale_not_contains: String
  locale_starts_with: String
  locale_not_starts_with: String
  locale_ends_with: String
  locale_not_ends_with: String
  AND: [ProjectTagLngWhereInput!]
  OR: [ProjectTagLngWhereInput!]
  NOT: [ProjectTagLngWhereInput!]
}

input ProjectTagLngWhereUniqueInput {
  id: UUID
}

enum ProjectTagOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  color_ASC
  color_DESC
}

type ProjectTagPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  color: String
}

input ProjectTagScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  color: String
  color_not: String
  color_in: [String!]
  color_not_in: [String!]
  color_lt: String
  color_lte: String
  color_gt: String
  color_gte: String
  color_contains: String
  color_not_contains: String
  color_starts_with: String
  color_not_starts_with: String
  color_ends_with: String
  color_not_ends_with: String
  AND: [ProjectTagScalarWhereInput!]
  OR: [ProjectTagScalarWhereInput!]
  NOT: [ProjectTagScalarWhereInput!]
}

type ProjectTagSubscriptionPayload {
  mutation: MutationType!
  node: ProjectTag
  updatedFields: [String!]
  previousValues: ProjectTagPreviousValues
}

input ProjectTagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectTagWhereInput
  AND: [ProjectTagSubscriptionWhereInput!]
  OR: [ProjectTagSubscriptionWhereInput!]
  NOT: [ProjectTagSubscriptionWhereInput!]
}

input ProjectTagUpdateDataInput {
  language: ProjectTagLngUpdateOneRequiredWithoutTagsInput
  contents: ProjectTagContentUpdateOneRequiredWithoutTagInput
  title: String
  color: String
}

input ProjectTagUpdateInput {
  language: ProjectTagLngUpdateOneRequiredWithoutTagsInput
  contents: ProjectTagContentUpdateOneRequiredWithoutTagInput
  title: String
  color: String
}

input ProjectTagUpdateManyDataInput {
  title: String
  color: String
}

input ProjectTagUpdateManyInput {
  create: [ProjectTagCreateInput!]
  update: [ProjectTagUpdateWithWhereUniqueNestedInput!]
  upsert: [ProjectTagUpsertWithWhereUniqueNestedInput!]
  delete: [ProjectTagWhereUniqueInput!]
  connect: [ProjectTagWhereUniqueInput!]
  set: [ProjectTagWhereUniqueInput!]
  disconnect: [ProjectTagWhereUniqueInput!]
  deleteMany: [ProjectTagScalarWhereInput!]
  updateMany: [ProjectTagUpdateManyWithWhereNestedInput!]
}

input ProjectTagUpdateManyMutationInput {
  title: String
  color: String
}

input ProjectTagUpdateManyWithoutLanguageInput {
  create: [ProjectTagCreateWithoutLanguageInput!]
  delete: [ProjectTagWhereUniqueInput!]
  connect: [ProjectTagWhereUniqueInput!]
  set: [ProjectTagWhereUniqueInput!]
  disconnect: [ProjectTagWhereUniqueInput!]
  update: [ProjectTagUpdateWithWhereUniqueWithoutLanguageInput!]
  upsert: [ProjectTagUpsertWithWhereUniqueWithoutLanguageInput!]
  deleteMany: [ProjectTagScalarWhereInput!]
  updateMany: [ProjectTagUpdateManyWithWhereNestedInput!]
}

input ProjectTagUpdateManyWithWhereNestedInput {
  where: ProjectTagScalarWhereInput!
  data: ProjectTagUpdateManyDataInput!
}

input ProjectTagUpdateOneRequiredWithoutContentsInput {
  create: ProjectTagCreateWithoutContentsInput
  update: ProjectTagUpdateWithoutContentsDataInput
  upsert: ProjectTagUpsertWithoutContentsInput
  connect: ProjectTagWhereUniqueInput
}

input ProjectTagUpdateWithoutContentsDataInput {
  language: ProjectTagLngUpdateOneRequiredWithoutTagsInput
  title: String
  color: String
}

input ProjectTagUpdateWithoutLanguageDataInput {
  contents: ProjectTagContentUpdateOneRequiredWithoutTagInput
  title: String
  color: String
}

input ProjectTagUpdateWithWhereUniqueNestedInput {
  where: ProjectTagWhereUniqueInput!
  data: ProjectTagUpdateDataInput!
}

input ProjectTagUpdateWithWhereUniqueWithoutLanguageInput {
  where: ProjectTagWhereUniqueInput!
  data: ProjectTagUpdateWithoutLanguageDataInput!
}

input ProjectTagUpsertWithoutContentsInput {
  update: ProjectTagUpdateWithoutContentsDataInput!
  create: ProjectTagCreateWithoutContentsInput!
}

input ProjectTagUpsertWithWhereUniqueNestedInput {
  where: ProjectTagWhereUniqueInput!
  update: ProjectTagUpdateDataInput!
  create: ProjectTagCreateInput!
}

input ProjectTagUpsertWithWhereUniqueWithoutLanguageInput {
  where: ProjectTagWhereUniqueInput!
  update: ProjectTagUpdateWithoutLanguageDataInput!
  create: ProjectTagCreateWithoutLanguageInput!
}

input ProjectTagWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  language: ProjectTagLngWhereInput
  contents: ProjectTagContentWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  color: String
  color_not: String
  color_in: [String!]
  color_not_in: [String!]
  color_lt: String
  color_lte: String
  color_gt: String
  color_gte: String
  color_contains: String
  color_not_contains: String
  color_starts_with: String
  color_not_starts_with: String
  color_ends_with: String
  color_not_ends_with: String
  AND: [ProjectTagWhereInput!]
  OR: [ProjectTagWhereInput!]
  NOT: [ProjectTagWhereInput!]
}

input ProjectTagWhereUniqueInput {
  id: UUID
}

input ProjectUpdateInput {
  slug: String
  category: ProjectCategoryUpdateOneRequiredWithoutProjectsInput
  author: UserUpdateOneRequiredWithoutProjectsInput
  album: ProjectAlbumUpdateOneRequiredWithoutProjectInput
  contents: ProjectContentUpdateManyWithoutProjectInput
  tags: ProjectTagUpdateManyInput
}

input ProjectUpdateManyDataInput {
  slug: String
}

input ProjectUpdateManyMutationInput {
  slug: String
}

input ProjectUpdateManyWithoutAuthorInput {
  create: [ProjectCreateWithoutAuthorInput!]
  delete: [ProjectWhereUniqueInput!]
  connect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  disconnect: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [ProjectScalarWhereInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
}

input ProjectUpdateManyWithoutCategoryInput {
  create: [ProjectCreateWithoutCategoryInput!]
  delete: [ProjectWhereUniqueInput!]
  connect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  disconnect: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [ProjectScalarWhereInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput!
  data: ProjectUpdateManyDataInput!
}

input ProjectUpdateOneRequiredWithoutAlbumInput {
  create: ProjectCreateWithoutAlbumInput
  update: ProjectUpdateWithoutAlbumDataInput
  upsert: ProjectUpsertWithoutAlbumInput
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateOneRequiredWithoutContentsInput {
  create: ProjectCreateWithoutContentsInput
  update: ProjectUpdateWithoutContentsDataInput
  upsert: ProjectUpsertWithoutContentsInput
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateWithoutAlbumDataInput {
  slug: String
  category: ProjectCategoryUpdateOneRequiredWithoutProjectsInput
  author: UserUpdateOneRequiredWithoutProjectsInput
  contents: ProjectContentUpdateManyWithoutProjectInput
  tags: ProjectTagUpdateManyInput
}

input ProjectUpdateWithoutAuthorDataInput {
  slug: String
  category: ProjectCategoryUpdateOneRequiredWithoutProjectsInput
  album: ProjectAlbumUpdateOneRequiredWithoutProjectInput
  contents: ProjectContentUpdateManyWithoutProjectInput
  tags: ProjectTagUpdateManyInput
}

input ProjectUpdateWithoutCategoryDataInput {
  slug: String
  author: UserUpdateOneRequiredWithoutProjectsInput
  album: ProjectAlbumUpdateOneRequiredWithoutProjectInput
  contents: ProjectContentUpdateManyWithoutProjectInput
  tags: ProjectTagUpdateManyInput
}

input ProjectUpdateWithoutContentsDataInput {
  slug: String
  category: ProjectCategoryUpdateOneRequiredWithoutProjectsInput
  author: UserUpdateOneRequiredWithoutProjectsInput
  album: ProjectAlbumUpdateOneRequiredWithoutProjectInput
  tags: ProjectTagUpdateManyInput
}

input ProjectUpdateWithWhereUniqueWithoutAuthorInput {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateWithoutAuthorDataInput!
}

input ProjectUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateWithoutCategoryDataInput!
}

input ProjectUpsertWithoutAlbumInput {
  update: ProjectUpdateWithoutAlbumDataInput!
  create: ProjectCreateWithoutAlbumInput!
}

input ProjectUpsertWithoutContentsInput {
  update: ProjectUpdateWithoutContentsDataInput!
  create: ProjectCreateWithoutContentsInput!
}

input ProjectUpsertWithWhereUniqueWithoutAuthorInput {
  where: ProjectWhereUniqueInput!
  update: ProjectUpdateWithoutAuthorDataInput!
  create: ProjectCreateWithoutAuthorInput!
}

input ProjectUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProjectWhereUniqueInput!
  update: ProjectUpdateWithoutCategoryDataInput!
  create: ProjectCreateWithoutCategoryInput!
}

input ProjectWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  category: ProjectCategoryWhereInput
  author: UserWhereInput
  album: ProjectAlbumWhereInput
  contents_every: ProjectContentWhereInput
  contents_some: ProjectContentWhereInput
  contents_none: ProjectContentWhereInput
  tags_every: ProjectTagWhereInput
  tags_some: ProjectTagWhereInput
  tags_none: ProjectTagWhereInput
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
}

input ProjectWhereUniqueInput {
  id: UUID
  slug: String
}

type Query {
  avatar(where: AvatarWhereUniqueInput!): Avatar
  avatars(where: AvatarWhereInput, orderBy: AvatarOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Avatar]!
  avatarsConnection(where: AvatarWhereInput, orderBy: AvatarOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AvatarConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  postContent(where: PostContentWhereUniqueInput!): PostContent
  postContents(where: PostContentWhereInput, orderBy: PostContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostContent]!
  postContentsConnection(where: PostContentWhereInput, orderBy: PostContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostContentConnection!
  postLng(where: PostLngWhereUniqueInput!): PostLng
  postLngs(where: PostLngWhereInput, orderBy: PostLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostLng]!
  postLngsConnection(where: PostLngWhereInput, orderBy: PostLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostLngConnection!
  postTag(where: PostTagWhereUniqueInput!): PostTag
  postTags(where: PostTagWhereInput, orderBy: PostTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostTag]!
  postTagsConnection(where: PostTagWhereInput, orderBy: PostTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostTagConnection!
  postTagContent(where: PostTagContentWhereUniqueInput!): PostTagContent
  postTagContents(where: PostTagContentWhereInput, orderBy: PostTagContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostTagContent]!
  postTagContentsConnection(where: PostTagContentWhereInput, orderBy: PostTagContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostTagContentConnection!
  postTagLng(where: PostTagLngWhereUniqueInput!): PostTagLng
  postTagLngs(where: PostTagLngWhereInput, orderBy: PostTagLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostTagLng]!
  postTagLngsConnection(where: PostTagLngWhereInput, orderBy: PostTagLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostTagLngConnection!
  profile(where: ProfileWhereUniqueInput!): Profile
  profiles(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Profile]!
  profilesConnection(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProfileConnection!
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
  projectsConnection(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectConnection!
  projectAlbum(where: ProjectAlbumWhereUniqueInput!): ProjectAlbum
  projectAlbums(where: ProjectAlbumWhereInput, orderBy: ProjectAlbumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectAlbum]!
  projectAlbumsConnection(where: ProjectAlbumWhereInput, orderBy: ProjectAlbumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectAlbumConnection!
  projectCategory(where: ProjectCategoryWhereUniqueInput!): ProjectCategory
  projectCategories(where: ProjectCategoryWhereInput, orderBy: ProjectCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectCategory]!
  projectCategoriesConnection(where: ProjectCategoryWhereInput, orderBy: ProjectCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectCategoryConnection!
  projectCategoryContent(where: ProjectCategoryContentWhereUniqueInput!): ProjectCategoryContent
  projectCategoryContents(where: ProjectCategoryContentWhereInput, orderBy: ProjectCategoryContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectCategoryContent]!
  projectCategoryContentsConnection(where: ProjectCategoryContentWhereInput, orderBy: ProjectCategoryContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectCategoryContentConnection!
  projectCategoryLng(where: ProjectCategoryLngWhereUniqueInput!): ProjectCategoryLng
  projectCategoryLngs(where: ProjectCategoryLngWhereInput, orderBy: ProjectCategoryLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectCategoryLng]!
  projectCategoryLngsConnection(where: ProjectCategoryLngWhereInput, orderBy: ProjectCategoryLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectCategoryLngConnection!
  projectContent(where: ProjectContentWhereUniqueInput!): ProjectContent
  projectContents(where: ProjectContentWhereInput, orderBy: ProjectContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectContent]!
  projectContentsConnection(where: ProjectContentWhereInput, orderBy: ProjectContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectContentConnection!
  projectImage(where: ProjectImageWhereUniqueInput!): ProjectImage
  projectImages(where: ProjectImageWhereInput, orderBy: ProjectImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectImage]!
  projectImagesConnection(where: ProjectImageWhereInput, orderBy: ProjectImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectImageConnection!
  projectImageContent(where: ProjectImageContentWhereUniqueInput!): ProjectImageContent
  projectImageContents(where: ProjectImageContentWhereInput, orderBy: ProjectImageContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectImageContent]!
  projectImageContentsConnection(where: ProjectImageContentWhereInput, orderBy: ProjectImageContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectImageContentConnection!
  projectImageLng(where: ProjectImageLngWhereUniqueInput!): ProjectImageLng
  projectImageLngs(where: ProjectImageLngWhereInput, orderBy: ProjectImageLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectImageLng]!
  projectImageLngsConnection(where: ProjectImageLngWhereInput, orderBy: ProjectImageLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectImageLngConnection!
  projectLng(where: ProjectLngWhereUniqueInput!): ProjectLng
  projectLngs(where: ProjectLngWhereInput, orderBy: ProjectLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectLng]!
  projectLngsConnection(where: ProjectLngWhereInput, orderBy: ProjectLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectLngConnection!
  projectTag(where: ProjectTagWhereUniqueInput!): ProjectTag
  projectTags(where: ProjectTagWhereInput, orderBy: ProjectTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectTag]!
  projectTagsConnection(where: ProjectTagWhereInput, orderBy: ProjectTagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectTagConnection!
  projectTagContent(where: ProjectTagContentWhereUniqueInput!): ProjectTagContent
  projectTagContents(where: ProjectTagContentWhereInput, orderBy: ProjectTagContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectTagContent]!
  projectTagContentsConnection(where: ProjectTagContentWhereInput, orderBy: ProjectTagContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectTagContentConnection!
  projectTagLng(where: ProjectTagLngWhereUniqueInput!): ProjectTagLng
  projectTagLngs(where: ProjectTagLngWhereInput, orderBy: ProjectTagLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectTagLng]!
  projectTagLngsConnection(where: ProjectTagLngWhereInput, orderBy: ProjectTagLngOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectTagLngConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Role {
  ADMIN
  SITEMANAGER
  USER
}

type Subscription {
  avatar(where: AvatarSubscriptionWhereInput): AvatarSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  postContent(where: PostContentSubscriptionWhereInput): PostContentSubscriptionPayload
  postLng(where: PostLngSubscriptionWhereInput): PostLngSubscriptionPayload
  postTag(where: PostTagSubscriptionWhereInput): PostTagSubscriptionPayload
  postTagContent(where: PostTagContentSubscriptionWhereInput): PostTagContentSubscriptionPayload
  postTagLng(where: PostTagLngSubscriptionWhereInput): PostTagLngSubscriptionPayload
  profile(where: ProfileSubscriptionWhereInput): ProfileSubscriptionPayload
  project(where: ProjectSubscriptionWhereInput): ProjectSubscriptionPayload
  projectAlbum(where: ProjectAlbumSubscriptionWhereInput): ProjectAlbumSubscriptionPayload
  projectCategory(where: ProjectCategorySubscriptionWhereInput): ProjectCategorySubscriptionPayload
  projectCategoryContent(where: ProjectCategoryContentSubscriptionWhereInput): ProjectCategoryContentSubscriptionPayload
  projectCategoryLng(where: ProjectCategoryLngSubscriptionWhereInput): ProjectCategoryLngSubscriptionPayload
  projectContent(where: ProjectContentSubscriptionWhereInput): ProjectContentSubscriptionPayload
  projectImage(where: ProjectImageSubscriptionWhereInput): ProjectImageSubscriptionPayload
  projectImageContent(where: ProjectImageContentSubscriptionWhereInput): ProjectImageContentSubscriptionPayload
  projectImageLng(where: ProjectImageLngSubscriptionWhereInput): ProjectImageLngSubscriptionPayload
  projectLng(where: ProjectLngSubscriptionWhereInput): ProjectLngSubscriptionPayload
  projectTag(where: ProjectTagSubscriptionWhereInput): ProjectTagSubscriptionPayload
  projectTagContent(where: ProjectTagContentSubscriptionWhereInput): ProjectTagContentSubscriptionPayload
  projectTagLng(where: ProjectTagLngSubscriptionWhereInput): ProjectTagLngSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  email: String
  password: String!
  role: Role!
  profile: Profile
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  postLikes(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: UUID
  name: String!
  email: String
  password: String!
  role: Role
  profile: ProfileCreateOneWithoutUserInput
  posts: PostCreateManyWithoutAuthorInput
  postLikes: PostCreateManyWithoutLikedByInput
  projects: ProjectCreateManyWithoutAuthorInput
  comments: CommentCreateManyWithoutAuthorInput
}

input UserCreateManyWithoutPostLikesInput {
  create: [UserCreateWithoutPostLikesInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutProfileInput {
  create: UserCreateWithoutProfileInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCommentsInput {
  id: UUID
  name: String!
  email: String
  password: String!
  role: Role
  profile: ProfileCreateOneWithoutUserInput
  posts: PostCreateManyWithoutAuthorInput
  postLikes: PostCreateManyWithoutLikedByInput
  projects: ProjectCreateManyWithoutAuthorInput
}

input UserCreateWithoutPostLikesInput {
  id: UUID
  name: String!
  email: String
  password: String!
  role: Role
  profile: ProfileCreateOneWithoutUserInput
  posts: PostCreateManyWithoutAuthorInput
  projects: ProjectCreateManyWithoutAuthorInput
  comments: CommentCreateManyWithoutAuthorInput
}

input UserCreateWithoutPostsInput {
  id: UUID
  name: String!
  email: String
  password: String!
  role: Role
  profile: ProfileCreateOneWithoutUserInput
  postLikes: PostCreateManyWithoutLikedByInput
  projects: ProjectCreateManyWithoutAuthorInput
  comments: CommentCreateManyWithoutAuthorInput
}

input UserCreateWithoutProfileInput {
  id: UUID
  name: String!
  email: String
  password: String!
  role: Role
  posts: PostCreateManyWithoutAuthorInput
  postLikes: PostCreateManyWithoutLikedByInput
  projects: ProjectCreateManyWithoutAuthorInput
  comments: CommentCreateManyWithoutAuthorInput
}

input UserCreateWithoutProjectsInput {
  id: UUID
  name: String!
  email: String
  password: String!
  role: Role
  profile: ProfileCreateOneWithoutUserInput
  posts: PostCreateManyWithoutAuthorInput
  postLikes: PostCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
}

type UserPreviousValues {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  email: String
  password: String!
  role: Role!
}

input UserScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  role: Role
  profile: ProfileUpdateOneWithoutUserInput
  posts: PostUpdateManyWithoutAuthorInput
  postLikes: PostUpdateManyWithoutLikedByInput
  projects: ProjectUpdateManyWithoutAuthorInput
  comments: CommentUpdateManyWithoutAuthorInput
}

input UserUpdateManyDataInput {
  name: String
  email: String
  password: String
  role: Role
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
  role: Role
}

input UserUpdateManyWithoutPostLikesInput {
  create: [UserCreateWithoutPostLikesInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutPostLikesInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutPostLikesInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutProfileInput {
  create: UserCreateWithoutProfileInput
  update: UserUpdateWithoutProfileDataInput
  upsert: UserUpsertWithoutProfileInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput
  update: UserUpdateWithoutProjectsDataInput
  upsert: UserUpsertWithoutProjectsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutCommentsDataInput {
  name: String
  email: String
  password: String
  role: Role
  profile: ProfileUpdateOneWithoutUserInput
  posts: PostUpdateManyWithoutAuthorInput
  postLikes: PostUpdateManyWithoutLikedByInput
  projects: ProjectUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutPostLikesDataInput {
  name: String
  email: String
  password: String
  role: Role
  profile: ProfileUpdateOneWithoutUserInput
  posts: PostUpdateManyWithoutAuthorInput
  projects: ProjectUpdateManyWithoutAuthorInput
  comments: CommentUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutPostsDataInput {
  name: String
  email: String
  password: String
  role: Role
  profile: ProfileUpdateOneWithoutUserInput
  postLikes: PostUpdateManyWithoutLikedByInput
  projects: ProjectUpdateManyWithoutAuthorInput
  comments: CommentUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutProfileDataInput {
  name: String
  email: String
  password: String
  role: Role
  posts: PostUpdateManyWithoutAuthorInput
  postLikes: PostUpdateManyWithoutLikedByInput
  projects: ProjectUpdateManyWithoutAuthorInput
  comments: CommentUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutProjectsDataInput {
  name: String
  email: String
  password: String
  role: Role
  profile: ProfileUpdateOneWithoutUserInput
  posts: PostUpdateManyWithoutAuthorInput
  postLikes: PostUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
}

input UserUpdateWithWhereUniqueWithoutPostLikesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutPostLikesDataInput!
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput!
  create: UserCreateWithoutCommentsInput!
}

input UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput!
  create: UserCreateWithoutPostsInput!
}

input UserUpsertWithoutProfileInput {
  update: UserUpdateWithoutProfileDataInput!
  create: UserCreateWithoutProfileInput!
}

input UserUpsertWithoutProjectsInput {
  update: UserUpdateWithoutProjectsDataInput!
  create: UserCreateWithoutProjectsInput!
}

input UserUpsertWithWhereUniqueWithoutPostLikesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutPostLikesDataInput!
  create: UserCreateWithoutPostLikesInput!
}

input UserWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  profile: ProfileWhereInput
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  postLikes_every: PostWhereInput
  postLikes_some: PostWhereInput
  postLikes_none: PostWhereInput
  projects_every: ProjectWhereInput
  projects_some: ProjectWhereInput
  projects_none: ProjectWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: UUID
  email: String
}

scalar UUID
