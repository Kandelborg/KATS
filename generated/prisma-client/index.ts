// Code generated by Prisma (prisma@1.30.0-beta.6). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  avatar: (where?: AvatarWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  postContent: (where?: PostContentWhereInput) => Promise<boolean>;
  postLng: (where?: PostLngWhereInput) => Promise<boolean>;
  postTag: (where?: PostTagWhereInput) => Promise<boolean>;
  postTagContent: (where?: PostTagContentWhereInput) => Promise<boolean>;
  postTagLng: (where?: PostTagLngWhereInput) => Promise<boolean>;
  profile: (where?: ProfileWhereInput) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  projectAlbum: (where?: ProjectAlbumWhereInput) => Promise<boolean>;
  projectCategory: (where?: ProjectCategoryWhereInput) => Promise<boolean>;
  projectCategoryContent: (
    where?: ProjectCategoryContentWhereInput
  ) => Promise<boolean>;
  projectCategoryLng: (
    where?: ProjectCategoryLngWhereInput
  ) => Promise<boolean>;
  projectContent: (where?: ProjectContentWhereInput) => Promise<boolean>;
  projectImage: (where?: ProjectImageWhereInput) => Promise<boolean>;
  projectImageContent: (
    where?: ProjectImageContentWhereInput
  ) => Promise<boolean>;
  projectImageLng: (where?: ProjectImageLngWhereInput) => Promise<boolean>;
  projectLng: (where?: ProjectLngWhereInput) => Promise<boolean>;
  projectTag: (where?: ProjectTagWhereInput) => Promise<boolean>;
  projectTagContent: (where?: ProjectTagContentWhereInput) => Promise<boolean>;
  projectTagLng: (where?: ProjectTagLngWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  avatar: (where: AvatarWhereUniqueInput) => AvatarPromise;
  avatars: (
    args?: {
      where?: AvatarWhereInput;
      orderBy?: AvatarOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Avatar>;
  avatarsConnection: (
    args?: {
      where?: AvatarWhereInput;
      orderBy?: AvatarOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AvatarConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Comment>;
  commentsConnection: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  postContent: (where: PostContentWhereUniqueInput) => PostContentPromise;
  postContents: (
    args?: {
      where?: PostContentWhereInput;
      orderBy?: PostContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PostContent>;
  postContentsConnection: (
    args?: {
      where?: PostContentWhereInput;
      orderBy?: PostContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostContentConnectionPromise;
  postLng: (where: PostLngWhereUniqueInput) => PostLngPromise;
  postLngs: (
    args?: {
      where?: PostLngWhereInput;
      orderBy?: PostLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PostLng>;
  postLngsConnection: (
    args?: {
      where?: PostLngWhereInput;
      orderBy?: PostLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostLngConnectionPromise;
  postTag: (where: PostTagWhereUniqueInput) => PostTagPromise;
  postTags: (
    args?: {
      where?: PostTagWhereInput;
      orderBy?: PostTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PostTag>;
  postTagsConnection: (
    args?: {
      where?: PostTagWhereInput;
      orderBy?: PostTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostTagConnectionPromise;
  postTagContent: (
    where: PostTagContentWhereUniqueInput
  ) => PostTagContentPromise;
  postTagContents: (
    args?: {
      where?: PostTagContentWhereInput;
      orderBy?: PostTagContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PostTagContent>;
  postTagContentsConnection: (
    args?: {
      where?: PostTagContentWhereInput;
      orderBy?: PostTagContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostTagContentConnectionPromise;
  postTagLng: (where: PostTagLngWhereUniqueInput) => PostTagLngPromise;
  postTagLngs: (
    args?: {
      where?: PostTagLngWhereInput;
      orderBy?: PostTagLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PostTagLng>;
  postTagLngsConnection: (
    args?: {
      where?: PostTagLngWhereInput;
      orderBy?: PostTagLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostTagLngConnectionPromise;
  profile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  profiles: (
    args?: {
      where?: ProfileWhereInput;
      orderBy?: ProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Profile>;
  profilesConnection: (
    args?: {
      where?: ProfileWhereInput;
      orderBy?: ProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProfileConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectPromise;
  projects: (
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Project>;
  projectsConnection: (
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectConnectionPromise;
  projectAlbum: (where: ProjectAlbumWhereUniqueInput) => ProjectAlbumPromise;
  projectAlbums: (
    args?: {
      where?: ProjectAlbumWhereInput;
      orderBy?: ProjectAlbumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectAlbum>;
  projectAlbumsConnection: (
    args?: {
      where?: ProjectAlbumWhereInput;
      orderBy?: ProjectAlbumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectAlbumConnectionPromise;
  projectCategory: (
    where: ProjectCategoryWhereUniqueInput
  ) => ProjectCategoryPromise;
  projectCategories: (
    args?: {
      where?: ProjectCategoryWhereInput;
      orderBy?: ProjectCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectCategory>;
  projectCategoriesConnection: (
    args?: {
      where?: ProjectCategoryWhereInput;
      orderBy?: ProjectCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectCategoryConnectionPromise;
  projectCategoryContent: (
    where: ProjectCategoryContentWhereUniqueInput
  ) => ProjectCategoryContentPromise;
  projectCategoryContents: (
    args?: {
      where?: ProjectCategoryContentWhereInput;
      orderBy?: ProjectCategoryContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectCategoryContent>;
  projectCategoryContentsConnection: (
    args?: {
      where?: ProjectCategoryContentWhereInput;
      orderBy?: ProjectCategoryContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectCategoryContentConnectionPromise;
  projectCategoryLng: (
    where: ProjectCategoryLngWhereUniqueInput
  ) => ProjectCategoryLngPromise;
  projectCategoryLngs: (
    args?: {
      where?: ProjectCategoryLngWhereInput;
      orderBy?: ProjectCategoryLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectCategoryLng>;
  projectCategoryLngsConnection: (
    args?: {
      where?: ProjectCategoryLngWhereInput;
      orderBy?: ProjectCategoryLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectCategoryLngConnectionPromise;
  projectContent: (
    where: ProjectContentWhereUniqueInput
  ) => ProjectContentPromise;
  projectContents: (
    args?: {
      where?: ProjectContentWhereInput;
      orderBy?: ProjectContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectContent>;
  projectContentsConnection: (
    args?: {
      where?: ProjectContentWhereInput;
      orderBy?: ProjectContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectContentConnectionPromise;
  projectImage: (where: ProjectImageWhereUniqueInput) => ProjectImagePromise;
  projectImages: (
    args?: {
      where?: ProjectImageWhereInput;
      orderBy?: ProjectImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectImage>;
  projectImagesConnection: (
    args?: {
      where?: ProjectImageWhereInput;
      orderBy?: ProjectImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectImageConnectionPromise;
  projectImageContent: (
    where: ProjectImageContentWhereUniqueInput
  ) => ProjectImageContentPromise;
  projectImageContents: (
    args?: {
      where?: ProjectImageContentWhereInput;
      orderBy?: ProjectImageContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectImageContent>;
  projectImageContentsConnection: (
    args?: {
      where?: ProjectImageContentWhereInput;
      orderBy?: ProjectImageContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectImageContentConnectionPromise;
  projectImageLng: (
    where: ProjectImageLngWhereUniqueInput
  ) => ProjectImageLngPromise;
  projectImageLngs: (
    args?: {
      where?: ProjectImageLngWhereInput;
      orderBy?: ProjectImageLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectImageLng>;
  projectImageLngsConnection: (
    args?: {
      where?: ProjectImageLngWhereInput;
      orderBy?: ProjectImageLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectImageLngConnectionPromise;
  projectLng: (where: ProjectLngWhereUniqueInput) => ProjectLngPromise;
  projectLngs: (
    args?: {
      where?: ProjectLngWhereInput;
      orderBy?: ProjectLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectLng>;
  projectLngsConnection: (
    args?: {
      where?: ProjectLngWhereInput;
      orderBy?: ProjectLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectLngConnectionPromise;
  projectTag: (where: ProjectTagWhereUniqueInput) => ProjectTagPromise;
  projectTags: (
    args?: {
      where?: ProjectTagWhereInput;
      orderBy?: ProjectTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectTag>;
  projectTagsConnection: (
    args?: {
      where?: ProjectTagWhereInput;
      orderBy?: ProjectTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectTagConnectionPromise;
  projectTagContent: (
    where: ProjectTagContentWhereUniqueInput
  ) => ProjectTagContentPromise;
  projectTagContents: (
    args?: {
      where?: ProjectTagContentWhereInput;
      orderBy?: ProjectTagContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectTagContent>;
  projectTagContentsConnection: (
    args?: {
      where?: ProjectTagContentWhereInput;
      orderBy?: ProjectTagContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectTagContentConnectionPromise;
  projectTagLng: (where: ProjectTagLngWhereUniqueInput) => ProjectTagLngPromise;
  projectTagLngs: (
    args?: {
      where?: ProjectTagLngWhereInput;
      orderBy?: ProjectTagLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProjectTagLng>;
  projectTagLngsConnection: (
    args?: {
      where?: ProjectTagLngWhereInput;
      orderBy?: ProjectTagLngOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectTagLngConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAvatar: (data: AvatarCreateInput) => AvatarPromise;
  updateAvatar: (
    args: { data: AvatarUpdateInput; where: AvatarWhereUniqueInput }
  ) => AvatarPromise;
  updateManyAvatars: (
    args: { data: AvatarUpdateManyMutationInput; where?: AvatarWhereInput }
  ) => BatchPayloadPromise;
  upsertAvatar: (
    args: {
      where: AvatarWhereUniqueInput;
      create: AvatarCreateInput;
      update: AvatarUpdateInput;
    }
  ) => AvatarPromise;
  deleteAvatar: (where: AvatarWhereUniqueInput) => AvatarPromise;
  deleteManyAvatars: (where?: AvatarWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (
    args: { data: CommentUpdateInput; where: CommentWhereUniqueInput }
  ) => CommentPromise;
  upsertComment: (
    args: {
      where: CommentWhereUniqueInput;
      create: CommentCreateInput;
      update: CommentUpdateInput;
    }
  ) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createPostContent: (data: PostContentCreateInput) => PostContentPromise;
  updatePostContent: (
    args: { data: PostContentUpdateInput; where: PostContentWhereUniqueInput }
  ) => PostContentPromise;
  updateManyPostContents: (
    args: {
      data: PostContentUpdateManyMutationInput;
      where?: PostContentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPostContent: (
    args: {
      where: PostContentWhereUniqueInput;
      create: PostContentCreateInput;
      update: PostContentUpdateInput;
    }
  ) => PostContentPromise;
  deletePostContent: (where: PostContentWhereUniqueInput) => PostContentPromise;
  deleteManyPostContents: (
    where?: PostContentWhereInput
  ) => BatchPayloadPromise;
  createPostLng: (data: PostLngCreateInput) => PostLngPromise;
  updatePostLng: (
    args: { data: PostLngUpdateInput; where: PostLngWhereUniqueInput }
  ) => PostLngPromise;
  updateManyPostLngs: (
    args: { data: PostLngUpdateManyMutationInput; where?: PostLngWhereInput }
  ) => BatchPayloadPromise;
  upsertPostLng: (
    args: {
      where: PostLngWhereUniqueInput;
      create: PostLngCreateInput;
      update: PostLngUpdateInput;
    }
  ) => PostLngPromise;
  deletePostLng: (where: PostLngWhereUniqueInput) => PostLngPromise;
  deleteManyPostLngs: (where?: PostLngWhereInput) => BatchPayloadPromise;
  createPostTag: (data: PostTagCreateInput) => PostTagPromise;
  updatePostTag: (
    args: { data: PostTagUpdateInput; where: PostTagWhereUniqueInput }
  ) => PostTagPromise;
  updateManyPostTags: (
    args: { data: PostTagUpdateManyMutationInput; where?: PostTagWhereInput }
  ) => BatchPayloadPromise;
  upsertPostTag: (
    args: {
      where: PostTagWhereUniqueInput;
      create: PostTagCreateInput;
      update: PostTagUpdateInput;
    }
  ) => PostTagPromise;
  deletePostTag: (where: PostTagWhereUniqueInput) => PostTagPromise;
  deleteManyPostTags: (where?: PostTagWhereInput) => BatchPayloadPromise;
  createPostTagContent: (
    data: PostTagContentCreateInput
  ) => PostTagContentPromise;
  updatePostTagContent: (
    args: {
      data: PostTagContentUpdateInput;
      where: PostTagContentWhereUniqueInput;
    }
  ) => PostTagContentPromise;
  updateManyPostTagContents: (
    args: {
      data: PostTagContentUpdateManyMutationInput;
      where?: PostTagContentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPostTagContent: (
    args: {
      where: PostTagContentWhereUniqueInput;
      create: PostTagContentCreateInput;
      update: PostTagContentUpdateInput;
    }
  ) => PostTagContentPromise;
  deletePostTagContent: (
    where: PostTagContentWhereUniqueInput
  ) => PostTagContentPromise;
  deleteManyPostTagContents: (
    where?: PostTagContentWhereInput
  ) => BatchPayloadPromise;
  createPostTagLng: (data: PostTagLngCreateInput) => PostTagLngPromise;
  updatePostTagLng: (
    args: { data: PostTagLngUpdateInput; where: PostTagLngWhereUniqueInput }
  ) => PostTagLngPromise;
  updateManyPostTagLngs: (
    args: {
      data: PostTagLngUpdateManyMutationInput;
      where?: PostTagLngWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPostTagLng: (
    args: {
      where: PostTagLngWhereUniqueInput;
      create: PostTagLngCreateInput;
      update: PostTagLngUpdateInput;
    }
  ) => PostTagLngPromise;
  deletePostTagLng: (where: PostTagLngWhereUniqueInput) => PostTagLngPromise;
  deleteManyPostTagLngs: (where?: PostTagLngWhereInput) => BatchPayloadPromise;
  createProfile: (data: ProfileCreateInput) => ProfilePromise;
  updateProfile: (
    args: { data: ProfileUpdateInput; where: ProfileWhereUniqueInput }
  ) => ProfilePromise;
  updateManyProfiles: (
    args: { data: ProfileUpdateManyMutationInput; where?: ProfileWhereInput }
  ) => BatchPayloadPromise;
  upsertProfile: (
    args: {
      where: ProfileWhereUniqueInput;
      create: ProfileCreateInput;
      update: ProfileUpdateInput;
    }
  ) => ProfilePromise;
  deleteProfile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  deleteManyProfiles: (where?: ProfileWhereInput) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (
    args: { data: ProjectUpdateInput; where: ProjectWhereUniqueInput }
  ) => ProjectPromise;
  updateManyProjects: (
    args: { data: ProjectUpdateManyMutationInput; where?: ProjectWhereInput }
  ) => BatchPayloadPromise;
  upsertProject: (
    args: {
      where: ProjectWhereUniqueInput;
      create: ProjectCreateInput;
      update: ProjectUpdateInput;
    }
  ) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createProjectAlbum: (data: ProjectAlbumCreateInput) => ProjectAlbumPromise;
  updateProjectAlbum: (
    args: { data: ProjectAlbumUpdateInput; where: ProjectAlbumWhereUniqueInput }
  ) => ProjectAlbumPromise;
  upsertProjectAlbum: (
    args: {
      where: ProjectAlbumWhereUniqueInput;
      create: ProjectAlbumCreateInput;
      update: ProjectAlbumUpdateInput;
    }
  ) => ProjectAlbumPromise;
  deleteProjectAlbum: (
    where: ProjectAlbumWhereUniqueInput
  ) => ProjectAlbumPromise;
  deleteManyProjectAlbums: (
    where?: ProjectAlbumWhereInput
  ) => BatchPayloadPromise;
  createProjectCategory: (
    data: ProjectCategoryCreateInput
  ) => ProjectCategoryPromise;
  updateProjectCategory: (
    args: {
      data: ProjectCategoryUpdateInput;
      where: ProjectCategoryWhereUniqueInput;
    }
  ) => ProjectCategoryPromise;
  updateManyProjectCategories: (
    args: {
      data: ProjectCategoryUpdateManyMutationInput;
      where?: ProjectCategoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectCategory: (
    args: {
      where: ProjectCategoryWhereUniqueInput;
      create: ProjectCategoryCreateInput;
      update: ProjectCategoryUpdateInput;
    }
  ) => ProjectCategoryPromise;
  deleteProjectCategory: (
    where: ProjectCategoryWhereUniqueInput
  ) => ProjectCategoryPromise;
  deleteManyProjectCategories: (
    where?: ProjectCategoryWhereInput
  ) => BatchPayloadPromise;
  createProjectCategoryContent: (
    data: ProjectCategoryContentCreateInput
  ) => ProjectCategoryContentPromise;
  updateProjectCategoryContent: (
    args: {
      data: ProjectCategoryContentUpdateInput;
      where: ProjectCategoryContentWhereUniqueInput;
    }
  ) => ProjectCategoryContentPromise;
  updateManyProjectCategoryContents: (
    args: {
      data: ProjectCategoryContentUpdateManyMutationInput;
      where?: ProjectCategoryContentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectCategoryContent: (
    args: {
      where: ProjectCategoryContentWhereUniqueInput;
      create: ProjectCategoryContentCreateInput;
      update: ProjectCategoryContentUpdateInput;
    }
  ) => ProjectCategoryContentPromise;
  deleteProjectCategoryContent: (
    where: ProjectCategoryContentWhereUniqueInput
  ) => ProjectCategoryContentPromise;
  deleteManyProjectCategoryContents: (
    where?: ProjectCategoryContentWhereInput
  ) => BatchPayloadPromise;
  createProjectCategoryLng: (
    data: ProjectCategoryLngCreateInput
  ) => ProjectCategoryLngPromise;
  updateProjectCategoryLng: (
    args: {
      data: ProjectCategoryLngUpdateInput;
      where: ProjectCategoryLngWhereUniqueInput;
    }
  ) => ProjectCategoryLngPromise;
  updateManyProjectCategoryLngs: (
    args: {
      data: ProjectCategoryLngUpdateManyMutationInput;
      where?: ProjectCategoryLngWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectCategoryLng: (
    args: {
      where: ProjectCategoryLngWhereUniqueInput;
      create: ProjectCategoryLngCreateInput;
      update: ProjectCategoryLngUpdateInput;
    }
  ) => ProjectCategoryLngPromise;
  deleteProjectCategoryLng: (
    where: ProjectCategoryLngWhereUniqueInput
  ) => ProjectCategoryLngPromise;
  deleteManyProjectCategoryLngs: (
    where?: ProjectCategoryLngWhereInput
  ) => BatchPayloadPromise;
  createProjectContent: (
    data: ProjectContentCreateInput
  ) => ProjectContentPromise;
  updateProjectContent: (
    args: {
      data: ProjectContentUpdateInput;
      where: ProjectContentWhereUniqueInput;
    }
  ) => ProjectContentPromise;
  updateManyProjectContents: (
    args: {
      data: ProjectContentUpdateManyMutationInput;
      where?: ProjectContentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectContent: (
    args: {
      where: ProjectContentWhereUniqueInput;
      create: ProjectContentCreateInput;
      update: ProjectContentUpdateInput;
    }
  ) => ProjectContentPromise;
  deleteProjectContent: (
    where: ProjectContentWhereUniqueInput
  ) => ProjectContentPromise;
  deleteManyProjectContents: (
    where?: ProjectContentWhereInput
  ) => BatchPayloadPromise;
  createProjectImage: (data: ProjectImageCreateInput) => ProjectImagePromise;
  updateProjectImage: (
    args: { data: ProjectImageUpdateInput; where: ProjectImageWhereUniqueInput }
  ) => ProjectImagePromise;
  updateManyProjectImages: (
    args: {
      data: ProjectImageUpdateManyMutationInput;
      where?: ProjectImageWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectImage: (
    args: {
      where: ProjectImageWhereUniqueInput;
      create: ProjectImageCreateInput;
      update: ProjectImageUpdateInput;
    }
  ) => ProjectImagePromise;
  deleteProjectImage: (
    where: ProjectImageWhereUniqueInput
  ) => ProjectImagePromise;
  deleteManyProjectImages: (
    where?: ProjectImageWhereInput
  ) => BatchPayloadPromise;
  createProjectImageContent: (
    data: ProjectImageContentCreateInput
  ) => ProjectImageContentPromise;
  updateProjectImageContent: (
    args: {
      data: ProjectImageContentUpdateInput;
      where: ProjectImageContentWhereUniqueInput;
    }
  ) => ProjectImageContentPromise;
  updateManyProjectImageContents: (
    args: {
      data: ProjectImageContentUpdateManyMutationInput;
      where?: ProjectImageContentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectImageContent: (
    args: {
      where: ProjectImageContentWhereUniqueInput;
      create: ProjectImageContentCreateInput;
      update: ProjectImageContentUpdateInput;
    }
  ) => ProjectImageContentPromise;
  deleteProjectImageContent: (
    where: ProjectImageContentWhereUniqueInput
  ) => ProjectImageContentPromise;
  deleteManyProjectImageContents: (
    where?: ProjectImageContentWhereInput
  ) => BatchPayloadPromise;
  createProjectImageLng: (
    data: ProjectImageLngCreateInput
  ) => ProjectImageLngPromise;
  updateProjectImageLng: (
    args: {
      data: ProjectImageLngUpdateInput;
      where: ProjectImageLngWhereUniqueInput;
    }
  ) => ProjectImageLngPromise;
  updateManyProjectImageLngs: (
    args: {
      data: ProjectImageLngUpdateManyMutationInput;
      where?: ProjectImageLngWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectImageLng: (
    args: {
      where: ProjectImageLngWhereUniqueInput;
      create: ProjectImageLngCreateInput;
      update: ProjectImageLngUpdateInput;
    }
  ) => ProjectImageLngPromise;
  deleteProjectImageLng: (
    where: ProjectImageLngWhereUniqueInput
  ) => ProjectImageLngPromise;
  deleteManyProjectImageLngs: (
    where?: ProjectImageLngWhereInput
  ) => BatchPayloadPromise;
  createProjectLng: (data: ProjectLngCreateInput) => ProjectLngPromise;
  updateProjectLng: (
    args: { data: ProjectLngUpdateInput; where: ProjectLngWhereUniqueInput }
  ) => ProjectLngPromise;
  updateManyProjectLngs: (
    args: {
      data: ProjectLngUpdateManyMutationInput;
      where?: ProjectLngWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectLng: (
    args: {
      where: ProjectLngWhereUniqueInput;
      create: ProjectLngCreateInput;
      update: ProjectLngUpdateInput;
    }
  ) => ProjectLngPromise;
  deleteProjectLng: (where: ProjectLngWhereUniqueInput) => ProjectLngPromise;
  deleteManyProjectLngs: (where?: ProjectLngWhereInput) => BatchPayloadPromise;
  createProjectTag: (data: ProjectTagCreateInput) => ProjectTagPromise;
  updateProjectTag: (
    args: { data: ProjectTagUpdateInput; where: ProjectTagWhereUniqueInput }
  ) => ProjectTagPromise;
  updateManyProjectTags: (
    args: {
      data: ProjectTagUpdateManyMutationInput;
      where?: ProjectTagWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectTag: (
    args: {
      where: ProjectTagWhereUniqueInput;
      create: ProjectTagCreateInput;
      update: ProjectTagUpdateInput;
    }
  ) => ProjectTagPromise;
  deleteProjectTag: (where: ProjectTagWhereUniqueInput) => ProjectTagPromise;
  deleteManyProjectTags: (where?: ProjectTagWhereInput) => BatchPayloadPromise;
  createProjectTagContent: (
    data: ProjectTagContentCreateInput
  ) => ProjectTagContentPromise;
  updateProjectTagContent: (
    args: {
      data: ProjectTagContentUpdateInput;
      where: ProjectTagContentWhereUniqueInput;
    }
  ) => ProjectTagContentPromise;
  updateManyProjectTagContents: (
    args: {
      data: ProjectTagContentUpdateManyMutationInput;
      where?: ProjectTagContentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectTagContent: (
    args: {
      where: ProjectTagContentWhereUniqueInput;
      create: ProjectTagContentCreateInput;
      update: ProjectTagContentUpdateInput;
    }
  ) => ProjectTagContentPromise;
  deleteProjectTagContent: (
    where: ProjectTagContentWhereUniqueInput
  ) => ProjectTagContentPromise;
  deleteManyProjectTagContents: (
    where?: ProjectTagContentWhereInput
  ) => BatchPayloadPromise;
  createProjectTagLng: (data: ProjectTagLngCreateInput) => ProjectTagLngPromise;
  updateProjectTagLng: (
    args: {
      data: ProjectTagLngUpdateInput;
      where: ProjectTagLngWhereUniqueInput;
    }
  ) => ProjectTagLngPromise;
  updateManyProjectTagLngs: (
    args: {
      data: ProjectTagLngUpdateManyMutationInput;
      where?: ProjectTagLngWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProjectTagLng: (
    args: {
      where: ProjectTagLngWhereUniqueInput;
      create: ProjectTagLngCreateInput;
      update: ProjectTagLngUpdateInput;
    }
  ) => ProjectTagLngPromise;
  deleteProjectTagLng: (
    where: ProjectTagLngWhereUniqueInput
  ) => ProjectTagLngPromise;
  deleteManyProjectTagLngs: (
    where?: ProjectTagLngWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  avatar: (
    where?: AvatarSubscriptionWhereInput
  ) => AvatarSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  postContent: (
    where?: PostContentSubscriptionWhereInput
  ) => PostContentSubscriptionPayloadSubscription;
  postLng: (
    where?: PostLngSubscriptionWhereInput
  ) => PostLngSubscriptionPayloadSubscription;
  postTag: (
    where?: PostTagSubscriptionWhereInput
  ) => PostTagSubscriptionPayloadSubscription;
  postTagContent: (
    where?: PostTagContentSubscriptionWhereInput
  ) => PostTagContentSubscriptionPayloadSubscription;
  postTagLng: (
    where?: PostTagLngSubscriptionWhereInput
  ) => PostTagLngSubscriptionPayloadSubscription;
  profile: (
    where?: ProfileSubscriptionWhereInput
  ) => ProfileSubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  projectAlbum: (
    where?: ProjectAlbumSubscriptionWhereInput
  ) => ProjectAlbumSubscriptionPayloadSubscription;
  projectCategory: (
    where?: ProjectCategorySubscriptionWhereInput
  ) => ProjectCategorySubscriptionPayloadSubscription;
  projectCategoryContent: (
    where?: ProjectCategoryContentSubscriptionWhereInput
  ) => ProjectCategoryContentSubscriptionPayloadSubscription;
  projectCategoryLng: (
    where?: ProjectCategoryLngSubscriptionWhereInput
  ) => ProjectCategoryLngSubscriptionPayloadSubscription;
  projectContent: (
    where?: ProjectContentSubscriptionWhereInput
  ) => ProjectContentSubscriptionPayloadSubscription;
  projectImage: (
    where?: ProjectImageSubscriptionWhereInput
  ) => ProjectImageSubscriptionPayloadSubscription;
  projectImageContent: (
    where?: ProjectImageContentSubscriptionWhereInput
  ) => ProjectImageContentSubscriptionPayloadSubscription;
  projectImageLng: (
    where?: ProjectImageLngSubscriptionWhereInput
  ) => ProjectImageLngSubscriptionPayloadSubscription;
  projectLng: (
    where?: ProjectLngSubscriptionWhereInput
  ) => ProjectLngSubscriptionPayloadSubscription;
  projectTag: (
    where?: ProjectTagSubscriptionWhereInput
  ) => ProjectTagSubscriptionPayloadSubscription;
  projectTagContent: (
    where?: ProjectTagContentSubscriptionWhereInput
  ) => ProjectTagContentSubscriptionPayloadSubscription;
  projectTagLng: (
    where?: ProjectTagLngSubscriptionWhereInput
  ) => ProjectTagLngSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PostLngOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "locale_ASC"
  | "locale_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "imageSrc_ASC"
  | "imageSrc_DESC"
  | "likes_ASC"
  | "likes_DESC";

export type ProjectTagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "color_ASC"
  | "color_DESC";

export type ProjectTagLngOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "locale_ASC"
  | "locale_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Role = "ADMIN" | "SITEMANAGER" | "USER";

export type ProjectLngOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "locale_ASC"
  | "locale_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProjectContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "text_ASC"
  | "text_DESC"
  | "metaTitle_ASC"
  | "metaTitle_DESC"
  | "metaDescription_ASC"
  | "metaDescription_DESC"
  | "isActive_ASC"
  | "isActive_DESC";

export type ProjectImageLngOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "locale_ASC"
  | "locale_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProjectImageContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "alt_ASC"
  | "alt_DESC";

export type ProjectCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "image_ASC"
  | "image_DESC";

export type ProjectImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "publicId_ASC"
  | "publicId_DESC"
  | "src_ASC"
  | "src_DESC";

export type ProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "bio_ASC"
  | "bio_DESC";

export type ProjectCategoryContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "text_ASC"
  | "text_DESC"
  | "imageAlt_ASC"
  | "imageAlt_DESC"
  | "metaTitle_ASC"
  | "metaTitle_DESC"
  | "metaDescription_ASC"
  | "metaDescription_DESC";

export type PostTagContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC";

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "slug_ASC"
  | "slug_DESC";

export type ProjectTagContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC";

export type PostContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "text_ASC"
  | "text_DESC"
  | "metaTitle_ASC"
  | "metaTitle_DESC"
  | "metaDescription_ASC"
  | "metaDescription_DESC"
  | "imageAlt_ASC"
  | "imageAlt_DESC";

export type PostTagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "color_ASC"
  | "color_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC";

export type AvatarOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "publicId_ASC"
  | "publicId_DESC"
  | "src_ASC"
  | "src_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PostTagLngOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "locale_ASC"
  | "locale_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProjectAlbumOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProjectCategoryLngOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "locale_ASC"
  | "locale_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface ProjectAlbumUpdateOneRequiredWithoutProjectInput {
  create?: ProjectAlbumCreateWithoutProjectInput;
  update?: ProjectAlbumUpdateWithoutProjectDataInput;
  upsert?: ProjectAlbumUpsertWithoutProjectInput;
  connect?: ProjectAlbumWhereUniqueInput;
}

export type AvatarWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ProjectImageUpdateManyDataInput {
  publicId?: String;
  src?: String;
}

export interface ProjectImageContentWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  image?: ProjectImageWhereInput;
  language?: ProjectImageLngWhereInput;
  alt?: String;
  alt_not?: String;
  alt_in?: String[] | String;
  alt_not_in?: String[] | String;
  alt_lt?: String;
  alt_lte?: String;
  alt_gt?: String;
  alt_gte?: String;
  alt_contains?: String;
  alt_not_contains?: String;
  alt_starts_with?: String;
  alt_not_starts_with?: String;
  alt_ends_with?: String;
  alt_not_ends_with?: String;
  AND?: ProjectImageContentWhereInput[] | ProjectImageContentWhereInput;
  OR?: ProjectImageContentWhereInput[] | ProjectImageContentWhereInput;
  NOT?: ProjectImageContentWhereInput[] | ProjectImageContentWhereInput;
}

export interface ProjectAlbumUpsertWithoutProjectInput {
  update: ProjectAlbumUpdateWithoutProjectDataInput;
  create: ProjectAlbumCreateWithoutProjectInput;
}

export interface ProjectContentWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  project?: ProjectWhereInput;
  language?: ProjectLngWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  metaTitle?: String;
  metaTitle_not?: String;
  metaTitle_in?: String[] | String;
  metaTitle_not_in?: String[] | String;
  metaTitle_lt?: String;
  metaTitle_lte?: String;
  metaTitle_gt?: String;
  metaTitle_gte?: String;
  metaTitle_contains?: String;
  metaTitle_not_contains?: String;
  metaTitle_starts_with?: String;
  metaTitle_not_starts_with?: String;
  metaTitle_ends_with?: String;
  metaTitle_not_ends_with?: String;
  metaDescription?: String;
  metaDescription_not?: String;
  metaDescription_in?: String[] | String;
  metaDescription_not_in?: String[] | String;
  metaDescription_lt?: String;
  metaDescription_lte?: String;
  metaDescription_gt?: String;
  metaDescription_gte?: String;
  metaDescription_contains?: String;
  metaDescription_not_contains?: String;
  metaDescription_starts_with?: String;
  metaDescription_not_starts_with?: String;
  metaDescription_ends_with?: String;
  metaDescription_not_ends_with?: String;
  isActive?: Boolean;
  isActive_not?: Boolean;
  AND?: ProjectContentWhereInput[] | ProjectContentWhereInput;
  OR?: ProjectContentWhereInput[] | ProjectContentWhereInput;
  NOT?: ProjectContentWhereInput[] | ProjectContentWhereInput;
}

export interface ProjectContentUpdateManyWithoutProjectInput {
  create?:
    | ProjectContentCreateWithoutProjectInput[]
    | ProjectContentCreateWithoutProjectInput;
  delete?: ProjectContentWhereUniqueInput[] | ProjectContentWhereUniqueInput;
  connect?: ProjectContentWhereUniqueInput[] | ProjectContentWhereUniqueInput;
  set?: ProjectContentWhereUniqueInput[] | ProjectContentWhereUniqueInput;
  disconnect?:
    | ProjectContentWhereUniqueInput[]
    | ProjectContentWhereUniqueInput;
  update?:
    | ProjectContentUpdateWithWhereUniqueWithoutProjectInput[]
    | ProjectContentUpdateWithWhereUniqueWithoutProjectInput;
  upsert?:
    | ProjectContentUpsertWithWhereUniqueWithoutProjectInput[]
    | ProjectContentUpsertWithWhereUniqueWithoutProjectInput;
  deleteMany?:
    | ProjectContentScalarWhereInput[]
    | ProjectContentScalarWhereInput;
  updateMany?:
    | ProjectContentUpdateManyWithWhereNestedInput[]
    | ProjectContentUpdateManyWithWhereNestedInput;
}

export interface ProjectTagWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  language?: ProjectTagLngWhereInput;
  contents?: ProjectTagContentWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  color?: String;
  color_not?: String;
  color_in?: String[] | String;
  color_not_in?: String[] | String;
  color_lt?: String;
  color_lte?: String;
  color_gt?: String;
  color_gte?: String;
  color_contains?: String;
  color_not_contains?: String;
  color_starts_with?: String;
  color_not_starts_with?: String;
  color_ends_with?: String;
  color_not_ends_with?: String;
  AND?: ProjectTagWhereInput[] | ProjectTagWhereInput;
  OR?: ProjectTagWhereInput[] | ProjectTagWhereInput;
  NOT?: ProjectTagWhereInput[] | ProjectTagWhereInput;
}

export interface ProjectContentUpdateWithWhereUniqueWithoutProjectInput {
  where: ProjectContentWhereUniqueInput;
  data: ProjectContentUpdateWithoutProjectDataInput;
}

export interface ProjectTagContentWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  tag?: ProjectTagWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: ProjectTagContentWhereInput[] | ProjectTagContentWhereInput;
  OR?: ProjectTagContentWhereInput[] | ProjectTagContentWhereInput;
  NOT?: ProjectTagContentWhereInput[] | ProjectTagContentWhereInput;
}

export interface ProjectContentUpdateWithoutProjectDataInput {
  language?: ProjectLngUpdateOneRequiredWithoutProjectsInput;
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive?: Boolean;
}

export interface PostContentWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  language?: PostLngWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  metaTitle?: String;
  metaTitle_not?: String;
  metaTitle_in?: String[] | String;
  metaTitle_not_in?: String[] | String;
  metaTitle_lt?: String;
  metaTitle_lte?: String;
  metaTitle_gt?: String;
  metaTitle_gte?: String;
  metaTitle_contains?: String;
  metaTitle_not_contains?: String;
  metaTitle_starts_with?: String;
  metaTitle_not_starts_with?: String;
  metaTitle_ends_with?: String;
  metaTitle_not_ends_with?: String;
  metaDescription?: String;
  metaDescription_not?: String;
  metaDescription_in?: String[] | String;
  metaDescription_not_in?: String[] | String;
  metaDescription_lt?: String;
  metaDescription_lte?: String;
  metaDescription_gt?: String;
  metaDescription_gte?: String;
  metaDescription_contains?: String;
  metaDescription_not_contains?: String;
  metaDescription_starts_with?: String;
  metaDescription_not_starts_with?: String;
  metaDescription_ends_with?: String;
  metaDescription_not_ends_with?: String;
  imageAlt?: String;
  imageAlt_not?: String;
  imageAlt_in?: String[] | String;
  imageAlt_not_in?: String[] | String;
  imageAlt_lt?: String;
  imageAlt_lte?: String;
  imageAlt_gt?: String;
  imageAlt_gte?: String;
  imageAlt_contains?: String;
  imageAlt_not_contains?: String;
  imageAlt_starts_with?: String;
  imageAlt_not_starts_with?: String;
  imageAlt_ends_with?: String;
  imageAlt_not_ends_with?: String;
  post?: PostWhereInput;
  AND?: PostContentWhereInput[] | PostContentWhereInput;
  OR?: PostContentWhereInput[] | PostContentWhereInput;
  NOT?: PostContentWhereInput[] | PostContentWhereInput;
}

export interface ProjectLngUpdateOneRequiredWithoutProjectsInput {
  create?: ProjectLngCreateWithoutProjectsInput;
  update?: ProjectLngUpdateWithoutProjectsDataInput;
  upsert?: ProjectLngUpsertWithoutProjectsInput;
  connect?: ProjectLngWhereUniqueInput;
}

export interface PostTagWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  color?: String;
  color_not?: String;
  color_in?: String[] | String;
  color_not_in?: String[] | String;
  color_lt?: String;
  color_lte?: String;
  color_gt?: String;
  color_gte?: String;
  color_contains?: String;
  color_not_contains?: String;
  color_starts_with?: String;
  color_not_starts_with?: String;
  color_ends_with?: String;
  color_not_ends_with?: String;
  language?: PostTagLngWhereInput;
  contents?: PostTagContentWhereInput;
  AND?: PostTagWhereInput[] | PostTagWhereInput;
  OR?: PostTagWhereInput[] | PostTagWhereInput;
  NOT?: PostTagWhereInput[] | PostTagWhereInput;
}

export interface ProjectLngUpdateWithoutProjectsDataInput {
  country?: String;
  locale?: String;
}

export interface PostTagContentWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  tag?: PostTagWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: PostTagContentWhereInput[] | PostTagContentWhereInput;
  OR?: PostTagContentWhereInput[] | PostTagContentWhereInput;
  NOT?: PostTagContentWhereInput[] | PostTagContentWhereInput;
}

export interface AvatarUpsertNestedInput {
  update: AvatarUpdateDataInput;
  create: AvatarCreateInput;
}

export interface ProjectCategoryContentUpdateManyMutationInput {
  title?: String;
  text?: String;
  imageAlt?: String;
  metaTitle?: String;
  metaDescription?: String;
}

export interface ProfileUpsertWithoutUserInput {
  update: ProfileUpdateWithoutUserDataInput;
  create: ProfileCreateWithoutUserInput;
}

export interface ProjectLngUpsertWithoutProjectsInput {
  update: ProjectLngUpdateWithoutProjectsDataInput;
  create: ProjectLngCreateWithoutProjectsInput;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  set?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export interface ProjectTagLngSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectTagLngWhereInput;
  AND?:
    | ProjectTagLngSubscriptionWhereInput[]
    | ProjectTagLngSubscriptionWhereInput;
  OR?:
    | ProjectTagLngSubscriptionWhereInput[]
    | ProjectTagLngSubscriptionWhereInput;
  NOT?:
    | ProjectTagLngSubscriptionWhereInput[]
    | ProjectTagLngSubscriptionWhereInput;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface ProjectTagContentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectTagContentWhereInput;
  AND?:
    | ProjectTagContentSubscriptionWhereInput[]
    | ProjectTagContentSubscriptionWhereInput;
  OR?:
    | ProjectTagContentSubscriptionWhereInput[]
    | ProjectTagContentSubscriptionWhereInput;
  NOT?:
    | ProjectTagContentSubscriptionWhereInput[]
    | ProjectTagContentSubscriptionWhereInput;
}

export interface PostUpdateWithoutAuthorDataInput {
  slug?: String;
  isPublished?: Boolean;
  imageSrc?: String;
  contents?: PostContentUpdateManyWithoutPostInput;
  tags?: PostTagUpdateManyInput;
  comments?: CommentUpdateManyWithoutPostInput;
  likes?: Int;
  likedBy?: UserUpdateManyWithoutPostLikesInput;
}

export interface ProjectLngSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectLngWhereInput;
  AND?: ProjectLngSubscriptionWhereInput[] | ProjectLngSubscriptionWhereInput;
  OR?: ProjectLngSubscriptionWhereInput[] | ProjectLngSubscriptionWhereInput;
  NOT?: ProjectLngSubscriptionWhereInput[] | ProjectLngSubscriptionWhereInput;
}

export interface PostContentUpdateManyWithoutPostInput {
  create?:
    | PostContentCreateWithoutPostInput[]
    | PostContentCreateWithoutPostInput;
  delete?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
  connect?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
  set?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
  disconnect?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
  update?:
    | PostContentUpdateWithWhereUniqueWithoutPostInput[]
    | PostContentUpdateWithWhereUniqueWithoutPostInput;
  upsert?:
    | PostContentUpsertWithWhereUniqueWithoutPostInput[]
    | PostContentUpsertWithWhereUniqueWithoutPostInput;
  deleteMany?: PostContentScalarWhereInput[] | PostContentScalarWhereInput;
  updateMany?:
    | PostContentUpdateManyWithWhereNestedInput[]
    | PostContentUpdateManyWithWhereNestedInput;
}

export interface ProjectCategoryWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  contents_every?: ProjectCategoryContentWhereInput;
  contents_some?: ProjectCategoryContentWhereInput;
  contents_none?: ProjectCategoryContentWhereInput;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  projects_every?: ProjectWhereInput;
  projects_some?: ProjectWhereInput;
  projects_none?: ProjectWhereInput;
  AND?: ProjectCategoryWhereInput[] | ProjectCategoryWhereInput;
  OR?: ProjectCategoryWhereInput[] | ProjectCategoryWhereInput;
  NOT?: ProjectCategoryWhereInput[] | ProjectCategoryWhereInput;
}

export interface PostContentUpdateWithWhereUniqueWithoutPostInput {
  where: PostContentWhereUniqueInput;
  data: PostContentUpdateWithoutPostDataInput;
}

export interface ProjectImageLngSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectImageLngWhereInput;
  AND?:
    | ProjectImageLngSubscriptionWhereInput[]
    | ProjectImageLngSubscriptionWhereInput;
  OR?:
    | ProjectImageLngSubscriptionWhereInput[]
    | ProjectImageLngSubscriptionWhereInput;
  NOT?:
    | ProjectImageLngSubscriptionWhereInput[]
    | ProjectImageLngSubscriptionWhereInput;
}

export interface PostContentUpdateWithoutPostDataInput {
  language?: PostLngUpdateOneRequiredWithoutPostsInput;
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt?: String;
}

export interface ProfileWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  avatar?: AvatarWhereInput;
  AND?: ProfileWhereInput[] | ProfileWhereInput;
  OR?: ProfileWhereInput[] | ProfileWhereInput;
  NOT?: ProfileWhereInput[] | ProfileWhereInput;
}

export interface PostLngUpdateOneRequiredWithoutPostsInput {
  create?: PostLngCreateWithoutPostsInput;
  update?: PostLngUpdateWithoutPostsDataInput;
  upsert?: PostLngUpsertWithoutPostsInput;
  connect?: PostLngWhereUniqueInput;
}

export interface ProjectContentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectContentWhereInput;
  AND?:
    | ProjectContentSubscriptionWhereInput[]
    | ProjectContentSubscriptionWhereInput;
  OR?:
    | ProjectContentSubscriptionWhereInput[]
    | ProjectContentSubscriptionWhereInput;
  NOT?:
    | ProjectContentSubscriptionWhereInput[]
    | ProjectContentSubscriptionWhereInput;
}

export interface PostLngUpdateWithoutPostsDataInput {
  country?: String;
  locale?: String;
}

export interface UserWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  profile?: ProfileWhereInput;
  posts_every?: PostWhereInput;
  posts_some?: PostWhereInput;
  posts_none?: PostWhereInput;
  postLikes_every?: PostWhereInput;
  postLikes_some?: PostWhereInput;
  postLikes_none?: PostWhereInput;
  projects_every?: ProjectWhereInput;
  projects_some?: ProjectWhereInput;
  projects_none?: ProjectWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface PostLngUpsertWithoutPostsInput {
  update: PostLngUpdateWithoutPostsDataInput;
  create: PostLngCreateWithoutPostsInput;
}

export interface ProjectCategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectCategoryWhereInput;
  AND?:
    | ProjectCategorySubscriptionWhereInput[]
    | ProjectCategorySubscriptionWhereInput;
  OR?:
    | ProjectCategorySubscriptionWhereInput[]
    | ProjectCategorySubscriptionWhereInput;
  NOT?:
    | ProjectCategorySubscriptionWhereInput[]
    | ProjectCategorySubscriptionWhereInput;
}

export interface PostContentUpsertWithWhereUniqueWithoutPostInput {
  where: PostContentWhereUniqueInput;
  update: PostContentUpdateWithoutPostDataInput;
  create: PostContentCreateWithoutPostInput;
}

export interface PostWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  imageSrc?: String;
  imageSrc_not?: String;
  imageSrc_in?: String[] | String;
  imageSrc_not_in?: String[] | String;
  imageSrc_lt?: String;
  imageSrc_lte?: String;
  imageSrc_gt?: String;
  imageSrc_gte?: String;
  imageSrc_contains?: String;
  imageSrc_not_contains?: String;
  imageSrc_starts_with?: String;
  imageSrc_not_starts_with?: String;
  imageSrc_ends_with?: String;
  imageSrc_not_ends_with?: String;
  contents_every?: PostContentWhereInput;
  contents_some?: PostContentWhereInput;
  contents_none?: PostContentWhereInput;
  tags_every?: PostTagWhereInput;
  tags_some?: PostTagWhereInput;
  tags_none?: PostTagWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  likes?: Int;
  likes_not?: Int;
  likes_in?: Int[] | Int;
  likes_not_in?: Int[] | Int;
  likes_lt?: Int;
  likes_lte?: Int;
  likes_gt?: Int;
  likes_gte?: Int;
  likedBy_every?: UserWhereInput;
  likedBy_some?: UserWhereInput;
  likedBy_none?: UserWhereInput;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export interface PostContentScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  metaTitle?: String;
  metaTitle_not?: String;
  metaTitle_in?: String[] | String;
  metaTitle_not_in?: String[] | String;
  metaTitle_lt?: String;
  metaTitle_lte?: String;
  metaTitle_gt?: String;
  metaTitle_gte?: String;
  metaTitle_contains?: String;
  metaTitle_not_contains?: String;
  metaTitle_starts_with?: String;
  metaTitle_not_starts_with?: String;
  metaTitle_ends_with?: String;
  metaTitle_not_ends_with?: String;
  metaDescription?: String;
  metaDescription_not?: String;
  metaDescription_in?: String[] | String;
  metaDescription_not_in?: String[] | String;
  metaDescription_lt?: String;
  metaDescription_lte?: String;
  metaDescription_gt?: String;
  metaDescription_gte?: String;
  metaDescription_contains?: String;
  metaDescription_not_contains?: String;
  metaDescription_starts_with?: String;
  metaDescription_not_starts_with?: String;
  metaDescription_ends_with?: String;
  metaDescription_not_ends_with?: String;
  imageAlt?: String;
  imageAlt_not?: String;
  imageAlt_in?: String[] | String;
  imageAlt_not_in?: String[] | String;
  imageAlt_lt?: String;
  imageAlt_lte?: String;
  imageAlt_gt?: String;
  imageAlt_gte?: String;
  imageAlt_contains?: String;
  imageAlt_not_contains?: String;
  imageAlt_starts_with?: String;
  imageAlt_not_starts_with?: String;
  imageAlt_ends_with?: String;
  imageAlt_not_ends_with?: String;
  AND?: PostContentScalarWhereInput[] | PostContentScalarWhereInput;
  OR?: PostContentScalarWhereInput[] | PostContentScalarWhereInput;
  NOT?: PostContentScalarWhereInput[] | PostContentScalarWhereInput;
}

export interface ProfileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProfileWhereInput;
  AND?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput;
  OR?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput;
  NOT?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput;
}

export interface PostContentUpdateManyWithWhereNestedInput {
  where: PostContentScalarWhereInput;
  data: PostContentUpdateManyDataInput;
}

export interface PostTagContentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostTagContentWhereInput;
  AND?:
    | PostTagContentSubscriptionWhereInput[]
    | PostTagContentSubscriptionWhereInput;
  OR?:
    | PostTagContentSubscriptionWhereInput[]
    | PostTagContentSubscriptionWhereInput;
  NOT?:
    | PostTagContentSubscriptionWhereInput[]
    | PostTagContentSubscriptionWhereInput;
}

export interface PostContentUpdateManyDataInput {
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt?: String;
}

export interface PostLngSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostLngWhereInput;
  AND?: PostLngSubscriptionWhereInput[] | PostLngSubscriptionWhereInput;
  OR?: PostLngSubscriptionWhereInput[] | PostLngSubscriptionWhereInput;
  NOT?: PostLngSubscriptionWhereInput[] | PostLngSubscriptionWhereInput;
}

export interface PostTagUpdateManyInput {
  create?: PostTagCreateInput[] | PostTagCreateInput;
  update?:
    | PostTagUpdateWithWhereUniqueNestedInput[]
    | PostTagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PostTagUpsertWithWhereUniqueNestedInput[]
    | PostTagUpsertWithWhereUniqueNestedInput;
  delete?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
  connect?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
  set?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
  disconnect?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
  deleteMany?: PostTagScalarWhereInput[] | PostTagScalarWhereInput;
  updateMany?:
    | PostTagUpdateManyWithWhereNestedInput[]
    | PostTagUpdateManyWithWhereNestedInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface PostTagUpdateWithWhereUniqueNestedInput {
  where: PostTagWhereUniqueInput;
  data: PostTagUpdateDataInput;
}

export interface AvatarSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AvatarWhereInput;
  AND?: AvatarSubscriptionWhereInput[] | AvatarSubscriptionWhereInput;
  OR?: AvatarSubscriptionWhereInput[] | AvatarSubscriptionWhereInput;
  NOT?: AvatarSubscriptionWhereInput[] | AvatarSubscriptionWhereInput;
}

export interface PostTagUpdateDataInput {
  color?: String;
  language?: PostTagLngUpdateOneRequiredWithoutTagsInput;
  contents?: PostTagContentUpdateOneRequiredWithoutTagInput;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
  role?: Role;
}

export interface PostTagLngUpdateOneRequiredWithoutTagsInput {
  create?: PostTagLngCreateWithoutTagsInput;
  update?: PostTagLngUpdateWithoutTagsDataInput;
  upsert?: PostTagLngUpsertWithoutTagsInput;
  connect?: PostTagLngWhereUniqueInput;
}

export interface UserCreateInput {
  id?: UUID;
  name: String;
  email?: String;
  password: String;
  role?: Role;
  profile?: ProfileCreateOneWithoutUserInput;
  posts?: PostCreateManyWithoutAuthorInput;
  postLikes?: PostCreateManyWithoutLikedByInput;
  projects?: ProjectCreateManyWithoutAuthorInput;
  comments?: CommentCreateManyWithoutAuthorInput;
}

export interface PostTagLngUpdateWithoutTagsDataInput {
  country?: String;
  locale?: String;
}

export interface ProjectTagLngUpdateManyMutationInput {
  country?: String;
  locale?: String;
}

export interface PostTagLngUpsertWithoutTagsInput {
  update: PostTagLngUpdateWithoutTagsDataInput;
  create: PostTagLngCreateWithoutTagsInput;
}

export interface ProjectTagUpdateWithoutLanguageDataInput {
  contents?: ProjectTagContentUpdateOneRequiredWithoutTagInput;
  title?: String;
  color?: String;
}

export interface PostTagContentUpdateOneRequiredWithoutTagInput {
  create?: PostTagContentCreateWithoutTagInput;
  update?: PostTagContentUpdateWithoutTagDataInput;
  upsert?: PostTagContentUpsertWithoutTagInput;
  connect?: PostTagContentWhereUniqueInput;
}

export interface ProjectTagUpdateWithWhereUniqueWithoutLanguageInput {
  where: ProjectTagWhereUniqueInput;
  data: ProjectTagUpdateWithoutLanguageDataInput;
}

export interface PostTagContentUpdateWithoutTagDataInput {
  title?: String;
}

export interface ProjectTagLngUpdateInput {
  tags?: ProjectTagUpdateManyWithoutLanguageInput;
  country?: String;
  locale?: String;
}

export interface PostTagContentUpsertWithoutTagInput {
  update: PostTagContentUpdateWithoutTagDataInput;
  create: PostTagContentCreateWithoutTagInput;
}

export type PostTagWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface PostTagUpsertWithWhereUniqueNestedInput {
  where: PostTagWhereUniqueInput;
  update: PostTagUpdateDataInput;
  create: PostTagCreateInput;
}

export interface ProjectTagLngCreateInput {
  id?: UUID;
  tags?: ProjectTagCreateManyWithoutLanguageInput;
  country: String;
  locale: String;
}

export interface PostTagScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  color?: String;
  color_not?: String;
  color_in?: String[] | String;
  color_not_in?: String[] | String;
  color_lt?: String;
  color_lte?: String;
  color_gt?: String;
  color_gte?: String;
  color_contains?: String;
  color_not_contains?: String;
  color_starts_with?: String;
  color_not_starts_with?: String;
  color_ends_with?: String;
  color_not_ends_with?: String;
  AND?: PostTagScalarWhereInput[] | PostTagScalarWhereInput;
  OR?: PostTagScalarWhereInput[] | PostTagScalarWhereInput;
  NOT?: PostTagScalarWhereInput[] | PostTagScalarWhereInput;
}

export type PostTagContentWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface PostTagUpdateManyWithWhereNestedInput {
  where: PostTagScalarWhereInput;
  data: PostTagUpdateManyDataInput;
}

export interface ProjectTagUpsertWithoutContentsInput {
  update: ProjectTagUpdateWithoutContentsDataInput;
  create: ProjectTagCreateWithoutContentsInput;
}

export interface PostTagUpdateManyDataInput {
  color?: String;
}

export interface ProjectTagUpdateOneRequiredWithoutContentsInput {
  create?: ProjectTagCreateWithoutContentsInput;
  update?: ProjectTagUpdateWithoutContentsDataInput;
  upsert?: ProjectTagUpsertWithoutContentsInput;
  connect?: ProjectTagWhereUniqueInput;
}

export interface CommentUpdateManyWithoutPostInput {
  create?: CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutPostInput[]
    | CommentUpdateWithWhereUniqueWithoutPostInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutPostInput[]
    | CommentUpsertWithWhereUniqueWithoutPostInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface ProjectTagContentUpdateInput {
  tag?: ProjectTagUpdateOneRequiredWithoutContentsInput;
  title?: String;
}

export interface CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutPostDataInput;
}

export interface ProjectTagCreateOneWithoutContentsInput {
  create?: ProjectTagCreateWithoutContentsInput;
  connect?: ProjectTagWhereUniqueInput;
}

export interface CommentUpdateWithoutPostDataInput {
  author?: UserUpdateOneRequiredWithoutCommentsInput;
}

export type ProfileWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutPostDataInput;
  create: CommentCreateWithoutPostInput;
}

export interface ProjectTagUpdateInput {
  language?: ProjectTagLngUpdateOneRequiredWithoutTagsInput;
  contents?: ProjectTagContentUpdateOneRequiredWithoutTagInput;
  title?: String;
  color?: String;
}

export interface CommentScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface ProjectContentUpsertWithWhereUniqueWithoutLanguageInput {
  where: ProjectContentWhereUniqueInput;
  update: ProjectContentUpdateWithoutLanguageDataInput;
  create: ProjectContentCreateWithoutLanguageInput;
}

export interface UserUpdateManyWithoutPostLikesInput {
  create?: UserCreateWithoutPostLikesInput[] | UserCreateWithoutPostLikesInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutPostLikesInput[]
    | UserUpdateWithWhereUniqueWithoutPostLikesInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutPostLikesInput[]
    | UserUpsertWithWhereUniqueWithoutPostLikesInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface ProjectContentUpdateWithoutLanguageDataInput {
  project?: ProjectUpdateOneRequiredWithoutContentsInput;
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive?: Boolean;
}

export interface UserUpdateWithWhereUniqueWithoutPostLikesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutPostLikesDataInput;
}

export interface ProjectContentUpdateManyWithoutLanguageInput {
  create?:
    | ProjectContentCreateWithoutLanguageInput[]
    | ProjectContentCreateWithoutLanguageInput;
  delete?: ProjectContentWhereUniqueInput[] | ProjectContentWhereUniqueInput;
  connect?: ProjectContentWhereUniqueInput[] | ProjectContentWhereUniqueInput;
  set?: ProjectContentWhereUniqueInput[] | ProjectContentWhereUniqueInput;
  disconnect?:
    | ProjectContentWhereUniqueInput[]
    | ProjectContentWhereUniqueInput;
  update?:
    | ProjectContentUpdateWithWhereUniqueWithoutLanguageInput[]
    | ProjectContentUpdateWithWhereUniqueWithoutLanguageInput;
  upsert?:
    | ProjectContentUpsertWithWhereUniqueWithoutLanguageInput[]
    | ProjectContentUpsertWithWhereUniqueWithoutLanguageInput;
  deleteMany?:
    | ProjectContentScalarWhereInput[]
    | ProjectContentScalarWhereInput;
  updateMany?:
    | ProjectContentUpdateManyWithWhereNestedInput[]
    | ProjectContentUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithoutPostLikesDataInput {
  name?: String;
  email?: String;
  password?: String;
  role?: Role;
  profile?: ProfileUpdateOneWithoutUserInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  projects?: ProjectUpdateManyWithoutAuthorInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
}

export interface ProjectLngUpdateInput {
  projects?: ProjectContentUpdateManyWithoutLanguageInput;
  country?: String;
  locale?: String;
}

export interface ProjectUpdateManyWithoutAuthorInput {
  create?: ProjectCreateWithoutAuthorInput[] | ProjectCreateWithoutAuthorInput;
  delete?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  connect?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  set?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  disconnect?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  update?:
    | ProjectUpdateWithWhereUniqueWithoutAuthorInput[]
    | ProjectUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | ProjectUpsertWithWhereUniqueWithoutAuthorInput[]
    | ProjectUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: ProjectScalarWhereInput[] | ProjectScalarWhereInput;
  updateMany?:
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput;
}

export interface ProjectContentCreateManyWithoutLanguageInput {
  create?:
    | ProjectContentCreateWithoutLanguageInput[]
    | ProjectContentCreateWithoutLanguageInput;
  connect?: ProjectContentWhereUniqueInput[] | ProjectContentWhereUniqueInput;
}

export interface ProjectUpdateWithWhereUniqueWithoutAuthorInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutAuthorDataInput;
}

export type ProjectCategoryWhereUniqueInput = AtLeastOne<{
  id: UUID;
  slug?: String;
}>;

export interface ProjectUpdateWithoutAuthorDataInput {
  slug?: String;
  category?: ProjectCategoryUpdateOneRequiredWithoutProjectsInput;
  album?: ProjectAlbumUpdateOneRequiredWithoutProjectInput;
  contents?: ProjectContentUpdateManyWithoutProjectInput;
  tags?: ProjectTagUpdateManyInput;
}

export interface ProjectImageContentUpdateManyDataInput {
  alt?: String;
}

export interface ProjectCategoryUpdateOneRequiredWithoutProjectsInput {
  create?: ProjectCategoryCreateWithoutProjectsInput;
  update?: ProjectCategoryUpdateWithoutProjectsDataInput;
  upsert?: ProjectCategoryUpsertWithoutProjectsInput;
  connect?: ProjectCategoryWhereUniqueInput;
}

export interface ProjectImageContentScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  alt?: String;
  alt_not?: String;
  alt_in?: String[] | String;
  alt_not_in?: String[] | String;
  alt_lt?: String;
  alt_lte?: String;
  alt_gt?: String;
  alt_gte?: String;
  alt_contains?: String;
  alt_not_contains?: String;
  alt_starts_with?: String;
  alt_not_starts_with?: String;
  alt_ends_with?: String;
  alt_not_ends_with?: String;
  AND?:
    | ProjectImageContentScalarWhereInput[]
    | ProjectImageContentScalarWhereInput;
  OR?:
    | ProjectImageContentScalarWhereInput[]
    | ProjectImageContentScalarWhereInput;
  NOT?:
    | ProjectImageContentScalarWhereInput[]
    | ProjectImageContentScalarWhereInput;
}

export interface ProjectCategoryUpdateWithoutProjectsDataInput {
  contents?: ProjectCategoryContentUpdateManyWithoutCategoryInput;
  slug?: String;
  image?: String;
}

export interface ProjectImageContentUpsertWithWhereUniqueWithoutLanguageInput {
  where: ProjectImageContentWhereUniqueInput;
  update: ProjectImageContentUpdateWithoutLanguageDataInput;
  create: ProjectImageContentCreateWithoutLanguageInput;
}

export interface ProjectCategoryContentUpdateManyWithoutCategoryInput {
  create?:
    | ProjectCategoryContentCreateWithoutCategoryInput[]
    | ProjectCategoryContentCreateWithoutCategoryInput;
  delete?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
  connect?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
  set?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
  disconnect?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
  update?:
    | ProjectCategoryContentUpdateWithWhereUniqueWithoutCategoryInput[]
    | ProjectCategoryContentUpdateWithWhereUniqueWithoutCategoryInput;
  upsert?:
    | ProjectCategoryContentUpsertWithWhereUniqueWithoutCategoryInput[]
    | ProjectCategoryContentUpsertWithWhereUniqueWithoutCategoryInput;
  deleteMany?:
    | ProjectCategoryContentScalarWhereInput[]
    | ProjectCategoryContentScalarWhereInput;
  updateMany?:
    | ProjectCategoryContentUpdateManyWithWhereNestedInput[]
    | ProjectCategoryContentUpdateManyWithWhereNestedInput;
}

export interface ProjectImageContentUpdateWithWhereUniqueWithoutLanguageInput {
  where: ProjectImageContentWhereUniqueInput;
  data: ProjectImageContentUpdateWithoutLanguageDataInput;
}

export interface ProjectCategoryContentUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProjectCategoryContentWhereUniqueInput;
  data: ProjectCategoryContentUpdateWithoutCategoryDataInput;
}

export interface ProjectImageContentUpdateManyWithoutLanguageInput {
  create?:
    | ProjectImageContentCreateWithoutLanguageInput[]
    | ProjectImageContentCreateWithoutLanguageInput;
  delete?:
    | ProjectImageContentWhereUniqueInput[]
    | ProjectImageContentWhereUniqueInput;
  connect?:
    | ProjectImageContentWhereUniqueInput[]
    | ProjectImageContentWhereUniqueInput;
  set?:
    | ProjectImageContentWhereUniqueInput[]
    | ProjectImageContentWhereUniqueInput;
  disconnect?:
    | ProjectImageContentWhereUniqueInput[]
    | ProjectImageContentWhereUniqueInput;
  update?:
    | ProjectImageContentUpdateWithWhereUniqueWithoutLanguageInput[]
    | ProjectImageContentUpdateWithWhereUniqueWithoutLanguageInput;
  upsert?:
    | ProjectImageContentUpsertWithWhereUniqueWithoutLanguageInput[]
    | ProjectImageContentUpsertWithWhereUniqueWithoutLanguageInput;
  deleteMany?:
    | ProjectImageContentScalarWhereInput[]
    | ProjectImageContentScalarWhereInput;
  updateMany?:
    | ProjectImageContentUpdateManyWithWhereNestedInput[]
    | ProjectImageContentUpdateManyWithWhereNestedInput;
}

export interface ProjectCategoryContentUpdateWithoutCategoryDataInput {
  language?: ProjectCategoryLngUpdateOneRequiredWithoutCategoriesInput;
  title?: String;
  text?: String;
  imageAlt?: String;
  metaTitle?: String;
  metaDescription?: String;
}

export interface ProjectImageContentCreateWithoutLanguageInput {
  id?: UUID;
  image: ProjectImageCreateOneWithoutContentsInput;
  alt: String;
}

export interface ProjectCategoryLngUpdateOneRequiredWithoutCategoriesInput {
  create?: ProjectCategoryLngCreateWithoutCategoriesInput;
  update?: ProjectCategoryLngUpdateWithoutCategoriesDataInput;
  upsert?: ProjectCategoryLngUpsertWithoutCategoriesInput;
  connect?: ProjectCategoryLngWhereUniqueInput;
}

export type ProjectContentWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ProjectCategoryLngUpdateWithoutCategoriesDataInput {
  country?: String;
  locale?: String;
}

export interface ProjectImageContentUpdateManyMutationInput {
  alt?: String;
}

export interface ProjectCategoryLngUpsertWithoutCategoriesInput {
  update: ProjectCategoryLngUpdateWithoutCategoriesDataInput;
  create: ProjectCategoryLngCreateWithoutCategoriesInput;
}

export type ProjectImageWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ProjectCategoryContentUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProjectCategoryContentWhereUniqueInput;
  update: ProjectCategoryContentUpdateWithoutCategoryDataInput;
  create: ProjectCategoryContentCreateWithoutCategoryInput;
}

export interface ProjectImageUpdateOneRequiredWithoutContentsInput {
  create?: ProjectImageCreateWithoutContentsInput;
  update?: ProjectImageUpdateWithoutContentsDataInput;
  upsert?: ProjectImageUpsertWithoutContentsInput;
  connect?: ProjectImageWhereUniqueInput;
}

export interface ProjectCategoryContentScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  imageAlt?: String;
  imageAlt_not?: String;
  imageAlt_in?: String[] | String;
  imageAlt_not_in?: String[] | String;
  imageAlt_lt?: String;
  imageAlt_lte?: String;
  imageAlt_gt?: String;
  imageAlt_gte?: String;
  imageAlt_contains?: String;
  imageAlt_not_contains?: String;
  imageAlt_starts_with?: String;
  imageAlt_not_starts_with?: String;
  imageAlt_ends_with?: String;
  imageAlt_not_ends_with?: String;
  metaTitle?: String;
  metaTitle_not?: String;
  metaTitle_in?: String[] | String;
  metaTitle_not_in?: String[] | String;
  metaTitle_lt?: String;
  metaTitle_lte?: String;
  metaTitle_gt?: String;
  metaTitle_gte?: String;
  metaTitle_contains?: String;
  metaTitle_not_contains?: String;
  metaTitle_starts_with?: String;
  metaTitle_not_starts_with?: String;
  metaTitle_ends_with?: String;
  metaTitle_not_ends_with?: String;
  metaDescription?: String;
  metaDescription_not?: String;
  metaDescription_in?: String[] | String;
  metaDescription_not_in?: String[] | String;
  metaDescription_lt?: String;
  metaDescription_lte?: String;
  metaDescription_gt?: String;
  metaDescription_gte?: String;
  metaDescription_contains?: String;
  metaDescription_not_contains?: String;
  metaDescription_starts_with?: String;
  metaDescription_not_starts_with?: String;
  metaDescription_ends_with?: String;
  metaDescription_not_ends_with?: String;
  AND?:
    | ProjectCategoryContentScalarWhereInput[]
    | ProjectCategoryContentScalarWhereInput;
  OR?:
    | ProjectCategoryContentScalarWhereInput[]
    | ProjectCategoryContentScalarWhereInput;
  NOT?:
    | ProjectCategoryContentScalarWhereInput[]
    | ProjectCategoryContentScalarWhereInput;
}

export type ProjectImageContentWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ProjectCategoryContentUpdateManyWithWhereNestedInput {
  where: ProjectCategoryContentScalarWhereInput;
  data: ProjectCategoryContentUpdateManyDataInput;
}

export interface ProjectImageCreateOneWithoutContentsInput {
  create?: ProjectImageCreateWithoutContentsInput;
  connect?: ProjectImageWhereUniqueInput;
}

export interface ProjectCategoryContentUpdateManyDataInput {
  title?: String;
  text?: String;
  imageAlt?: String;
  metaTitle?: String;
  metaDescription?: String;
}

export type ProjectImageLngWhereUniqueInput = AtLeastOne<{
  id: UUID;
  country?: String;
  locale?: String;
}>;

export interface ProjectCategoryUpsertWithoutProjectsInput {
  update: ProjectCategoryUpdateWithoutProjectsDataInput;
  create: ProjectCategoryCreateWithoutProjectsInput;
}

export interface ProjectAlbumUpsertWithoutImagesInput {
  update: ProjectAlbumUpdateWithoutImagesDataInput;
  create: ProjectAlbumCreateWithoutImagesInput;
}

export interface ProjectCategoryLngCreateInput {
  id?: UUID;
  categories?: ProjectCategoryContentCreateManyWithoutLanguageInput;
  country: String;
  locale?: String;
}

export interface ProjectAlbumUpdateOneRequiredWithoutImagesInput {
  create?: ProjectAlbumCreateWithoutImagesInput;
  update?: ProjectAlbumUpdateWithoutImagesDataInput;
  upsert?: ProjectAlbumUpsertWithoutImagesInput;
  connect?: ProjectAlbumWhereUniqueInput;
}

export interface ProjectAlbumUpdateWithoutProjectDataInput {
  images?: ProjectImageUpdateManyWithoutAlbumInput;
}

export interface AvatarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  publicId?: String;
  publicId_not?: String;
  publicId_in?: String[] | String;
  publicId_not_in?: String[] | String;
  publicId_lt?: String;
  publicId_lte?: String;
  publicId_gt?: String;
  publicId_gte?: String;
  publicId_contains?: String;
  publicId_not_contains?: String;
  publicId_starts_with?: String;
  publicId_not_starts_with?: String;
  publicId_ends_with?: String;
  publicId_not_ends_with?: String;
  src?: String;
  src_not?: String;
  src_in?: String[] | String;
  src_not_in?: String[] | String;
  src_lt?: String;
  src_lte?: String;
  src_gt?: String;
  src_gte?: String;
  src_contains?: String;
  src_not_contains?: String;
  src_starts_with?: String;
  src_not_starts_with?: String;
  src_ends_with?: String;
  src_not_ends_with?: String;
  AND?: AvatarWhereInput[] | AvatarWhereInput;
  OR?: AvatarWhereInput[] | AvatarWhereInput;
  NOT?: AvatarWhereInput[] | AvatarWhereInput;
}

export interface ProjectImageUpdateManyWithoutAlbumInput {
  create?:
    | ProjectImageCreateWithoutAlbumInput[]
    | ProjectImageCreateWithoutAlbumInput;
  delete?: ProjectImageWhereUniqueInput[] | ProjectImageWhereUniqueInput;
  connect?: ProjectImageWhereUniqueInput[] | ProjectImageWhereUniqueInput;
  set?: ProjectImageWhereUniqueInput[] | ProjectImageWhereUniqueInput;
  disconnect?: ProjectImageWhereUniqueInput[] | ProjectImageWhereUniqueInput;
  update?:
    | ProjectImageUpdateWithWhereUniqueWithoutAlbumInput[]
    | ProjectImageUpdateWithWhereUniqueWithoutAlbumInput;
  upsert?:
    | ProjectImageUpsertWithWhereUniqueWithoutAlbumInput[]
    | ProjectImageUpsertWithWhereUniqueWithoutAlbumInput;
  deleteMany?: ProjectImageScalarWhereInput[] | ProjectImageScalarWhereInput;
  updateMany?:
    | ProjectImageUpdateManyWithWhereNestedInput[]
    | ProjectImageUpdateManyWithWhereNestedInput;
}

export interface ProjectAlbumCreateWithoutImagesInput {
  id?: UUID;
  project: ProjectCreateOneWithoutAlbumInput;
}

export interface ProjectImageUpdateWithWhereUniqueWithoutAlbumInput {
  where: ProjectImageWhereUniqueInput;
  data: ProjectImageUpdateWithoutAlbumDataInput;
}

export type ProjectTagWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ProjectImageUpdateWithoutAlbumDataInput {
  publicId?: String;
  src?: String;
  contents?: ProjectImageContentUpdateOneRequiredWithoutImageInput;
}

export interface ProjectContentUpdateManyMutationInput {
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive?: Boolean;
}

export interface ProjectImageContentUpdateOneRequiredWithoutImageInput {
  create?: ProjectImageContentCreateWithoutImageInput;
  update?: ProjectImageContentUpdateWithoutImageDataInput;
  upsert?: ProjectImageContentUpsertWithoutImageInput;
  connect?: ProjectImageContentWhereUniqueInput;
}

export type ProjectTagContentWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ProjectImageContentUpdateWithoutImageDataInput {
  language?: ProjectImageLngUpdateOneRequiredWithoutImagesInput;
  alt?: String;
}

export interface ProjectUpdateOneRequiredWithoutContentsInput {
  create?: ProjectCreateWithoutContentsInput;
  update?: ProjectUpdateWithoutContentsDataInput;
  upsert?: ProjectUpsertWithoutContentsInput;
  connect?: ProjectWhereUniqueInput;
}

export interface ProjectImageLngUpdateOneRequiredWithoutImagesInput {
  create?: ProjectImageLngCreateWithoutImagesInput;
  update?: ProjectImageLngUpdateWithoutImagesDataInput;
  upsert?: ProjectImageLngUpsertWithoutImagesInput;
  connect?: ProjectImageLngWhereUniqueInput;
}

export interface ProjectCreateWithoutContentsInput {
  id?: UUID;
  slug: String;
  category: ProjectCategoryCreateOneWithoutProjectsInput;
  author: UserCreateOneWithoutProjectsInput;
  album: ProjectAlbumCreateOneWithoutProjectInput;
  tags?: ProjectTagCreateManyInput;
}

export interface ProjectImageLngUpdateWithoutImagesDataInput {
  country?: String;
  locale?: String;
}

export interface ProjectCreateOneWithoutContentsInput {
  create?: ProjectCreateWithoutContentsInput;
  connect?: ProjectWhereUniqueInput;
}

export interface ProjectImageLngUpsertWithoutImagesInput {
  update: ProjectImageLngUpdateWithoutImagesDataInput;
  create: ProjectImageLngCreateWithoutImagesInput;
}

export interface ProjectCategoryLngUpdateManyMutationInput {
  country?: String;
  locale?: String;
}

export interface ProjectImageContentUpsertWithoutImageInput {
  update: ProjectImageContentUpdateWithoutImageDataInput;
  create: ProjectImageContentCreateWithoutImageInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: UUID;
  email?: String;
}>;

export interface ProjectImageUpsertWithWhereUniqueWithoutAlbumInput {
  where: ProjectImageWhereUniqueInput;
  update: ProjectImageUpdateWithoutAlbumDataInput;
  create: ProjectImageCreateWithoutAlbumInput;
}

export interface ProjectCategoryContentUpdateWithWhereUniqueWithoutLanguageInput {
  where: ProjectCategoryContentWhereUniqueInput;
  data: ProjectCategoryContentUpdateWithoutLanguageDataInput;
}

export interface ProjectImageScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  publicId?: String;
  publicId_not?: String;
  publicId_in?: String[] | String;
  publicId_not_in?: String[] | String;
  publicId_lt?: String;
  publicId_lte?: String;
  publicId_gt?: String;
  publicId_gte?: String;
  publicId_contains?: String;
  publicId_not_contains?: String;
  publicId_starts_with?: String;
  publicId_not_starts_with?: String;
  publicId_ends_with?: String;
  publicId_not_ends_with?: String;
  src?: String;
  src_not?: String;
  src_in?: String[] | String;
  src_not_in?: String[] | String;
  src_lt?: String;
  src_lte?: String;
  src_gt?: String;
  src_gte?: String;
  src_contains?: String;
  src_not_contains?: String;
  src_starts_with?: String;
  src_not_starts_with?: String;
  src_ends_with?: String;
  src_not_ends_with?: String;
  AND?: ProjectImageScalarWhereInput[] | ProjectImageScalarWhereInput;
  OR?: ProjectImageScalarWhereInput[] | ProjectImageScalarWhereInput;
  NOT?: ProjectImageScalarWhereInput[] | ProjectImageScalarWhereInput;
}

export interface ProjectCategoryLngUpdateInput {
  categories?: ProjectCategoryContentUpdateManyWithoutLanguageInput;
  country?: String;
  locale?: String;
}

export interface ProjectImageUpdateManyWithWhereNestedInput {
  where: ProjectImageScalarWhereInput;
  data: ProjectImageUpdateManyDataInput;
}

export interface AvatarCreateInput {
  id?: UUID;
  publicId?: String;
  src?: String;
}

export interface ProjectImageLngWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  images_every?: ProjectImageContentWhereInput;
  images_some?: ProjectImageContentWhereInput;
  images_none?: ProjectImageContentWhereInput;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  locale?: String;
  locale_not?: String;
  locale_in?: String[] | String;
  locale_not_in?: String[] | String;
  locale_lt?: String;
  locale_lte?: String;
  locale_gt?: String;
  locale_gte?: String;
  locale_contains?: String;
  locale_not_contains?: String;
  locale_starts_with?: String;
  locale_not_starts_with?: String;
  locale_ends_with?: String;
  locale_not_ends_with?: String;
  AND?: ProjectImageLngWhereInput[] | ProjectImageLngWhereInput;
  OR?: ProjectImageLngWhereInput[] | ProjectImageLngWhereInput;
  NOT?: ProjectImageLngWhereInput[] | ProjectImageLngWhereInput;
}

export interface AvatarUpdateManyMutationInput {
  publicId?: String;
  src?: String;
}

export interface ProjectLngWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  projects_every?: ProjectContentWhereInput;
  projects_some?: ProjectContentWhereInput;
  projects_none?: ProjectContentWhereInput;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  locale?: String;
  locale_not?: String;
  locale_in?: String[] | String;
  locale_not_in?: String[] | String;
  locale_lt?: String;
  locale_lte?: String;
  locale_gt?: String;
  locale_gte?: String;
  locale_contains?: String;
  locale_not_contains?: String;
  locale_starts_with?: String;
  locale_not_starts_with?: String;
  locale_ends_with?: String;
  locale_not_ends_with?: String;
  AND?: ProjectLngWhereInput[] | ProjectLngWhereInput;
  OR?: ProjectLngWhereInput[] | ProjectLngWhereInput;
  NOT?: ProjectLngWhereInput[] | ProjectLngWhereInput;
}

export interface ProjectCategoryContentCreateManyWithoutLanguageInput {
  create?:
    | ProjectCategoryContentCreateWithoutLanguageInput[]
    | ProjectCategoryContentCreateWithoutLanguageInput;
  connect?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
}

export interface ProjectTagLngWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  tags_every?: ProjectTagWhereInput;
  tags_some?: ProjectTagWhereInput;
  tags_none?: ProjectTagWhereInput;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  locale?: String;
  locale_not?: String;
  locale_in?: String[] | String;
  locale_not_in?: String[] | String;
  locale_lt?: String;
  locale_lte?: String;
  locale_gt?: String;
  locale_gte?: String;
  locale_contains?: String;
  locale_not_contains?: String;
  locale_starts_with?: String;
  locale_not_starts_with?: String;
  locale_ends_with?: String;
  locale_not_ends_with?: String;
  AND?: ProjectTagLngWhereInput[] | ProjectTagLngWhereInput;
  OR?: ProjectTagLngWhereInput[] | ProjectTagLngWhereInput;
  NOT?: ProjectTagLngWhereInput[] | ProjectTagLngWhereInput;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  connect?: UserWhereUniqueInput;
}

export interface CommentWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  post?: PostWhereInput;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface ProfileCreateOneWithoutUserInput {
  create?: ProfileCreateWithoutUserInput;
  connect?: ProfileWhereUniqueInput;
}

export interface PostLngWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  posts_every?: PostContentWhereInput;
  posts_some?: PostContentWhereInput;
  posts_none?: PostContentWhereInput;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  locale?: String;
  locale_not?: String;
  locale_in?: String[] | String;
  locale_not_in?: String[] | String;
  locale_lt?: String;
  locale_lte?: String;
  locale_gt?: String;
  locale_gte?: String;
  locale_contains?: String;
  locale_not_contains?: String;
  locale_starts_with?: String;
  locale_not_starts_with?: String;
  locale_ends_with?: String;
  locale_not_ends_with?: String;
  AND?: PostLngWhereInput[] | PostLngWhereInput;
  OR?: PostLngWhereInput[] | PostLngWhereInput;
  NOT?: PostLngWhereInput[] | PostLngWhereInput;
}

export interface AvatarCreateOneInput {
  create?: AvatarCreateInput;
  connect?: AvatarWhereUniqueInput;
}

export interface PostTagLngWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  tags_every?: PostTagWhereInput;
  tags_some?: PostTagWhereInput;
  tags_none?: PostTagWhereInput;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  locale?: String;
  locale_not?: String;
  locale_in?: String[] | String;
  locale_not_in?: String[] | String;
  locale_lt?: String;
  locale_lte?: String;
  locale_gt?: String;
  locale_gte?: String;
  locale_contains?: String;
  locale_not_contains?: String;
  locale_starts_with?: String;
  locale_not_starts_with?: String;
  locale_ends_with?: String;
  locale_not_ends_with?: String;
  AND?: PostTagLngWhereInput[] | PostTagLngWhereInput;
  OR?: PostTagLngWhereInput[] | PostTagLngWhereInput;
  NOT?: PostTagLngWhereInput[] | PostTagLngWhereInput;
}

export interface PostCreateWithoutAuthorInput {
  id?: UUID;
  slug: String;
  isPublished?: Boolean;
  imageSrc: String;
  contents?: PostContentCreateManyWithoutPostInput;
  tags?: PostTagCreateManyInput;
  comments?: CommentCreateManyWithoutPostInput;
  likes?: Int;
  likedBy?: UserCreateManyWithoutPostLikesInput;
}

export interface ProjectImageWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  album?: ProjectAlbumWhereInput;
  publicId?: String;
  publicId_not?: String;
  publicId_in?: String[] | String;
  publicId_not_in?: String[] | String;
  publicId_lt?: String;
  publicId_lte?: String;
  publicId_gt?: String;
  publicId_gte?: String;
  publicId_contains?: String;
  publicId_not_contains?: String;
  publicId_starts_with?: String;
  publicId_not_starts_with?: String;
  publicId_ends_with?: String;
  publicId_not_ends_with?: String;
  src?: String;
  src_not?: String;
  src_in?: String[] | String;
  src_not_in?: String[] | String;
  src_lt?: String;
  src_lte?: String;
  src_gt?: String;
  src_gte?: String;
  src_contains?: String;
  src_not_contains?: String;
  src_starts_with?: String;
  src_not_starts_with?: String;
  src_ends_with?: String;
  src_not_ends_with?: String;
  contents?: ProjectImageContentWhereInput;
  AND?: ProjectImageWhereInput[] | ProjectImageWhereInput;
  OR?: ProjectImageWhereInput[] | ProjectImageWhereInput;
  NOT?: ProjectImageWhereInput[] | ProjectImageWhereInput;
}

export interface PostContentCreateWithoutPostInput {
  id?: UUID;
  language: PostLngCreateOneWithoutPostsInput;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt: String;
}

export interface ProjectAlbumWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  project?: ProjectWhereInput;
  images_every?: ProjectImageWhereInput;
  images_some?: ProjectImageWhereInput;
  images_none?: ProjectImageWhereInput;
  AND?: ProjectAlbumWhereInput[] | ProjectAlbumWhereInput;
  OR?: ProjectAlbumWhereInput[] | ProjectAlbumWhereInput;
  NOT?: ProjectAlbumWhereInput[] | ProjectAlbumWhereInput;
}

export interface PostLngCreateWithoutPostsInput {
  id?: UUID;
  country: String;
  locale?: String;
}

export interface ProjectContentUpsertWithWhereUniqueWithoutProjectInput {
  where: ProjectContentWhereUniqueInput;
  update: ProjectContentUpdateWithoutProjectDataInput;
  create: ProjectContentCreateWithoutProjectInput;
}

export interface PostTagCreateInput {
  id?: UUID;
  color: String;
  language: PostTagLngCreateOneWithoutTagsInput;
  contents: PostTagContentCreateOneWithoutTagInput;
}

export interface ProjectContentScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  metaTitle?: String;
  metaTitle_not?: String;
  metaTitle_in?: String[] | String;
  metaTitle_not_in?: String[] | String;
  metaTitle_lt?: String;
  metaTitle_lte?: String;
  metaTitle_gt?: String;
  metaTitle_gte?: String;
  metaTitle_contains?: String;
  metaTitle_not_contains?: String;
  metaTitle_starts_with?: String;
  metaTitle_not_starts_with?: String;
  metaTitle_ends_with?: String;
  metaTitle_not_ends_with?: String;
  metaDescription?: String;
  metaDescription_not?: String;
  metaDescription_in?: String[] | String;
  metaDescription_not_in?: String[] | String;
  metaDescription_lt?: String;
  metaDescription_lte?: String;
  metaDescription_gt?: String;
  metaDescription_gte?: String;
  metaDescription_contains?: String;
  metaDescription_not_contains?: String;
  metaDescription_starts_with?: String;
  metaDescription_not_starts_with?: String;
  metaDescription_ends_with?: String;
  metaDescription_not_ends_with?: String;
  isActive?: Boolean;
  isActive_not?: Boolean;
  AND?: ProjectContentScalarWhereInput[] | ProjectContentScalarWhereInput;
  OR?: ProjectContentScalarWhereInput[] | ProjectContentScalarWhereInput;
  NOT?: ProjectContentScalarWhereInput[] | ProjectContentScalarWhereInput;
}

export interface PostTagLngCreateWithoutTagsInput {
  id?: UUID;
  country: String;
  locale: String;
}

export interface ProjectContentUpdateManyWithWhereNestedInput {
  where: ProjectContentScalarWhereInput;
  data: ProjectContentUpdateManyDataInput;
}

export interface PostTagContentCreateWithoutTagInput {
  id?: UUID;
  title: String;
}

export interface ProjectContentUpdateManyDataInput {
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive?: Boolean;
}

export interface CommentCreateWithoutPostInput {
  id?: UUID;
  author: UserCreateOneWithoutCommentsInput;
}

export interface ProjectTagUpdateManyInput {
  create?: ProjectTagCreateInput[] | ProjectTagCreateInput;
  update?:
    | ProjectTagUpdateWithWhereUniqueNestedInput[]
    | ProjectTagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ProjectTagUpsertWithWhereUniqueNestedInput[]
    | ProjectTagUpsertWithWhereUniqueNestedInput;
  delete?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
  connect?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
  set?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
  disconnect?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
  deleteMany?: ProjectTagScalarWhereInput[] | ProjectTagScalarWhereInput;
  updateMany?:
    | ProjectTagUpdateManyWithWhereNestedInput[]
    | ProjectTagUpdateManyWithWhereNestedInput;
}

export interface UserCreateWithoutPostLikesInput {
  id?: UUID;
  name: String;
  email?: String;
  password: String;
  role?: Role;
  profile?: ProfileCreateOneWithoutUserInput;
  posts?: PostCreateManyWithoutAuthorInput;
  projects?: ProjectCreateManyWithoutAuthorInput;
  comments?: CommentCreateManyWithoutAuthorInput;
}

export interface ProjectTagUpdateWithWhereUniqueNestedInput {
  where: ProjectTagWhereUniqueInput;
  data: ProjectTagUpdateDataInput;
}

export interface ProjectCreateWithoutAuthorInput {
  id?: UUID;
  slug: String;
  category: ProjectCategoryCreateOneWithoutProjectsInput;
  album: ProjectAlbumCreateOneWithoutProjectInput;
  contents?: ProjectContentCreateManyWithoutProjectInput;
  tags?: ProjectTagCreateManyInput;
}

export interface ProjectTagUpdateDataInput {
  language?: ProjectTagLngUpdateOneRequiredWithoutTagsInput;
  contents?: ProjectTagContentUpdateOneRequiredWithoutTagInput;
  title?: String;
  color?: String;
}

export interface ProjectCategoryCreateWithoutProjectsInput {
  id?: UUID;
  contents?: ProjectCategoryContentCreateManyWithoutCategoryInput;
  slug: String;
  image: String;
}

export interface ProjectTagLngUpdateOneRequiredWithoutTagsInput {
  create?: ProjectTagLngCreateWithoutTagsInput;
  update?: ProjectTagLngUpdateWithoutTagsDataInput;
  upsert?: ProjectTagLngUpsertWithoutTagsInput;
  connect?: ProjectTagLngWhereUniqueInput;
}

export interface ProjectCategoryContentCreateWithoutCategoryInput {
  id?: UUID;
  language: ProjectCategoryLngCreateOneWithoutCategoriesInput;
  title: String;
  text: String;
  imageAlt: String;
  metaTitle?: String;
  metaDescription?: String;
}

export interface ProjectTagLngUpdateWithoutTagsDataInput {
  country?: String;
  locale?: String;
}

export interface ProjectCategoryLngCreateWithoutCategoriesInput {
  id?: UUID;
  country: String;
  locale?: String;
}

export interface ProjectTagLngUpsertWithoutTagsInput {
  update: ProjectTagLngUpdateWithoutTagsDataInput;
  create: ProjectTagLngCreateWithoutTagsInput;
}

export interface ProjectAlbumCreateWithoutProjectInput {
  id?: UUID;
  images?: ProjectImageCreateManyWithoutAlbumInput;
}

export interface ProjectTagContentUpdateOneRequiredWithoutTagInput {
  create?: ProjectTagContentCreateWithoutTagInput;
  update?: ProjectTagContentUpdateWithoutTagDataInput;
  upsert?: ProjectTagContentUpsertWithoutTagInput;
  connect?: ProjectTagContentWhereUniqueInput;
}

export interface ProjectImageCreateWithoutAlbumInput {
  id?: UUID;
  publicId: String;
  src: String;
  contents: ProjectImageContentCreateOneWithoutImageInput;
}

export interface ProjectTagContentUpdateWithoutTagDataInput {
  title?: String;
}

export interface ProjectImageContentCreateWithoutImageInput {
  id?: UUID;
  language: ProjectImageLngCreateOneWithoutImagesInput;
  alt: String;
}

export interface ProjectTagContentUpsertWithoutTagInput {
  update: ProjectTagContentUpdateWithoutTagDataInput;
  create: ProjectTagContentCreateWithoutTagInput;
}

export interface ProjectImageLngCreateWithoutImagesInput {
  id?: UUID;
  country: String;
  locale?: String;
}

export interface ProjectTagUpsertWithWhereUniqueNestedInput {
  where: ProjectTagWhereUniqueInput;
  update: ProjectTagUpdateDataInput;
  create: ProjectTagCreateInput;
}

export interface ProjectContentCreateWithoutProjectInput {
  id?: UUID;
  language: ProjectLngCreateOneWithoutProjectsInput;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive?: Boolean;
}

export interface ProjectTagScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  color?: String;
  color_not?: String;
  color_in?: String[] | String;
  color_not_in?: String[] | String;
  color_lt?: String;
  color_lte?: String;
  color_gt?: String;
  color_gte?: String;
  color_contains?: String;
  color_not_contains?: String;
  color_starts_with?: String;
  color_not_starts_with?: String;
  color_ends_with?: String;
  color_not_ends_with?: String;
  AND?: ProjectTagScalarWhereInput[] | ProjectTagScalarWhereInput;
  OR?: ProjectTagScalarWhereInput[] | ProjectTagScalarWhereInput;
  NOT?: ProjectTagScalarWhereInput[] | ProjectTagScalarWhereInput;
}

export interface ProjectLngCreateWithoutProjectsInput {
  id?: UUID;
  country: String;
  locale?: String;
}

export interface ProjectTagUpdateManyWithWhereNestedInput {
  where: ProjectTagScalarWhereInput;
  data: ProjectTagUpdateManyDataInput;
}

export interface ProjectTagCreateInput {
  id?: UUID;
  language: ProjectTagLngCreateOneWithoutTagsInput;
  contents: ProjectTagContentCreateOneWithoutTagInput;
  title: String;
  color?: String;
}

export interface ProjectTagUpdateManyDataInput {
  title?: String;
  color?: String;
}

export interface ProjectTagLngCreateWithoutTagsInput {
  id?: UUID;
  country: String;
  locale: String;
}

export interface ProjectUpsertWithWhereUniqueWithoutAuthorInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutAuthorDataInput;
  create: ProjectCreateWithoutAuthorInput;
}

export interface ProjectTagContentCreateWithoutTagInput {
  id?: UUID;
  title?: String;
}

export interface ProjectScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  AND?: ProjectScalarWhereInput[] | ProjectScalarWhereInput;
  OR?: ProjectScalarWhereInput[] | ProjectScalarWhereInput;
  NOT?: ProjectScalarWhereInput[] | ProjectScalarWhereInput;
}

export interface CommentCreateWithoutAuthorInput {
  id?: UUID;
  post: PostCreateOneWithoutCommentsInput;
}

export interface ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput;
  data: ProjectUpdateManyDataInput;
}

export interface PostCreateWithoutCommentsInput {
  id?: UUID;
  author: UserCreateOneWithoutPostsInput;
  slug: String;
  isPublished?: Boolean;
  imageSrc: String;
  contents?: PostContentCreateManyWithoutPostInput;
  tags?: PostTagCreateManyInput;
  likes?: Int;
  likedBy?: UserCreateManyWithoutPostLikesInput;
}

export interface ProjectUpdateManyDataInput {
  slug?: String;
}

export interface UserCreateWithoutPostsInput {
  id?: UUID;
  name: String;
  email?: String;
  password: String;
  role?: Role;
  profile?: ProfileCreateOneWithoutUserInput;
  postLikes?: PostCreateManyWithoutLikedByInput;
  projects?: ProjectCreateManyWithoutAuthorInput;
  comments?: CommentCreateManyWithoutAuthorInput;
}

export interface CommentUpdateManyWithoutAuthorInput {
  create?: CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    | CommentUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    | CommentUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface PostCreateWithoutLikedByInput {
  id?: UUID;
  author: UserCreateOneWithoutPostsInput;
  slug: String;
  isPublished?: Boolean;
  imageSrc: String;
  contents?: PostContentCreateManyWithoutPostInput;
  tags?: PostTagCreateManyInput;
  comments?: CommentCreateManyWithoutPostInput;
  likes?: Int;
}

export interface CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutAuthorDataInput;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  update?: UserUpdateWithoutCommentsDataInput;
  upsert?: UserUpsertWithoutCommentsInput;
  connect?: UserWhereUniqueInput;
}

export interface CommentUpdateWithoutAuthorDataInput {
  post?: PostUpdateOneRequiredWithoutCommentsInput;
}

export interface ProfileUpdateOneWithoutUserInput {
  create?: ProfileCreateWithoutUserInput;
  update?: ProfileUpdateWithoutUserDataInput;
  upsert?: ProfileUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProfileWhereUniqueInput;
}

export interface PostUpdateOneRequiredWithoutCommentsInput {
  create?: PostCreateWithoutCommentsInput;
  update?: PostUpdateWithoutCommentsDataInput;
  upsert?: PostUpsertWithoutCommentsInput;
  connect?: PostWhereUniqueInput;
}

export interface AvatarUpdateOneRequiredInput {
  create?: AvatarCreateInput;
  update?: AvatarUpdateDataInput;
  upsert?: AvatarUpsertNestedInput;
  connect?: AvatarWhereUniqueInput;
}

export interface PostUpdateWithoutCommentsDataInput {
  author?: UserUpdateOneRequiredWithoutPostsInput;
  slug?: String;
  isPublished?: Boolean;
  imageSrc?: String;
  contents?: PostContentUpdateManyWithoutPostInput;
  tags?: PostTagUpdateManyInput;
  likes?: Int;
  likedBy?: UserUpdateManyWithoutPostLikesInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  update?: UserUpdateWithoutPostsDataInput;
  upsert?: UserUpsertWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface ProjectTagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectTagWhereInput;
  AND?: ProjectTagSubscriptionWhereInput[] | ProjectTagSubscriptionWhereInput;
  OR?: ProjectTagSubscriptionWhereInput[] | ProjectTagSubscriptionWhereInput;
  NOT?: ProjectTagSubscriptionWhereInput[] | ProjectTagSubscriptionWhereInput;
}

export interface UserUpdateWithoutPostsDataInput {
  name?: String;
  email?: String;
  password?: String;
  role?: Role;
  profile?: ProfileUpdateOneWithoutUserInput;
  postLikes?: PostUpdateManyWithoutLikedByInput;
  projects?: ProjectUpdateManyWithoutAuthorInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
}

export interface ProjectWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  category?: ProjectCategoryWhereInput;
  author?: UserWhereInput;
  album?: ProjectAlbumWhereInput;
  contents_every?: ProjectContentWhereInput;
  contents_some?: ProjectContentWhereInput;
  contents_none?: ProjectContentWhereInput;
  tags_every?: ProjectTagWhereInput;
  tags_some?: ProjectTagWhereInput;
  tags_none?: ProjectTagWhereInput;
  AND?: ProjectWhereInput[] | ProjectWhereInput;
  OR?: ProjectWhereInput[] | ProjectWhereInput;
  NOT?: ProjectWhereInput[] | ProjectWhereInput;
}

export interface PostUpdateManyWithoutLikedByInput {
  create?: PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  set?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutLikedByInput[]
    | PostUpdateWithWhereUniqueWithoutLikedByInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutLikedByInput[]
    | PostUpsertWithWhereUniqueWithoutLikedByInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export interface ProjectImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectImageWhereInput;
  AND?:
    | ProjectImageSubscriptionWhereInput[]
    | ProjectImageSubscriptionWhereInput;
  OR?:
    | ProjectImageSubscriptionWhereInput[]
    | ProjectImageSubscriptionWhereInput;
  NOT?:
    | ProjectImageSubscriptionWhereInput[]
    | ProjectImageSubscriptionWhereInput;
}

export interface PostUpdateWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutLikedByDataInput;
}

export interface ProjectCategoryContentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectCategoryContentWhereInput;
  AND?:
    | ProjectCategoryContentSubscriptionWhereInput[]
    | ProjectCategoryContentSubscriptionWhereInput;
  OR?:
    | ProjectCategoryContentSubscriptionWhereInput[]
    | ProjectCategoryContentSubscriptionWhereInput;
  NOT?:
    | ProjectCategoryContentSubscriptionWhereInput[]
    | ProjectCategoryContentSubscriptionWhereInput;
}

export interface PostUpdateWithoutLikedByDataInput {
  author?: UserUpdateOneRequiredWithoutPostsInput;
  slug?: String;
  isPublished?: Boolean;
  imageSrc?: String;
  contents?: PostContentUpdateManyWithoutPostInput;
  tags?: PostTagUpdateManyInput;
  comments?: CommentUpdateManyWithoutPostInput;
  likes?: Int;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectWhereInput;
  AND?: ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput;
  OR?: ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput;
  NOT?: ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput;
}

export interface PostUpsertWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutLikedByDataInput;
  create: PostCreateWithoutLikedByInput;
}

export interface PostTagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostTagWhereInput;
  AND?: PostTagSubscriptionWhereInput[] | PostTagSubscriptionWhereInput;
  OR?: PostTagSubscriptionWhereInput[] | PostTagSubscriptionWhereInput;
  NOT?: PostTagSubscriptionWhereInput[] | PostTagSubscriptionWhereInput;
}

export interface PostScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  imageSrc?: String;
  imageSrc_not?: String;
  imageSrc_in?: String[] | String;
  imageSrc_not_in?: String[] | String;
  imageSrc_lt?: String;
  imageSrc_lte?: String;
  imageSrc_gt?: String;
  imageSrc_gte?: String;
  imageSrc_contains?: String;
  imageSrc_not_contains?: String;
  imageSrc_starts_with?: String;
  imageSrc_not_starts_with?: String;
  imageSrc_ends_with?: String;
  imageSrc_not_ends_with?: String;
  likes?: Int;
  likes_not?: Int;
  likes_in?: Int[] | Int;
  likes_not_in?: Int[] | Int;
  likes_lt?: Int;
  likes_lte?: Int;
  likes_gt?: Int;
  likes_gte?: Int;
  AND?: PostScalarWhereInput[] | PostScalarWhereInput;
  OR?: PostScalarWhereInput[] | PostScalarWhereInput;
  NOT?: PostScalarWhereInput[] | PostScalarWhereInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  role?: Role;
  profile?: ProfileUpdateOneWithoutUserInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  postLikes?: PostUpdateManyWithoutLikedByInput;
  projects?: ProjectUpdateManyWithoutAuthorInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
}

export interface PostUpdateManyDataInput {
  slug?: String;
  isPublished?: Boolean;
  imageSrc?: String;
  likes?: Int;
}

export interface ProjectTagUpsertWithWhereUniqueWithoutLanguageInput {
  where: ProjectTagWhereUniqueInput;
  update: ProjectTagUpdateWithoutLanguageDataInput;
  create: ProjectTagCreateWithoutLanguageInput;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface ProjectTagUpdateManyWithoutLanguageInput {
  create?:
    | ProjectTagCreateWithoutLanguageInput[]
    | ProjectTagCreateWithoutLanguageInput;
  delete?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
  connect?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
  set?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
  disconnect?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
  update?:
    | ProjectTagUpdateWithWhereUniqueWithoutLanguageInput[]
    | ProjectTagUpdateWithWhereUniqueWithoutLanguageInput;
  upsert?:
    | ProjectTagUpsertWithWhereUniqueWithoutLanguageInput[]
    | ProjectTagUpsertWithWhereUniqueWithoutLanguageInput;
  deleteMany?: ProjectTagScalarWhereInput[] | ProjectTagScalarWhereInput;
  updateMany?:
    | ProjectTagUpdateManyWithWhereNestedInput[]
    | ProjectTagUpdateManyWithWhereNestedInput;
}

export interface PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput;
  create: PostCreateWithoutCommentsInput;
}

export interface ProjectTagCreateManyWithoutLanguageInput {
  create?:
    | ProjectTagCreateWithoutLanguageInput[]
    | ProjectTagCreateWithoutLanguageInput;
  connect?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
}

export interface CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutAuthorDataInput;
  create: CommentCreateWithoutAuthorInput;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface UserUpsertWithWhereUniqueWithoutPostLikesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutPostLikesDataInput;
  create: UserCreateWithoutPostLikesInput;
}

export type PostTagLngWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface UserScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface ProjectTagContentCreateInput {
  id?: UUID;
  tag: ProjectTagCreateOneWithoutContentsInput;
  title?: String;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface ProjectLngUpdateManyMutationInput {
  country?: String;
  locale?: String;
}

export interface UserUpdateManyDataInput {
  name?: String;
  email?: String;
  password?: String;
  role?: Role;
}

export interface ProjectContentUpdateWithWhereUniqueWithoutLanguageInput {
  where: ProjectContentWhereUniqueInput;
  data: ProjectContentUpdateWithoutLanguageDataInput;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface ProjectContentCreateWithoutLanguageInput {
  id?: UUID;
  project: ProjectCreateOneWithoutContentsInput;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive?: Boolean;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface ProjectImageLngUpdateManyMutationInput {
  country?: String;
  locale?: String;
}

export interface PostCreateInput {
  id?: UUID;
  author: UserCreateOneWithoutPostsInput;
  slug: String;
  isPublished?: Boolean;
  imageSrc: String;
  contents?: PostContentCreateManyWithoutPostInput;
  tags?: PostTagCreateManyInput;
  comments?: CommentCreateManyWithoutPostInput;
  likes?: Int;
  likedBy?: UserCreateManyWithoutPostLikesInput;
}

export type ProjectCategoryContentWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface PostUpdateInput {
  author?: UserUpdateOneRequiredWithoutPostsInput;
  slug?: String;
  isPublished?: Boolean;
  imageSrc?: String;
  contents?: PostContentUpdateManyWithoutPostInput;
  tags?: PostTagUpdateManyInput;
  comments?: CommentUpdateManyWithoutPostInput;
  likes?: Int;
  likedBy?: UserUpdateManyWithoutPostLikesInput;
}

export type ProjectCategoryLngWhereUniqueInput = AtLeastOne<{
  id: UUID;
  country?: String;
  locale?: String;
}>;

export interface PostUpdateManyMutationInput {
  slug?: String;
  isPublished?: Boolean;
  imageSrc?: String;
  likes?: Int;
}

export interface ProjectImageContentCreateManyWithoutLanguageInput {
  create?:
    | ProjectImageContentCreateWithoutLanguageInput[]
    | ProjectImageContentCreateWithoutLanguageInput;
  connect?:
    | ProjectImageContentWhereUniqueInput[]
    | ProjectImageContentWhereUniqueInput;
}

export interface PostContentCreateInput {
  id?: UUID;
  language: PostLngCreateOneWithoutPostsInput;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt: String;
  post: PostCreateOneWithoutContentsInput;
}

export interface ProjectImageUpsertWithoutContentsInput {
  update: ProjectImageUpdateWithoutContentsDataInput;
  create: ProjectImageCreateWithoutContentsInput;
}

export interface PostCreateOneWithoutContentsInput {
  create?: PostCreateWithoutContentsInput;
  connect?: PostWhereUniqueInput;
}

export interface ProjectImageContentUpdateInput {
  image?: ProjectImageUpdateOneRequiredWithoutContentsInput;
  language?: ProjectImageLngUpdateOneRequiredWithoutImagesInput;
  alt?: String;
}

export interface PostCreateWithoutContentsInput {
  id?: UUID;
  author: UserCreateOneWithoutPostsInput;
  slug: String;
  isPublished?: Boolean;
  imageSrc: String;
  tags?: PostTagCreateManyInput;
  comments?: CommentCreateManyWithoutPostInput;
  likes?: Int;
  likedBy?: UserCreateManyWithoutPostLikesInput;
}

export interface ProjectImageContentCreateInput {
  id?: UUID;
  image: ProjectImageCreateOneWithoutContentsInput;
  language: ProjectImageLngCreateOneWithoutImagesInput;
  alt: String;
}

export interface PostContentUpdateInput {
  language?: PostLngUpdateOneRequiredWithoutPostsInput;
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt?: String;
  post?: PostUpdateOneRequiredWithoutContentsInput;
}

export interface ProjectAlbumUpdateWithoutImagesDataInput {
  project?: ProjectUpdateOneRequiredWithoutAlbumInput;
}

export interface PostUpdateOneRequiredWithoutContentsInput {
  create?: PostCreateWithoutContentsInput;
  update?: PostUpdateWithoutContentsDataInput;
  upsert?: PostUpsertWithoutContentsInput;
  connect?: PostWhereUniqueInput;
}

export interface ProjectImageUpdateInput {
  album?: ProjectAlbumUpdateOneRequiredWithoutImagesInput;
  publicId?: String;
  src?: String;
  contents?: ProjectImageContentUpdateOneRequiredWithoutImageInput;
}

export interface PostUpdateWithoutContentsDataInput {
  author?: UserUpdateOneRequiredWithoutPostsInput;
  slug?: String;
  isPublished?: Boolean;
  imageSrc?: String;
  tags?: PostTagUpdateManyInput;
  comments?: CommentUpdateManyWithoutPostInput;
  likes?: Int;
  likedBy?: UserUpdateManyWithoutPostLikesInput;
}

export interface ProjectImageCreateInput {
  id?: UUID;
  album: ProjectAlbumCreateOneWithoutImagesInput;
  publicId: String;
  src: String;
  contents: ProjectImageContentCreateOneWithoutImageInput;
}

export interface PostUpsertWithoutContentsInput {
  update: PostUpdateWithoutContentsDataInput;
  create: PostCreateWithoutContentsInput;
}

export interface ProjectUpdateWithoutContentsDataInput {
  slug?: String;
  category?: ProjectCategoryUpdateOneRequiredWithoutProjectsInput;
  author?: UserUpdateOneRequiredWithoutProjectsInput;
  album?: ProjectAlbumUpdateOneRequiredWithoutProjectInput;
  tags?: ProjectTagUpdateManyInput;
}

export interface PostContentUpdateManyMutationInput {
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt?: String;
}

export type ProjectTagLngWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface PostLngCreateInput {
  id?: UUID;
  posts?: PostContentCreateManyWithoutLanguageInput;
  country: String;
  locale?: String;
}

export interface ProjectCategoryContentUpsertWithWhereUniqueWithoutLanguageInput {
  where: ProjectCategoryContentWhereUniqueInput;
  update: ProjectCategoryContentUpdateWithoutLanguageDataInput;
  create: ProjectCategoryContentCreateWithoutLanguageInput;
}

export interface PostContentCreateManyWithoutLanguageInput {
  create?:
    | PostContentCreateWithoutLanguageInput[]
    | PostContentCreateWithoutLanguageInput;
  connect?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
}

export interface ProjectCategoryContentUpdateManyWithoutLanguageInput {
  create?:
    | ProjectCategoryContentCreateWithoutLanguageInput[]
    | ProjectCategoryContentCreateWithoutLanguageInput;
  delete?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
  connect?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
  set?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
  disconnect?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
  update?:
    | ProjectCategoryContentUpdateWithWhereUniqueWithoutLanguageInput[]
    | ProjectCategoryContentUpdateWithWhereUniqueWithoutLanguageInput;
  upsert?:
    | ProjectCategoryContentUpsertWithWhereUniqueWithoutLanguageInput[]
    | ProjectCategoryContentUpsertWithWhereUniqueWithoutLanguageInput;
  deleteMany?:
    | ProjectCategoryContentScalarWhereInput[]
    | ProjectCategoryContentScalarWhereInput;
  updateMany?:
    | ProjectCategoryContentUpdateManyWithWhereNestedInput[]
    | ProjectCategoryContentUpdateManyWithWhereNestedInput;
}

export interface PostContentCreateWithoutLanguageInput {
  id?: UUID;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt: String;
  post: PostCreateOneWithoutContentsInput;
}

export interface AvatarUpdateInput {
  publicId?: String;
  src?: String;
}

export interface PostLngUpdateInput {
  posts?: PostContentUpdateManyWithoutLanguageInput;
  country?: String;
  locale?: String;
}

export interface CommentCreateInput {
  id?: UUID;
  author: UserCreateOneWithoutCommentsInput;
  post: PostCreateOneWithoutCommentsInput;
}

export interface PostContentUpdateManyWithoutLanguageInput {
  create?:
    | PostContentCreateWithoutLanguageInput[]
    | PostContentCreateWithoutLanguageInput;
  delete?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
  connect?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
  set?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
  disconnect?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
  update?:
    | PostContentUpdateWithWhereUniqueWithoutLanguageInput[]
    | PostContentUpdateWithWhereUniqueWithoutLanguageInput;
  upsert?:
    | PostContentUpsertWithWhereUniqueWithoutLanguageInput[]
    | PostContentUpsertWithWhereUniqueWithoutLanguageInput;
  deleteMany?: PostContentScalarWhereInput[] | PostContentScalarWhereInput;
  updateMany?:
    | PostContentUpdateManyWithWhereNestedInput[]
    | PostContentUpdateManyWithWhereNestedInput;
}

export interface ProfileCreateWithoutUserInput {
  id?: UUID;
  bio: String;
  avatar: AvatarCreateOneInput;
}

export interface PostContentUpdateWithWhereUniqueWithoutLanguageInput {
  where: PostContentWhereUniqueInput;
  data: PostContentUpdateWithoutLanguageDataInput;
}

export interface PostContentCreateManyWithoutPostInput {
  create?:
    | PostContentCreateWithoutPostInput[]
    | PostContentCreateWithoutPostInput;
  connect?: PostContentWhereUniqueInput[] | PostContentWhereUniqueInput;
}

export interface PostContentUpdateWithoutLanguageDataInput {
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt?: String;
  post?: PostUpdateOneRequiredWithoutContentsInput;
}

export interface PostTagCreateManyInput {
  create?: PostTagCreateInput[] | PostTagCreateInput;
  connect?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
}

export interface PostContentUpsertWithWhereUniqueWithoutLanguageInput {
  where: PostContentWhereUniqueInput;
  update: PostContentUpdateWithoutLanguageDataInput;
  create: PostContentCreateWithoutLanguageInput;
}

export interface PostTagContentCreateOneWithoutTagInput {
  create?: PostTagContentCreateWithoutTagInput;
  connect?: PostTagContentWhereUniqueInput;
}

export interface PostLngUpdateManyMutationInput {
  country?: String;
  locale?: String;
}

export interface UserCreateManyWithoutPostLikesInput {
  create?: UserCreateWithoutPostLikesInput[] | UserCreateWithoutPostLikesInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface PostTagUpdateInput {
  color?: String;
  language?: PostTagLngUpdateOneRequiredWithoutTagsInput;
  contents?: PostTagContentUpdateOneRequiredWithoutTagInput;
}

export interface ProjectCategoryCreateOneWithoutProjectsInput {
  create?: ProjectCategoryCreateWithoutProjectsInput;
  connect?: ProjectCategoryWhereUniqueInput;
}

export interface PostTagUpdateManyMutationInput {
  color?: String;
}

export interface ProjectCategoryLngCreateOneWithoutCategoriesInput {
  create?: ProjectCategoryLngCreateWithoutCategoriesInput;
  connect?: ProjectCategoryLngWhereUniqueInput;
}

export interface PostTagContentCreateInput {
  id?: UUID;
  tag: PostTagCreateOneWithoutContentsInput;
  title: String;
}

export interface ProjectImageCreateManyWithoutAlbumInput {
  create?:
    | ProjectImageCreateWithoutAlbumInput[]
    | ProjectImageCreateWithoutAlbumInput;
  connect?: ProjectImageWhereUniqueInput[] | ProjectImageWhereUniqueInput;
}

export interface PostTagCreateOneWithoutContentsInput {
  create?: PostTagCreateWithoutContentsInput;
  connect?: PostTagWhereUniqueInput;
}

export interface ProjectImageLngCreateOneWithoutImagesInput {
  create?: ProjectImageLngCreateWithoutImagesInput;
  connect?: ProjectImageLngWhereUniqueInput;
}

export interface PostTagCreateWithoutContentsInput {
  id?: UUID;
  color: String;
  language: PostTagLngCreateOneWithoutTagsInput;
}

export interface ProjectLngCreateOneWithoutProjectsInput {
  create?: ProjectLngCreateWithoutProjectsInput;
  connect?: ProjectLngWhereUniqueInput;
}

export interface PostTagContentUpdateInput {
  tag?: PostTagUpdateOneRequiredWithoutContentsInput;
  title?: String;
}

export interface ProjectTagLngCreateOneWithoutTagsInput {
  create?: ProjectTagLngCreateWithoutTagsInput;
  connect?: ProjectTagLngWhereUniqueInput;
}

export interface PostTagUpdateOneRequiredWithoutContentsInput {
  create?: PostTagCreateWithoutContentsInput;
  update?: PostTagUpdateWithoutContentsDataInput;
  upsert?: PostTagUpsertWithoutContentsInput;
  connect?: PostTagWhereUniqueInput;
}

export interface CommentCreateManyWithoutAuthorInput {
  create?: CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface PostTagUpdateWithoutContentsDataInput {
  color?: String;
  language?: PostTagLngUpdateOneRequiredWithoutTagsInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface PostTagUpsertWithoutContentsInput {
  update: PostTagUpdateWithoutContentsDataInput;
  create: PostTagCreateWithoutContentsInput;
}

export interface CommentUpdateInput {
  author?: UserUpdateOneRequiredWithoutCommentsInput;
  post?: PostUpdateOneRequiredWithoutCommentsInput;
}

export interface PostTagContentUpdateManyMutationInput {
  title?: String;
}

export interface ProfileUpdateWithoutUserDataInput {
  bio?: String;
  avatar?: AvatarUpdateOneRequiredInput;
}

export interface PostTagLngCreateInput {
  id?: UUID;
  tags?: PostTagCreateManyWithoutLanguageInput;
  country: String;
  locale: String;
}

export interface ProjectCategoryLngWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  categories_every?: ProjectCategoryContentWhereInput;
  categories_some?: ProjectCategoryContentWhereInput;
  categories_none?: ProjectCategoryContentWhereInput;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  locale?: String;
  locale_not?: String;
  locale_in?: String[] | String;
  locale_not_in?: String[] | String;
  locale_lt?: String;
  locale_lte?: String;
  locale_gt?: String;
  locale_gte?: String;
  locale_contains?: String;
  locale_not_contains?: String;
  locale_starts_with?: String;
  locale_not_starts_with?: String;
  locale_ends_with?: String;
  locale_not_ends_with?: String;
  AND?: ProjectCategoryLngWhereInput[] | ProjectCategoryLngWhereInput;
  OR?: ProjectCategoryLngWhereInput[] | ProjectCategoryLngWhereInput;
  NOT?: ProjectCategoryLngWhereInput[] | ProjectCategoryLngWhereInput;
}

export interface PostTagCreateManyWithoutLanguageInput {
  create?:
    | PostTagCreateWithoutLanguageInput[]
    | PostTagCreateWithoutLanguageInput;
  connect?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
}

export interface ProjectImageContentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectImageContentWhereInput;
  AND?:
    | ProjectImageContentSubscriptionWhereInput[]
    | ProjectImageContentSubscriptionWhereInput;
  OR?:
    | ProjectImageContentSubscriptionWhereInput[]
    | ProjectImageContentSubscriptionWhereInput;
  NOT?:
    | ProjectImageContentSubscriptionWhereInput[]
    | ProjectImageContentSubscriptionWhereInput;
}

export interface PostTagCreateWithoutLanguageInput {
  id?: UUID;
  color: String;
  contents: PostTagContentCreateOneWithoutTagInput;
}

export interface ProjectAlbumSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectAlbumWhereInput;
  AND?:
    | ProjectAlbumSubscriptionWhereInput[]
    | ProjectAlbumSubscriptionWhereInput;
  OR?:
    | ProjectAlbumSubscriptionWhereInput[]
    | ProjectAlbumSubscriptionWhereInput;
  NOT?:
    | ProjectAlbumSubscriptionWhereInput[]
    | ProjectAlbumSubscriptionWhereInput;
}

export interface PostTagLngUpdateInput {
  tags?: PostTagUpdateManyWithoutLanguageInput;
  country?: String;
  locale?: String;
}

export interface PostContentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostContentWhereInput;
  AND?: PostContentSubscriptionWhereInput[] | PostContentSubscriptionWhereInput;
  OR?: PostContentSubscriptionWhereInput[] | PostContentSubscriptionWhereInput;
  NOT?: PostContentSubscriptionWhereInput[] | PostContentSubscriptionWhereInput;
}

export interface PostTagUpdateManyWithoutLanguageInput {
  create?:
    | PostTagCreateWithoutLanguageInput[]
    | PostTagCreateWithoutLanguageInput;
  delete?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
  connect?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
  set?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
  disconnect?: PostTagWhereUniqueInput[] | PostTagWhereUniqueInput;
  update?:
    | PostTagUpdateWithWhereUniqueWithoutLanguageInput[]
    | PostTagUpdateWithWhereUniqueWithoutLanguageInput;
  upsert?:
    | PostTagUpsertWithWhereUniqueWithoutLanguageInput[]
    | PostTagUpsertWithWhereUniqueWithoutLanguageInput;
  deleteMany?: PostTagScalarWhereInput[] | PostTagScalarWhereInput;
  updateMany?:
    | PostTagUpdateManyWithWhereNestedInput[]
    | PostTagUpdateManyWithWhereNestedInput;
}

export type PostContentWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface PostTagUpdateWithWhereUniqueWithoutLanguageInput {
  where: PostTagWhereUniqueInput;
  data: PostTagUpdateWithoutLanguageDataInput;
}

export interface ProjectTagCreateWithoutLanguageInput {
  id?: UUID;
  contents: ProjectTagContentCreateOneWithoutTagInput;
  title: String;
  color?: String;
}

export interface PostTagUpdateWithoutLanguageDataInput {
  color?: String;
  contents?: PostTagContentUpdateOneRequiredWithoutTagInput;
}

export interface ProjectTagUpdateWithoutContentsDataInput {
  language?: ProjectTagLngUpdateOneRequiredWithoutTagsInput;
  title?: String;
  color?: String;
}

export interface PostTagUpsertWithWhereUniqueWithoutLanguageInput {
  where: PostTagWhereUniqueInput;
  update: PostTagUpdateWithoutLanguageDataInput;
  create: PostTagCreateWithoutLanguageInput;
}

export interface ProjectTagUpdateManyMutationInput {
  title?: String;
  color?: String;
}

export interface PostTagLngUpdateManyMutationInput {
  country?: String;
  locale?: String;
}

export type ProjectAlbumWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ProfileCreateInput {
  id?: UUID;
  user: UserCreateOneWithoutProfileInput;
  bio: String;
  avatar: AvatarCreateOneInput;
}

export interface ProjectImageContentUpdateManyWithWhereNestedInput {
  where: ProjectImageContentScalarWhereInput;
  data: ProjectImageContentUpdateManyDataInput;
}

export interface UserCreateOneWithoutProfileInput {
  create?: UserCreateWithoutProfileInput;
  connect?: UserWhereUniqueInput;
}

export interface ProjectImageLngUpdateInput {
  images?: ProjectImageContentUpdateManyWithoutLanguageInput;
  country?: String;
  locale?: String;
}

export interface UserCreateWithoutProfileInput {
  id?: UUID;
  name: String;
  email?: String;
  password: String;
  role?: Role;
  posts?: PostCreateManyWithoutAuthorInput;
  postLikes?: PostCreateManyWithoutLikedByInput;
  projects?: ProjectCreateManyWithoutAuthorInput;
  comments?: CommentCreateManyWithoutAuthorInput;
}

export interface ProjectImageUpdateWithoutContentsDataInput {
  album?: ProjectAlbumUpdateOneRequiredWithoutImagesInput;
  publicId?: String;
  src?: String;
}

export interface ProfileUpdateInput {
  user?: UserUpdateOneRequiredWithoutProfileInput;
  bio?: String;
  avatar?: AvatarUpdateOneRequiredInput;
}

export interface ProjectImageUpdateManyMutationInput {
  publicId?: String;
  src?: String;
}

export interface UserUpdateOneRequiredWithoutProfileInput {
  create?: UserCreateWithoutProfileInput;
  update?: UserUpdateWithoutProfileDataInput;
  upsert?: UserUpsertWithoutProfileInput;
  connect?: UserWhereUniqueInput;
}

export interface ProjectAlbumCreateOneWithoutImagesInput {
  create?: ProjectAlbumCreateWithoutImagesInput;
  connect?: ProjectAlbumWhereUniqueInput;
}

export interface UserUpdateWithoutProfileDataInput {
  name?: String;
  email?: String;
  password?: String;
  role?: Role;
  posts?: PostUpdateManyWithoutAuthorInput;
  postLikes?: PostUpdateManyWithoutLikedByInput;
  projects?: ProjectUpdateManyWithoutAuthorInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
}

export interface ProjectContentUpdateInput {
  project?: ProjectUpdateOneRequiredWithoutContentsInput;
  language?: ProjectLngUpdateOneRequiredWithoutProjectsInput;
  title?: String;
  text?: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive?: Boolean;
}

export interface UserUpsertWithoutProfileInput {
  update: UserUpdateWithoutProfileDataInput;
  create: UserCreateWithoutProfileInput;
}

export interface ProjectCategoryContentUpdateWithoutLanguageDataInput {
  category?: ProjectCategoryUpdateOneRequiredWithoutContentsInput;
  title?: String;
  text?: String;
  imageAlt?: String;
  metaTitle?: String;
  metaDescription?: String;
}

export interface ProfileUpdateManyMutationInput {
  bio?: String;
}

export interface ProjectCategoryContentCreateWithoutLanguageInput {
  id?: UUID;
  category: ProjectCategoryCreateOneWithoutContentsInput;
  title: String;
  text: String;
  imageAlt: String;
  metaTitle?: String;
  metaDescription?: String;
}

export interface ProjectCreateInput {
  id?: UUID;
  slug: String;
  category: ProjectCategoryCreateOneWithoutProjectsInput;
  author: UserCreateOneWithoutProjectsInput;
  album: ProjectAlbumCreateOneWithoutProjectInput;
  contents?: ProjectContentCreateManyWithoutProjectInput;
  tags?: ProjectTagCreateManyInput;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface UserCreateOneWithoutProjectsInput {
  create?: UserCreateWithoutProjectsInput;
  connect?: UserWhereUniqueInput;
}

export interface PostTagLngCreateOneWithoutTagsInput {
  create?: PostTagLngCreateWithoutTagsInput;
  connect?: PostTagLngWhereUniqueInput;
}

export interface UserCreateWithoutProjectsInput {
  id?: UUID;
  name: String;
  email?: String;
  password: String;
  role?: Role;
  profile?: ProfileCreateOneWithoutUserInput;
  posts?: PostCreateManyWithoutAuthorInput;
  postLikes?: PostCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
}

export interface ProjectCreateManyWithoutAuthorInput {
  create?: ProjectCreateWithoutAuthorInput[] | ProjectCreateWithoutAuthorInput;
  connect?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
}

export interface ProjectUpdateInput {
  slug?: String;
  category?: ProjectCategoryUpdateOneRequiredWithoutProjectsInput;
  author?: UserUpdateOneRequiredWithoutProjectsInput;
  album?: ProjectAlbumUpdateOneRequiredWithoutProjectInput;
  contents?: ProjectContentUpdateManyWithoutProjectInput;
  tags?: ProjectTagUpdateManyInput;
}

export interface ProjectAlbumCreateOneWithoutProjectInput {
  create?: ProjectAlbumCreateWithoutProjectInput;
  connect?: ProjectAlbumWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutProjectsInput {
  create?: UserCreateWithoutProjectsInput;
  update?: UserUpdateWithoutProjectsDataInput;
  upsert?: UserUpsertWithoutProjectsInput;
  connect?: UserWhereUniqueInput;
}

export interface ProjectContentCreateManyWithoutProjectInput {
  create?:
    | ProjectContentCreateWithoutProjectInput[]
    | ProjectContentCreateWithoutProjectInput;
  connect?: ProjectContentWhereUniqueInput[] | ProjectContentWhereUniqueInput;
}

export interface UserUpdateWithoutProjectsDataInput {
  name?: String;
  email?: String;
  password?: String;
  role?: Role;
  profile?: ProfileUpdateOneWithoutUserInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  postLikes?: PostUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
}

export interface ProjectTagContentCreateOneWithoutTagInput {
  create?: ProjectTagContentCreateWithoutTagInput;
  connect?: ProjectTagContentWhereUniqueInput;
}

export interface UserUpsertWithoutProjectsInput {
  update: UserUpdateWithoutProjectsDataInput;
  create: UserCreateWithoutProjectsInput;
}

export interface PostCreateManyWithoutLikedByInput {
  create?: PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface ProjectUpdateManyMutationInput {
  slug?: String;
}

export interface AvatarUpdateDataInput {
  publicId?: String;
  src?: String;
}

export interface ProjectAlbumCreateInput {
  id?: UUID;
  project: ProjectCreateOneWithoutAlbumInput;
  images?: ProjectImageCreateManyWithoutAlbumInput;
}

export interface ProjectCategoryLngSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectCategoryLngWhereInput;
  AND?:
    | ProjectCategoryLngSubscriptionWhereInput[]
    | ProjectCategoryLngSubscriptionWhereInput;
  OR?:
    | ProjectCategoryLngSubscriptionWhereInput[]
    | ProjectCategoryLngSubscriptionWhereInput;
  NOT?:
    | ProjectCategoryLngSubscriptionWhereInput[]
    | ProjectCategoryLngSubscriptionWhereInput;
}

export interface ProjectCreateOneWithoutAlbumInput {
  create?: ProjectCreateWithoutAlbumInput;
  connect?: ProjectWhereUniqueInput;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: UUID;
  slug?: String;
}>;

export interface ProjectCreateWithoutAlbumInput {
  id?: UUID;
  slug: String;
  category: ProjectCategoryCreateOneWithoutProjectsInput;
  author: UserCreateOneWithoutProjectsInput;
  contents?: ProjectContentCreateManyWithoutProjectInput;
  tags?: ProjectTagCreateManyInput;
}

export interface ProjectTagContentUpdateManyMutationInput {
  title?: String;
}

export interface ProjectAlbumUpdateInput {
  project?: ProjectUpdateOneRequiredWithoutAlbumInput;
  images?: ProjectImageUpdateManyWithoutAlbumInput;
}

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: UUID;
  slug?: String;
}>;

export interface ProjectUpdateOneRequiredWithoutAlbumInput {
  create?: ProjectCreateWithoutAlbumInput;
  update?: ProjectUpdateWithoutAlbumDataInput;
  upsert?: ProjectUpsertWithoutAlbumInput;
  connect?: ProjectWhereUniqueInput;
}

export interface ProjectImageContentUpdateWithoutLanguageDataInput {
  image?: ProjectImageUpdateOneRequiredWithoutContentsInput;
  alt?: String;
}

export interface ProjectUpdateWithoutAlbumDataInput {
  slug?: String;
  category?: ProjectCategoryUpdateOneRequiredWithoutProjectsInput;
  author?: UserUpdateOneRequiredWithoutProjectsInput;
  contents?: ProjectContentUpdateManyWithoutProjectInput;
  tags?: ProjectTagUpdateManyInput;
}

export interface ProjectImageCreateWithoutContentsInput {
  id?: UUID;
  album: ProjectAlbumCreateOneWithoutImagesInput;
  publicId: String;
  src: String;
}

export interface ProjectUpsertWithoutAlbumInput {
  update: ProjectUpdateWithoutAlbumDataInput;
  create: ProjectCreateWithoutAlbumInput;
}

export interface ProjectUpsertWithoutContentsInput {
  update: ProjectUpdateWithoutContentsDataInput;
  create: ProjectCreateWithoutContentsInput;
}

export interface ProjectCategoryCreateInput {
  id?: UUID;
  contents?: ProjectCategoryContentCreateManyWithoutCategoryInput;
  slug: String;
  image: String;
  projects?: ProjectCreateManyWithoutCategoryInput;
}

export interface PostLngCreateOneWithoutPostsInput {
  create?: PostLngCreateWithoutPostsInput;
  connect?: PostLngWhereUniqueInput;
}

export interface ProjectCreateManyWithoutCategoryInput {
  create?:
    | ProjectCreateWithoutCategoryInput[]
    | ProjectCreateWithoutCategoryInput;
  connect?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
}

export interface ProjectCategoryContentCreateManyWithoutCategoryInput {
  create?:
    | ProjectCategoryContentCreateWithoutCategoryInput[]
    | ProjectCategoryContentCreateWithoutCategoryInput;
  connect?:
    | ProjectCategoryContentWhereUniqueInput[]
    | ProjectCategoryContentWhereUniqueInput;
}

export interface ProjectCreateWithoutCategoryInput {
  id?: UUID;
  slug: String;
  author: UserCreateOneWithoutProjectsInput;
  album: ProjectAlbumCreateOneWithoutProjectInput;
  contents?: ProjectContentCreateManyWithoutProjectInput;
  tags?: ProjectTagCreateManyInput;
}

export interface ProjectTagCreateManyInput {
  create?: ProjectTagCreateInput[] | ProjectTagCreateInput;
  connect?: ProjectTagWhereUniqueInput[] | ProjectTagWhereUniqueInput;
}

export interface ProjectCategoryUpdateInput {
  contents?: ProjectCategoryContentUpdateManyWithoutCategoryInput;
  slug?: String;
  image?: String;
  projects?: ProjectUpdateManyWithoutCategoryInput;
}

export interface UserUpdateWithoutCommentsDataInput {
  name?: String;
  email?: String;
  password?: String;
  role?: Role;
  profile?: ProfileUpdateOneWithoutUserInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  postLikes?: PostUpdateManyWithoutLikedByInput;
  projects?: ProjectUpdateManyWithoutAuthorInput;
}

export interface ProjectUpdateManyWithoutCategoryInput {
  create?:
    | ProjectCreateWithoutCategoryInput[]
    | ProjectCreateWithoutCategoryInput;
  delete?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  connect?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  set?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  disconnect?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  update?:
    | ProjectUpdateWithWhereUniqueWithoutCategoryInput[]
    | ProjectUpdateWithWhereUniqueWithoutCategoryInput;
  upsert?:
    | ProjectUpsertWithWhereUniqueWithoutCategoryInput[]
    | ProjectUpsertWithWhereUniqueWithoutCategoryInput;
  deleteMany?: ProjectScalarWhereInput[] | ProjectScalarWhereInput;
  updateMany?:
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput;
}

export interface PostTagLngSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostTagLngWhereInput;
  AND?: PostTagLngSubscriptionWhereInput[] | PostTagLngSubscriptionWhereInput;
  OR?: PostTagLngSubscriptionWhereInput[] | PostTagLngSubscriptionWhereInput;
  NOT?: PostTagLngSubscriptionWhereInput[] | PostTagLngSubscriptionWhereInput;
}

export interface ProjectUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutCategoryDataInput;
}

export interface ProjectTagCreateWithoutContentsInput {
  id?: UUID;
  language: ProjectTagLngCreateOneWithoutTagsInput;
  title: String;
  color?: String;
}

export interface ProjectUpdateWithoutCategoryDataInput {
  slug?: String;
  author?: UserUpdateOneRequiredWithoutProjectsInput;
  album?: ProjectAlbumUpdateOneRequiredWithoutProjectInput;
  contents?: ProjectContentUpdateManyWithoutProjectInput;
  tags?: ProjectTagUpdateManyInput;
}

export interface ProjectImageLngCreateInput {
  id?: UUID;
  images?: ProjectImageContentCreateManyWithoutLanguageInput;
  country: String;
  locale?: String;
}

export interface ProjectUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutCategoryDataInput;
  create: ProjectCreateWithoutCategoryInput;
}

export interface ProjectContentCreateInput {
  id?: UUID;
  project: ProjectCreateOneWithoutContentsInput;
  language: ProjectLngCreateOneWithoutProjectsInput;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive?: Boolean;
}

export interface ProjectCategoryUpdateManyMutationInput {
  slug?: String;
  image?: String;
}

export interface CommentCreateManyWithoutPostInput {
  create?: CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface ProjectCategoryContentCreateInput {
  id?: UUID;
  category: ProjectCategoryCreateOneWithoutContentsInput;
  language: ProjectCategoryLngCreateOneWithoutCategoriesInput;
  title: String;
  text: String;
  imageAlt: String;
  metaTitle?: String;
  metaDescription?: String;
}

export interface PostCreateOneWithoutCommentsInput {
  create?: PostCreateWithoutCommentsInput;
  connect?: PostWhereUniqueInput;
}

export interface ProjectCategoryCreateOneWithoutContentsInput {
  create?: ProjectCategoryCreateWithoutContentsInput;
  connect?: ProjectCategoryWhereUniqueInput;
}

export type PostLngWhereUniqueInput = AtLeastOne<{
  id: UUID;
  country?: String;
  locale?: String;
}>;

export interface ProjectCategoryCreateWithoutContentsInput {
  id?: UUID;
  slug: String;
  image: String;
  projects?: ProjectCreateManyWithoutCategoryInput;
}

export type ProjectLngWhereUniqueInput = AtLeastOne<{
  id: UUID;
  country?: String;
  locale?: String;
}>;

export interface ProjectCategoryUpsertWithoutContentsInput {
  update: ProjectCategoryUpdateWithoutContentsDataInput;
  create: ProjectCategoryCreateWithoutContentsInput;
}

export interface ProjectCategoryUpdateWithoutContentsDataInput {
  slug?: String;
  image?: String;
  projects?: ProjectUpdateManyWithoutCategoryInput;
}

export interface ProjectCategoryUpdateOneRequiredWithoutContentsInput {
  create?: ProjectCategoryCreateWithoutContentsInput;
  update?: ProjectCategoryUpdateWithoutContentsDataInput;
  upsert?: ProjectCategoryUpsertWithoutContentsInput;
  connect?: ProjectCategoryWhereUniqueInput;
}

export interface ProjectCategoryContentUpdateInput {
  category?: ProjectCategoryUpdateOneRequiredWithoutContentsInput;
  language?: ProjectCategoryLngUpdateOneRequiredWithoutCategoriesInput;
  title?: String;
  text?: String;
  imageAlt?: String;
  metaTitle?: String;
  metaDescription?: String;
}

export interface UserCreateWithoutCommentsInput {
  id?: UUID;
  name: String;
  email?: String;
  password: String;
  role?: Role;
  profile?: ProfileCreateOneWithoutUserInput;
  posts?: PostCreateManyWithoutAuthorInput;
  postLikes?: PostCreateManyWithoutLikedByInput;
  projects?: ProjectCreateManyWithoutAuthorInput;
}

export interface ProjectLngCreateInput {
  id?: UUID;
  projects?: ProjectContentCreateManyWithoutLanguageInput;
  country: String;
  locale?: String;
}

export interface ProjectCategoryContentWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  category?: ProjectCategoryWhereInput;
  language?: ProjectCategoryLngWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  imageAlt?: String;
  imageAlt_not?: String;
  imageAlt_in?: String[] | String;
  imageAlt_not_in?: String[] | String;
  imageAlt_lt?: String;
  imageAlt_lte?: String;
  imageAlt_gt?: String;
  imageAlt_gte?: String;
  imageAlt_contains?: String;
  imageAlt_not_contains?: String;
  imageAlt_starts_with?: String;
  imageAlt_not_starts_with?: String;
  imageAlt_ends_with?: String;
  imageAlt_not_ends_with?: String;
  metaTitle?: String;
  metaTitle_not?: String;
  metaTitle_in?: String[] | String;
  metaTitle_not_in?: String[] | String;
  metaTitle_lt?: String;
  metaTitle_lte?: String;
  metaTitle_gt?: String;
  metaTitle_gte?: String;
  metaTitle_contains?: String;
  metaTitle_not_contains?: String;
  metaTitle_starts_with?: String;
  metaTitle_not_starts_with?: String;
  metaTitle_ends_with?: String;
  metaTitle_not_ends_with?: String;
  metaDescription?: String;
  metaDescription_not?: String;
  metaDescription_in?: String[] | String;
  metaDescription_not_in?: String[] | String;
  metaDescription_lt?: String;
  metaDescription_lte?: String;
  metaDescription_gt?: String;
  metaDescription_gte?: String;
  metaDescription_contains?: String;
  metaDescription_not_contains?: String;
  metaDescription_starts_with?: String;
  metaDescription_not_starts_with?: String;
  metaDescription_ends_with?: String;
  metaDescription_not_ends_with?: String;
  AND?: ProjectCategoryContentWhereInput[] | ProjectCategoryContentWhereInput;
  OR?: ProjectCategoryContentWhereInput[] | ProjectCategoryContentWhereInput;
  NOT?: ProjectCategoryContentWhereInput[] | ProjectCategoryContentWhereInput;
}

export interface ProjectImageContentCreateOneWithoutImageInput {
  create?: ProjectImageContentCreateWithoutImageInput;
  connect?: ProjectImageContentWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  email?: String;
  password: String;
  role: Role;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Post {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
  isPublished: Boolean;
  imageSrc: String;
  likes?: Int;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  slug: () => Promise<String>;
  isPublished: () => Promise<Boolean>;
  imageSrc: () => Promise<String>;
  contents: <T = FragmentableArray<PostContent>>(
    args?: {
      where?: PostContentWhereInput;
      orderBy?: PostContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<PostTag>>(
    args?: {
      where?: PostTagWhereInput;
      orderBy?: PostTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likes: () => Promise<Int>;
  likedBy: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  slug: () => Promise<AsyncIterator<String>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  imageSrc: () => Promise<AsyncIterator<String>>;
  contents: <T = Promise<AsyncIterator<PostContentSubscription>>>(
    args?: {
      where?: PostContentWhereInput;
      orderBy?: PostContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<PostTagSubscription>>>(
    args?: {
      where?: PostTagWhereInput;
      orderBy?: PostTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likes: () => Promise<AsyncIterator<Int>>;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Avatar {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publicId?: String;
  src?: String;
}

export interface AvatarPromise extends Promise<Avatar>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publicId: () => Promise<String>;
  src: () => Promise<String>;
}

export interface AvatarSubscription
  extends Promise<AsyncIterator<Avatar>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publicId: () => Promise<AsyncIterator<String>>;
  src: () => Promise<AsyncIterator<String>>;
}

export interface ProjectTagLngEdge {
  node: ProjectTagLng;
  cursor: String;
}

export interface ProjectTagLngEdgePromise
  extends Promise<ProjectTagLngEdge>,
    Fragmentable {
  node: <T = ProjectTagLngPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectTagLngEdgeSubscription
  extends Promise<AsyncIterator<ProjectTagLngEdge>>,
    Fragmentable {
  node: <T = ProjectTagLngSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectTagContentPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
}

export interface ProjectTagContentPreviousValuesPromise
  extends Promise<ProjectTagContentPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
}

export interface ProjectTagContentPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectTagContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProjectTagLng {
  count: Int;
}

export interface AggregateProjectTagLngPromise
  extends Promise<AggregateProjectTagLng>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectTagLngSubscription
  extends Promise<AsyncIterator<AggregateProjectTagLng>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AvatarSubscriptionPayload {
  mutation: MutationType;
  node: Avatar;
  updatedFields: String[];
  previousValues: AvatarPreviousValues;
}

export interface AvatarSubscriptionPayloadPromise
  extends Promise<AvatarSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AvatarPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AvatarPreviousValuesPromise>() => T;
}

export interface AvatarSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AvatarSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AvatarSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AvatarPreviousValuesSubscription>() => T;
}

export interface ProjectTagLngConnection {
  pageInfo: PageInfo;
  edges: ProjectTagLngEdge[];
}

export interface ProjectTagLngConnectionPromise
  extends Promise<ProjectTagLngConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectTagLngEdge>>() => T;
  aggregate: <T = AggregateProjectTagLngPromise>() => T;
}

export interface ProjectTagLngConnectionSubscription
  extends Promise<AsyncIterator<ProjectTagLngConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectTagLngEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectTagLngSubscription>() => T;
}

export interface ProjectTagContentConnection {
  pageInfo: PageInfo;
  edges: ProjectTagContentEdge[];
}

export interface ProjectTagContentConnectionPromise
  extends Promise<ProjectTagContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectTagContentEdge>>() => T;
  aggregate: <T = AggregateProjectTagContentPromise>() => T;
}

export interface ProjectTagContentConnectionSubscription
  extends Promise<AsyncIterator<ProjectTagContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectTagContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectTagContentSubscription>() => T;
}

export interface AggregateProjectTagContent {
  count: Int;
}

export interface AggregateProjectTagContentPromise
  extends Promise<AggregateProjectTagContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectTagContentSubscription
  extends Promise<AsyncIterator<AggregateProjectTagContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateProjectTag {
  count: Int;
}

export interface AggregateProjectTagPromise
  extends Promise<AggregateProjectTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectTagSubscription
  extends Promise<AsyncIterator<AggregateProjectTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AvatarPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publicId?: String;
  src?: String;
}

export interface AvatarPreviousValuesPromise
  extends Promise<AvatarPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publicId: () => Promise<String>;
  src: () => Promise<String>;
}

export interface AvatarPreviousValuesSubscription
  extends Promise<AsyncIterator<AvatarPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publicId: () => Promise<AsyncIterator<String>>;
  src: () => Promise<AsyncIterator<String>>;
}

export interface ProjectTagConnection {
  pageInfo: PageInfo;
  edges: ProjectTagEdge[];
}

export interface ProjectTagConnectionPromise
  extends Promise<ProjectTagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectTagEdge>>() => T;
  aggregate: <T = AggregateProjectTagPromise>() => T;
}

export interface ProjectTagConnectionSubscription
  extends Promise<AsyncIterator<ProjectTagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectTagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectTagSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectLngEdge {
  node: ProjectLng;
  cursor: String;
}

export interface ProjectLngEdgePromise
  extends Promise<ProjectLngEdge>,
    Fragmentable {
  node: <T = ProjectLngPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectLngEdgeSubscription
  extends Promise<AsyncIterator<ProjectLngEdge>>,
    Fragmentable {
  node: <T = ProjectLngSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface AggregateProjectImageLng {
  count: Int;
}

export interface AggregateProjectImageLngPromise
  extends Promise<AggregateProjectImageLng>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectImageLngSubscription
  extends Promise<AsyncIterator<AggregateProjectImageLng>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectImageLngConnection {
  pageInfo: PageInfo;
  edges: ProjectImageLngEdge[];
}

export interface ProjectImageLngConnectionPromise
  extends Promise<ProjectImageLngConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectImageLngEdge>>() => T;
  aggregate: <T = AggregateProjectImageLngPromise>() => T;
}

export interface ProjectImageLngConnectionSubscription
  extends Promise<AsyncIterator<ProjectImageLngConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectImageLngEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectImageLngSubscription>() => T;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface AggregateProjectImageContent {
  count: Int;
}

export interface AggregateProjectImageContentPromise
  extends Promise<AggregateProjectImageContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectImageContentSubscription
  extends Promise<AsyncIterator<AggregateProjectImageContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface ProjectImageContentConnection {
  pageInfo: PageInfo;
  edges: ProjectImageContentEdge[];
}

export interface ProjectImageContentConnectionPromise
  extends Promise<ProjectImageContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectImageContentEdge>>() => T;
  aggregate: <T = AggregateProjectImageContentPromise>() => T;
}

export interface ProjectImageContentConnectionSubscription
  extends Promise<AsyncIterator<ProjectImageContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProjectImageContentEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProjectImageContentSubscription>() => T;
}

export interface PostPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
  isPublished: Boolean;
  imageSrc: String;
  likes?: Int;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  slug: () => Promise<String>;
  isPublished: () => Promise<Boolean>;
  imageSrc: () => Promise<String>;
  likes: () => Promise<Int>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  slug: () => Promise<AsyncIterator<String>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  imageSrc: () => Promise<AsyncIterator<String>>;
  likes: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectImageEdge {
  node: ProjectImage;
  cursor: String;
}

export interface ProjectImageEdgePromise
  extends Promise<ProjectImageEdge>,
    Fragmentable {
  node: <T = ProjectImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectImageEdgeSubscription
  extends Promise<AsyncIterator<ProjectImageEdge>>,
    Fragmentable {
  node: <T = ProjectImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectTagContent {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
}

export interface ProjectTagContentPromise
  extends Promise<ProjectTagContent>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  tag: <T = ProjectTagPromise>() => T;
  title: () => Promise<String>;
}

export interface ProjectTagContentSubscription
  extends Promise<AsyncIterator<ProjectTagContent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  tag: <T = ProjectTagSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProjectContent {
  count: Int;
}

export interface AggregateProjectContentPromise
  extends Promise<AggregateProjectContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectContentSubscription
  extends Promise<AsyncIterator<AggregateProjectContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostContentSubscriptionPayload {
  mutation: MutationType;
  node: PostContent;
  updatedFields: String[];
  previousValues: PostContentPreviousValues;
}

export interface PostContentSubscriptionPayloadPromise
  extends Promise<PostContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostContentPreviousValuesPromise>() => T;
}

export interface PostContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostContentPreviousValuesSubscription>() => T;
}

export interface ProjectContentConnection {
  pageInfo: PageInfo;
  edges: ProjectContentEdge[];
}

export interface ProjectContentConnectionPromise
  extends Promise<ProjectContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectContentEdge>>() => T;
  aggregate: <T = AggregateProjectContentPromise>() => T;
}

export interface ProjectContentConnectionSubscription
  extends Promise<AsyncIterator<ProjectContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectContentSubscription>() => T;
}

export interface PostContentPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt: String;
}

export interface PostContentPreviousValuesPromise
  extends Promise<PostContentPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
  imageAlt: () => Promise<String>;
}

export interface PostContentPreviousValuesSubscription
  extends Promise<AsyncIterator<PostContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  imageAlt: () => Promise<AsyncIterator<String>>;
}

export interface ProjectCategoryLngEdge {
  node: ProjectCategoryLng;
  cursor: String;
}

export interface ProjectCategoryLngEdgePromise
  extends Promise<ProjectCategoryLngEdge>,
    Fragmentable {
  node: <T = ProjectCategoryLngPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectCategoryLngEdgeSubscription
  extends Promise<AsyncIterator<ProjectCategoryLngEdge>>,
    Fragmentable {
  node: <T = ProjectCategoryLngSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectTagLng {
  id: UUID;
  country: String;
  locale: String;
}

export interface ProjectTagLngPromise
  extends Promise<ProjectTagLng>,
    Fragmentable {
  id: () => Promise<UUID>;
  tags: <T = FragmentableArray<ProjectTag>>(
    args?: {
      where?: ProjectTagWhereInput;
      orderBy?: ProjectTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface ProjectTagLngSubscription
  extends Promise<AsyncIterator<ProjectTagLng>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  tags: <T = Promise<AsyncIterator<ProjectTagSubscription>>>(
    args?: {
      where?: ProjectTagWhereInput;
      orderBy?: ProjectTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface AvatarConnection {
  pageInfo: PageInfo;
  edges: AvatarEdge[];
}

export interface AvatarConnectionPromise
  extends Promise<AvatarConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AvatarEdge>>() => T;
  aggregate: <T = AggregateAvatarPromise>() => T;
}

export interface AvatarConnectionSubscription
  extends Promise<AsyncIterator<AvatarConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AvatarEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAvatarSubscription>() => T;
}

export interface PostLngSubscriptionPayload {
  mutation: MutationType;
  node: PostLng;
  updatedFields: String[];
  previousValues: PostLngPreviousValues;
}

export interface PostLngSubscriptionPayloadPromise
  extends Promise<PostLngSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostLngPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostLngPreviousValuesPromise>() => T;
}

export interface PostLngSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostLngSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostLngSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostLngPreviousValuesSubscription>() => T;
}

export interface ProjectCategoryContentEdge {
  node: ProjectCategoryContent;
  cursor: String;
}

export interface ProjectCategoryContentEdgePromise
  extends Promise<ProjectCategoryContentEdge>,
    Fragmentable {
  node: <T = ProjectCategoryContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectCategoryContentEdgeSubscription
  extends Promise<AsyncIterator<ProjectCategoryContentEdge>>,
    Fragmentable {
  node: <T = ProjectCategoryContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostLngPreviousValues {
  id: UUID;
  country: String;
  locale?: String;
}

export interface PostLngPreviousValuesPromise
  extends Promise<PostLngPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface PostLngPreviousValuesSubscription
  extends Promise<AsyncIterator<PostLngPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProjectCategory {
  count: Int;
}

export interface AggregateProjectCategoryPromise
  extends Promise<AggregateProjectCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectCategorySubscription
  extends Promise<AsyncIterator<AggregateProjectCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectTag {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  color?: String;
}

export interface ProjectTagPromise extends Promise<ProjectTag>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = ProjectTagLngPromise>() => T;
  contents: <T = ProjectTagContentPromise>() => T;
  title: () => Promise<String>;
  color: () => Promise<String>;
}

export interface ProjectTagSubscription
  extends Promise<AsyncIterator<ProjectTag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  language: <T = ProjectTagLngSubscription>() => T;
  contents: <T = ProjectTagContentSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  color: () => Promise<AsyncIterator<String>>;
}

export interface ProjectCategoryConnection {
  pageInfo: PageInfo;
  edges: ProjectCategoryEdge[];
}

export interface ProjectCategoryConnectionPromise
  extends Promise<ProjectCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectCategoryEdge>>() => T;
  aggregate: <T = AggregateProjectCategoryPromise>() => T;
}

export interface ProjectCategoryConnectionSubscription
  extends Promise<AsyncIterator<ProjectCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectCategorySubscription>() => T;
}

export interface PostTagSubscriptionPayload {
  mutation: MutationType;
  node: PostTag;
  updatedFields: String[];
  previousValues: PostTagPreviousValues;
}

export interface PostTagSubscriptionPayloadPromise
  extends Promise<PostTagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostTagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostTagPreviousValuesPromise>() => T;
}

export interface PostTagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostTagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostTagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostTagPreviousValuesSubscription>() => T;
}

export interface AggregateProjectAlbum {
  count: Int;
}

export interface AggregateProjectAlbumPromise
  extends Promise<AggregateProjectAlbum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectAlbumSubscription
  extends Promise<AsyncIterator<AggregateProjectAlbum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostTagPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  color: String;
}

export interface PostTagPreviousValuesPromise
  extends Promise<PostTagPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  color: () => Promise<String>;
}

export interface PostTagPreviousValuesSubscription
  extends Promise<AsyncIterator<PostTagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  color: () => Promise<AsyncIterator<String>>;
}

export interface ProjectAlbumConnection {
  pageInfo: PageInfo;
  edges: ProjectAlbumEdge[];
}

export interface ProjectAlbumConnectionPromise
  extends Promise<ProjectAlbumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectAlbumEdge>>() => T;
  aggregate: <T = AggregateProjectAlbumPromise>() => T;
}

export interface ProjectAlbumConnectionSubscription
  extends Promise<AsyncIterator<ProjectAlbumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectAlbumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectAlbumSubscription>() => T;
}

export interface User {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  email?: String;
  password: String;
  role: Role;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  profile: <T = ProfilePromise>() => T;
  posts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  postLikes: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  projects: <T = FragmentableArray<Project>>(
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  profile: <T = ProfileSubscription>() => T;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  postLikes: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  projects: <T = Promise<AsyncIterator<ProjectSubscription>>>(
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostTagContentSubscriptionPayload {
  mutation: MutationType;
  node: PostTagContent;
  updatedFields: String[];
  previousValues: PostTagContentPreviousValues;
}

export interface PostTagContentSubscriptionPayloadPromise
  extends Promise<PostTagContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostTagContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostTagContentPreviousValuesPromise>() => T;
}

export interface PostTagContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostTagContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostTagContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostTagContentPreviousValuesSubscription>() => T;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface PostTagContentPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
}

export interface PostTagContentPreviousValuesPromise
  extends Promise<PostTagContentPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
}

export interface PostTagContentPreviousValuesSubscription
  extends Promise<AsyncIterator<PostTagContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface ProfileEdge {
  node: Profile;
  cursor: String;
}

export interface ProfileEdgePromise extends Promise<ProfileEdge>, Fragmentable {
  node: <T = ProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfileEdgeSubscription
  extends Promise<AsyncIterator<ProfileEdge>>,
    Fragmentable {
  node: <T = ProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectLng {
  id: UUID;
  country: String;
  locale?: String;
}

export interface ProjectLngPromise extends Promise<ProjectLng>, Fragmentable {
  id: () => Promise<UUID>;
  projects: <T = FragmentableArray<ProjectContent>>(
    args?: {
      where?: ProjectContentWhereInput;
      orderBy?: ProjectContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface ProjectLngSubscription
  extends Promise<AsyncIterator<ProjectLng>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  projects: <T = Promise<AsyncIterator<ProjectContentSubscription>>>(
    args?: {
      where?: ProjectContentWhereInput;
      orderBy?: ProjectContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface AvatarEdge {
  node: Avatar;
  cursor: String;
}

export interface AvatarEdgePromise extends Promise<AvatarEdge>, Fragmentable {
  node: <T = AvatarPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AvatarEdgeSubscription
  extends Promise<AsyncIterator<AvatarEdge>>,
    Fragmentable {
  node: <T = AvatarSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostTagLngSubscriptionPayload {
  mutation: MutationType;
  node: PostTagLng;
  updatedFields: String[];
  previousValues: PostTagLngPreviousValues;
}

export interface PostTagLngSubscriptionPayloadPromise
  extends Promise<PostTagLngSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostTagLngPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostTagLngPreviousValuesPromise>() => T;
}

export interface PostTagLngSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostTagLngSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostTagLngSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostTagLngPreviousValuesSubscription>() => T;
}

export interface PostTagLngEdge {
  node: PostTagLng;
  cursor: String;
}

export interface PostTagLngEdgePromise
  extends Promise<PostTagLngEdge>,
    Fragmentable {
  node: <T = PostTagLngPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostTagLngEdgeSubscription
  extends Promise<AsyncIterator<PostTagLngEdge>>,
    Fragmentable {
  node: <T = PostTagLngSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostTagLngPreviousValues {
  id: UUID;
  country: String;
  locale: String;
}

export interface PostTagLngPreviousValuesPromise
  extends Promise<PostTagLngPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface PostTagLngPreviousValuesSubscription
  extends Promise<AsyncIterator<PostTagLngPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAvatar {
  count: Int;
}

export interface AggregateAvatarPromise
  extends Promise<AggregateAvatar>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAvatarSubscription
  extends Promise<AsyncIterator<AggregateAvatar>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectContent {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive: Boolean;
}

export interface ProjectContentPromise
  extends Promise<ProjectContent>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  project: <T = ProjectPromise>() => T;
  language: <T = ProjectLngPromise>() => T;
  title: () => Promise<String>;
  text: () => Promise<String>;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
  isActive: () => Promise<Boolean>;
}

export interface ProjectContentSubscription
  extends Promise<AsyncIterator<ProjectContent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  project: <T = ProjectSubscription>() => T;
  language: <T = ProjectLngSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
}

export interface PostTagContentEdge {
  node: PostTagContent;
  cursor: String;
}

export interface PostTagContentEdgePromise
  extends Promise<PostTagContentEdge>,
    Fragmentable {
  node: <T = PostTagContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostTagContentEdgeSubscription
  extends Promise<AsyncIterator<PostTagContentEdge>>,
    Fragmentable {
  node: <T = PostTagContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProfileSubscriptionPayload {
  mutation: MutationType;
  node: Profile;
  updatedFields: String[];
  previousValues: ProfilePreviousValues;
}

export interface ProfileSubscriptionPayloadPromise
  extends Promise<ProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfilePreviousValuesPromise>() => T;
}

export interface ProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfilePreviousValuesSubscription>() => T;
}

export interface AggregatePostTag {
  count: Int;
}

export interface AggregatePostTagPromise
  extends Promise<AggregatePostTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostTagSubscription
  extends Promise<AsyncIterator<AggregatePostTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfilePreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio: String;
}

export interface ProfilePreviousValuesPromise
  extends Promise<ProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
}

export interface ProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<ProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
}

export interface PostTagConnection {
  pageInfo: PageInfo;
  edges: PostTagEdge[];
}

export interface PostTagConnectionPromise
  extends Promise<PostTagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostTagEdge>>() => T;
  aggregate: <T = AggregatePostTagPromise>() => T;
}

export interface PostTagConnectionSubscription
  extends Promise<AsyncIterator<PostTagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostTagEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostTagSubscription>() => T;
}

export interface Profile {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio: String;
}

export interface ProfilePromise extends Promise<Profile>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  bio: () => Promise<String>;
  avatar: <T = AvatarPromise>() => T;
}

export interface ProfileSubscription
  extends Promise<AsyncIterator<Profile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  bio: () => Promise<AsyncIterator<String>>;
  avatar: <T = AvatarSubscription>() => T;
}

export interface PostLngEdge {
  node: PostLng;
  cursor: String;
}

export interface PostLngEdgePromise extends Promise<PostLngEdge>, Fragmentable {
  node: <T = PostLngPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostLngEdgeSubscription
  extends Promise<AsyncIterator<PostLngEdge>>,
    Fragmentable {
  node: <T = PostLngSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface Comment {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  post: <T = PostPromise>() => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  post: <T = PostSubscription>() => T;
}

export interface ProjectPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  slug: () => Promise<String>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  slug: () => Promise<AsyncIterator<String>>;
}

export interface PostContentEdge {
  node: PostContent;
  cursor: String;
}

export interface PostContentEdgePromise
  extends Promise<PostContentEdge>,
    Fragmentable {
  node: <T = PostContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostContentEdgeSubscription
  extends Promise<AsyncIterator<PostContentEdge>>,
    Fragmentable {
  node: <T = PostContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectImageLng {
  id: UUID;
  country: String;
  locale?: String;
}

export interface ProjectImageLngPromise
  extends Promise<ProjectImageLng>,
    Fragmentable {
  id: () => Promise<UUID>;
  images: <T = FragmentableArray<ProjectImageContent>>(
    args?: {
      where?: ProjectImageContentWhereInput;
      orderBy?: ProjectImageContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface ProjectImageLngSubscription
  extends Promise<AsyncIterator<ProjectImageLng>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  images: <T = Promise<AsyncIterator<ProjectImageContentSubscription>>>(
    args?: {
      where?: ProjectImageContentWhereInput;
      orderBy?: ProjectImageContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface ProjectTagLngSubscriptionPayload {
  mutation: MutationType;
  node: ProjectTagLng;
  updatedFields: String[];
  previousValues: ProjectTagLngPreviousValues;
}

export interface ProjectTagLngSubscriptionPayloadPromise
  extends Promise<ProjectTagLngSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectTagLngPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectTagLngPreviousValuesPromise>() => T;
}

export interface ProjectTagLngSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectTagLngSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectTagLngSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectTagLngPreviousValuesSubscription>() => T;
}

export interface ProjectAlbumSubscriptionPayload {
  mutation: MutationType;
  node: ProjectAlbum;
  updatedFields: String[];
  previousValues: ProjectAlbumPreviousValues;
}

export interface ProjectAlbumSubscriptionPayloadPromise
  extends Promise<ProjectAlbumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectAlbumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectAlbumPreviousValuesPromise>() => T;
}

export interface ProjectAlbumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectAlbumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectAlbumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectAlbumPreviousValuesSubscription>() => T;
}

export interface ProjectTagContentEdge {
  node: ProjectTagContent;
  cursor: String;
}

export interface ProjectTagContentEdgePromise
  extends Promise<ProjectTagContentEdge>,
    Fragmentable {
  node: <T = ProjectTagContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectTagContentEdgeSubscription
  extends Promise<AsyncIterator<ProjectTagContentEdge>>,
    Fragmentable {
  node: <T = ProjectTagContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectAlbumPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectAlbumPreviousValuesPromise
  extends Promise<ProjectAlbumPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectAlbumPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectAlbumPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectTagEdge {
  node: ProjectTag;
  cursor: String;
}

export interface ProjectTagEdgePromise
  extends Promise<ProjectTagEdge>,
    Fragmentable {
  node: <T = ProjectTagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectTagEdgeSubscription
  extends Promise<AsyncIterator<ProjectTagEdge>>,
    Fragmentable {
  node: <T = ProjectTagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectImageContent {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  alt: String;
}

export interface ProjectImageContentPromise
  extends Promise<ProjectImageContent>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  image: <T = ProjectImagePromise>() => T;
  language: <T = ProjectImageLngPromise>() => T;
  alt: () => Promise<String>;
}

export interface ProjectImageContentSubscription
  extends Promise<AsyncIterator<ProjectImageContent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  image: <T = ProjectImageSubscription>() => T;
  language: <T = ProjectImageLngSubscription>() => T;
  alt: () => Promise<AsyncIterator<String>>;
}

export interface ProjectLngConnection {
  pageInfo: PageInfo;
  edges: ProjectLngEdge[];
}

export interface ProjectLngConnectionPromise
  extends Promise<ProjectLngConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectLngEdge>>() => T;
  aggregate: <T = AggregateProjectLngPromise>() => T;
}

export interface ProjectLngConnectionSubscription
  extends Promise<AsyncIterator<ProjectLngConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectLngEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectLngSubscription>() => T;
}

export interface ProjectCategorySubscriptionPayload {
  mutation: MutationType;
  node: ProjectCategory;
  updatedFields: String[];
  previousValues: ProjectCategoryPreviousValues;
}

export interface ProjectCategorySubscriptionPayloadPromise
  extends Promise<ProjectCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectCategoryPreviousValuesPromise>() => T;
}

export interface ProjectCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectCategoryPreviousValuesSubscription>() => T;
}

export interface PostContent {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  imageAlt: String;
}

export interface PostContentPromise extends Promise<PostContent>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = PostLngPromise>() => T;
  title: () => Promise<String>;
  text: () => Promise<String>;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
  imageAlt: () => Promise<String>;
  post: <T = PostPromise>() => T;
}

export interface PostContentSubscription
  extends Promise<AsyncIterator<PostContent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  language: <T = PostLngSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  imageAlt: () => Promise<AsyncIterator<String>>;
  post: <T = PostSubscription>() => T;
}

export interface ProjectCategoryPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
  image: String;
}

export interface ProjectCategoryPreviousValuesPromise
  extends Promise<ProjectCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  slug: () => Promise<String>;
  image: () => Promise<String>;
}

export interface ProjectCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  slug: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProjectImage {
  count: Int;
}

export interface AggregateProjectImagePromise
  extends Promise<AggregateProjectImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectImageSubscription
  extends Promise<AsyncIterator<AggregateProjectImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectImage {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publicId: String;
  src: String;
}

export interface ProjectImagePromise
  extends Promise<ProjectImage>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  album: <T = ProjectAlbumPromise>() => T;
  publicId: () => Promise<String>;
  src: () => Promise<String>;
  contents: <T = ProjectImageContentPromise>() => T;
}

export interface ProjectImageSubscription
  extends Promise<AsyncIterator<ProjectImage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  album: <T = ProjectAlbumSubscription>() => T;
  publicId: () => Promise<AsyncIterator<String>>;
  src: () => Promise<AsyncIterator<String>>;
  contents: <T = ProjectImageContentSubscription>() => T;
}

export interface ProjectContentEdge {
  node: ProjectContent;
  cursor: String;
}

export interface ProjectContentEdgePromise
  extends Promise<ProjectContentEdge>,
    Fragmentable {
  node: <T = ProjectContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectContentEdgeSubscription
  extends Promise<AsyncIterator<ProjectContentEdge>>,
    Fragmentable {
  node: <T = ProjectContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectCategoryContentSubscriptionPayload {
  mutation: MutationType;
  node: ProjectCategoryContent;
  updatedFields: String[];
  previousValues: ProjectCategoryContentPreviousValues;
}

export interface ProjectCategoryContentSubscriptionPayloadPromise
  extends Promise<ProjectCategoryContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectCategoryContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectCategoryContentPreviousValuesPromise>() => T;
}

export interface ProjectCategoryContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectCategoryContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectCategoryContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectCategoryContentPreviousValuesSubscription>() => T;
}

export interface ProjectCategoryLngConnection {
  pageInfo: PageInfo;
  edges: ProjectCategoryLngEdge[];
}

export interface ProjectCategoryLngConnectionPromise
  extends Promise<ProjectCategoryLngConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectCategoryLngEdge>>() => T;
  aggregate: <T = AggregateProjectCategoryLngPromise>() => T;
}

export interface ProjectCategoryLngConnectionSubscription
  extends Promise<AsyncIterator<ProjectCategoryLngConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProjectCategoryLngEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProjectCategoryLngSubscription>() => T;
}

export interface ProjectCategoryContentPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  text: String;
  imageAlt: String;
  metaTitle?: String;
  metaDescription?: String;
}

export interface ProjectCategoryContentPreviousValuesPromise
  extends Promise<ProjectCategoryContentPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  imageAlt: () => Promise<String>;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
}

export interface ProjectCategoryContentPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectCategoryContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  imageAlt: () => Promise<AsyncIterator<String>>;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
}

export interface ProjectCategoryContentConnection {
  pageInfo: PageInfo;
  edges: ProjectCategoryContentEdge[];
}

export interface ProjectCategoryContentConnectionPromise
  extends Promise<ProjectCategoryContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectCategoryContentEdge>>() => T;
  aggregate: <T = AggregateProjectCategoryContentPromise>() => T;
}

export interface ProjectCategoryContentConnectionSubscription
  extends Promise<AsyncIterator<ProjectCategoryContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProjectCategoryContentEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProjectCategoryContentSubscription>() => T;
}

export interface ProjectAlbum {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectAlbumPromise
  extends Promise<ProjectAlbum>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  project: <T = ProjectPromise>() => T;
  images: <T = FragmentableArray<ProjectImage>>(
    args?: {
      where?: ProjectImageWhereInput;
      orderBy?: ProjectImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProjectAlbumSubscription
  extends Promise<AsyncIterator<ProjectAlbum>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  project: <T = ProjectSubscription>() => T;
  images: <T = Promise<AsyncIterator<ProjectImageSubscription>>>(
    args?: {
      where?: ProjectImageWhereInput;
      orderBy?: ProjectImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectCategoryLngSubscriptionPayload {
  mutation: MutationType;
  node: ProjectCategoryLng;
  updatedFields: String[];
  previousValues: ProjectCategoryLngPreviousValues;
}

export interface ProjectCategoryLngSubscriptionPayloadPromise
  extends Promise<ProjectCategoryLngSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectCategoryLngPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectCategoryLngPreviousValuesPromise>() => T;
}

export interface ProjectCategoryLngSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectCategoryLngSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectCategoryLngSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectCategoryLngPreviousValuesSubscription>() => T;
}

export interface ProjectTagLngPreviousValues {
  id: UUID;
  country: String;
  locale: String;
}

export interface ProjectTagLngPreviousValuesPromise
  extends Promise<ProjectTagLngPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface ProjectTagLngPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectTagLngPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface ProjectCategoryLngPreviousValues {
  id: UUID;
  country: String;
  locale?: String;
}

export interface ProjectCategoryLngPreviousValuesPromise
  extends Promise<ProjectCategoryLngPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface ProjectCategoryLngPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectCategoryLngPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProfile {
  count: Int;
}

export interface AggregateProfilePromise
  extends Promise<AggregateProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfileSubscription
  extends Promise<AsyncIterator<AggregateProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectCategoryLng {
  id: UUID;
  country: String;
  locale?: String;
}

export interface ProjectCategoryLngPromise
  extends Promise<ProjectCategoryLng>,
    Fragmentable {
  id: () => Promise<UUID>;
  categories: <T = FragmentableArray<ProjectCategoryContent>>(
    args?: {
      where?: ProjectCategoryContentWhereInput;
      orderBy?: ProjectCategoryContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface ProjectCategoryLngSubscription
  extends Promise<AsyncIterator<ProjectCategoryLng>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  categories: <T = Promise<AsyncIterator<ProjectCategoryContentSubscription>>>(
    args?: {
      where?: ProjectCategoryContentWhereInput;
      orderBy?: ProjectCategoryContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePostTagLng {
  count: Int;
}

export interface AggregatePostTagLngPromise
  extends Promise<AggregatePostTagLng>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostTagLngSubscription
  extends Promise<AsyncIterator<AggregatePostTagLng>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectContentSubscriptionPayload {
  mutation: MutationType;
  node: ProjectContent;
  updatedFields: String[];
  previousValues: ProjectContentPreviousValues;
}

export interface ProjectContentSubscriptionPayloadPromise
  extends Promise<ProjectContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectContentPreviousValuesPromise>() => T;
}

export interface ProjectContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectContentPreviousValuesSubscription>() => T;
}

export interface AggregatePostTagContent {
  count: Int;
}

export interface AggregatePostTagContentPromise
  extends Promise<AggregatePostTagContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostTagContentSubscription
  extends Promise<AsyncIterator<AggregatePostTagContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectContentPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  text: String;
  metaTitle?: String;
  metaDescription?: String;
  isActive: Boolean;
}

export interface ProjectContentPreviousValuesPromise
  extends Promise<ProjectContentPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
  isActive: () => Promise<Boolean>;
}

export interface ProjectContentPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
}

export interface PostTagEdge {
  node: PostTag;
  cursor: String;
}

export interface PostTagEdgePromise extends Promise<PostTagEdge>, Fragmentable {
  node: <T = PostTagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostTagEdgeSubscription
  extends Promise<AsyncIterator<PostTagEdge>>,
    Fragmentable {
  node: <T = PostTagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectCategoryContent {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  text: String;
  imageAlt: String;
  metaTitle?: String;
  metaDescription?: String;
}

export interface ProjectCategoryContentPromise
  extends Promise<ProjectCategoryContent>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  category: <T = ProjectCategoryPromise>() => T;
  language: <T = ProjectCategoryLngPromise>() => T;
  title: () => Promise<String>;
  text: () => Promise<String>;
  imageAlt: () => Promise<String>;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
}

export interface ProjectCategoryContentSubscription
  extends Promise<AsyncIterator<ProjectCategoryContent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: <T = ProjectCategorySubscription>() => T;
  language: <T = ProjectCategoryLngSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  imageAlt: () => Promise<AsyncIterator<String>>;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
}

export interface PostLngConnection {
  pageInfo: PageInfo;
  edges: PostLngEdge[];
}

export interface PostLngConnectionPromise
  extends Promise<PostLngConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostLngEdge>>() => T;
  aggregate: <T = AggregatePostLngPromise>() => T;
}

export interface PostLngConnectionSubscription
  extends Promise<AsyncIterator<PostLngConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostLngEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostLngSubscription>() => T;
}

export interface ProjectImageSubscriptionPayload {
  mutation: MutationType;
  node: ProjectImage;
  updatedFields: String[];
  previousValues: ProjectImagePreviousValues;
}

export interface ProjectImageSubscriptionPayloadPromise
  extends Promise<ProjectImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectImagePreviousValuesPromise>() => T;
}

export interface ProjectImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectImagePreviousValuesSubscription>() => T;
}

export interface PostContentConnection {
  pageInfo: PageInfo;
  edges: PostContentEdge[];
}

export interface PostContentConnectionPromise
  extends Promise<PostContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostContentEdge>>() => T;
  aggregate: <T = AggregatePostContentPromise>() => T;
}

export interface PostContentConnectionSubscription
  extends Promise<AsyncIterator<PostContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostContentSubscription>() => T;
}

export interface ProjectImagePreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publicId: String;
  src: String;
}

export interface ProjectImagePreviousValuesPromise
  extends Promise<ProjectImagePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publicId: () => Promise<String>;
  src: () => Promise<String>;
}

export interface ProjectImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publicId: () => Promise<AsyncIterator<String>>;
  src: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ProjectCategory {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
  image: String;
}

export interface ProjectCategoryPromise
  extends Promise<ProjectCategory>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  contents: <T = FragmentableArray<ProjectCategoryContent>>(
    args?: {
      where?: ProjectCategoryContentWhereInput;
      orderBy?: ProjectCategoryContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  slug: () => Promise<String>;
  image: () => Promise<String>;
  projects: <T = FragmentableArray<Project>>(
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProjectCategorySubscription
  extends Promise<AsyncIterator<ProjectCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  contents: <T = Promise<AsyncIterator<ProjectCategoryContentSubscription>>>(
    args?: {
      where?: ProjectCategoryContentWhereInput;
      orderBy?: ProjectCategoryContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  slug: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  projects: <T = Promise<AsyncIterator<ProjectSubscription>>>(
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProjectImageLngEdge {
  node: ProjectImageLng;
  cursor: String;
}

export interface ProjectImageLngEdgePromise
  extends Promise<ProjectImageLngEdge>,
    Fragmentable {
  node: <T = ProjectImageLngPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectImageLngEdgeSubscription
  extends Promise<AsyncIterator<ProjectImageLngEdge>>,
    Fragmentable {
  node: <T = ProjectImageLngSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectImageContentSubscriptionPayload {
  mutation: MutationType;
  node: ProjectImageContent;
  updatedFields: String[];
  previousValues: ProjectImageContentPreviousValues;
}

export interface ProjectImageContentSubscriptionPayloadPromise
  extends Promise<ProjectImageContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectImageContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectImageContentPreviousValuesPromise>() => T;
}

export interface ProjectImageContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectImageContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectImageContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectImageContentPreviousValuesSubscription>() => T;
}

export interface ProjectImageConnection {
  pageInfo: PageInfo;
  edges: ProjectImageEdge[];
}

export interface ProjectImageConnectionPromise
  extends Promise<ProjectImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectImageEdge>>() => T;
  aggregate: <T = AggregateProjectImagePromise>() => T;
}

export interface ProjectImageConnectionSubscription
  extends Promise<AsyncIterator<ProjectImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectImageSubscription>() => T;
}

export interface ProjectImageContentPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  alt: String;
}

export interface ProjectImageContentPreviousValuesPromise
  extends Promise<ProjectImageContentPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  alt: () => Promise<String>;
}

export interface ProjectImageContentPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectImageContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  alt: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProjectCategoryContent {
  count: Int;
}

export interface AggregateProjectCategoryContentPromise
  extends Promise<AggregateProjectCategoryContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectCategoryContentSubscription
  extends Promise<AsyncIterator<AggregateProjectCategoryContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Project {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  slug: () => Promise<String>;
  category: <T = ProjectCategoryPromise>() => T;
  author: <T = UserPromise>() => T;
  album: <T = ProjectAlbumPromise>() => T;
  contents: <T = FragmentableArray<ProjectContent>>(
    args?: {
      where?: ProjectContentWhereInput;
      orderBy?: ProjectContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<ProjectTag>>(
    args?: {
      where?: ProjectTagWhereInput;
      orderBy?: ProjectTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  slug: () => Promise<AsyncIterator<String>>;
  category: <T = ProjectCategorySubscription>() => T;
  author: <T = UserSubscription>() => T;
  album: <T = ProjectAlbumSubscription>() => T;
  contents: <T = Promise<AsyncIterator<ProjectContentSubscription>>>(
    args?: {
      where?: ProjectContentWhereInput;
      orderBy?: ProjectContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<ProjectTagSubscription>>>(
    args?: {
      where?: ProjectTagWhereInput;
      orderBy?: ProjectTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProjectAlbumEdge {
  node: ProjectAlbum;
  cursor: String;
}

export interface ProjectAlbumEdgePromise
  extends Promise<ProjectAlbumEdge>,
    Fragmentable {
  node: <T = ProjectAlbumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectAlbumEdgeSubscription
  extends Promise<AsyncIterator<ProjectAlbumEdge>>,
    Fragmentable {
  node: <T = ProjectAlbumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectImageLngSubscriptionPayload {
  mutation: MutationType;
  node: ProjectImageLng;
  updatedFields: String[];
  previousValues: ProjectImageLngPreviousValues;
}

export interface ProjectImageLngSubscriptionPayloadPromise
  extends Promise<ProjectImageLngSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectImageLngPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectImageLngPreviousValuesPromise>() => T;
}

export interface ProjectImageLngSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectImageLngSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectImageLngSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectImageLngPreviousValuesSubscription>() => T;
}

export interface ProfileConnection {
  pageInfo: PageInfo;
  edges: ProfileEdge[];
}

export interface ProfileConnectionPromise
  extends Promise<ProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfileEdge>>() => T;
  aggregate: <T = AggregateProfilePromise>() => T;
}

export interface ProfileConnectionSubscription
  extends Promise<AsyncIterator<ProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfileSubscription>() => T;
}

export interface ProjectImageLngPreviousValues {
  id: UUID;
  country: String;
  locale?: String;
}

export interface ProjectImageLngPreviousValuesPromise
  extends Promise<ProjectImageLngPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface ProjectImageLngPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectImageLngPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface PostTagContentConnection {
  pageInfo: PageInfo;
  edges: PostTagContentEdge[];
}

export interface PostTagContentConnectionPromise
  extends Promise<PostTagContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostTagContentEdge>>() => T;
  aggregate: <T = AggregatePostTagContentPromise>() => T;
}

export interface PostTagContentConnectionSubscription
  extends Promise<AsyncIterator<PostTagContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostTagContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostTagContentSubscription>() => T;
}

export interface PostTagContent {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
}

export interface PostTagContentPromise
  extends Promise<PostTagContent>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  tag: <T = PostTagPromise>() => T;
  title: () => Promise<String>;
}

export interface PostTagContentSubscription
  extends Promise<AsyncIterator<PostTagContent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  tag: <T = PostTagSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePostContent {
  count: Int;
}

export interface AggregatePostContentPromise
  extends Promise<AggregatePostContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostContentSubscription
  extends Promise<AsyncIterator<AggregatePostContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectLngSubscriptionPayload {
  mutation: MutationType;
  node: ProjectLng;
  updatedFields: String[];
  previousValues: ProjectLngPreviousValues;
}

export interface ProjectLngSubscriptionPayloadPromise
  extends Promise<ProjectLngSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectLngPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectLngPreviousValuesPromise>() => T;
}

export interface ProjectLngSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectLngSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectLngSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectLngPreviousValuesSubscription>() => T;
}

export interface AggregateProjectLng {
  count: Int;
}

export interface AggregateProjectLngPromise
  extends Promise<AggregateProjectLng>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectLngSubscription
  extends Promise<AsyncIterator<AggregateProjectLng>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectLngPreviousValues {
  id: UUID;
  country: String;
  locale?: String;
}

export interface ProjectLngPreviousValuesPromise
  extends Promise<ProjectLngPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface ProjectLngPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectLngPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProjectCategoryLng {
  count: Int;
}

export interface AggregateProjectCategoryLngPromise
  extends Promise<AggregateProjectCategoryLng>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectCategoryLngSubscription
  extends Promise<AsyncIterator<AggregateProjectCategoryLng>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostTagLng {
  id: UUID;
  country: String;
  locale: String;
}

export interface PostTagLngPromise extends Promise<PostTagLng>, Fragmentable {
  id: () => Promise<UUID>;
  tags: <T = FragmentableArray<PostTag>>(
    args?: {
      where?: PostTagWhereInput;
      orderBy?: PostTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface PostTagLngSubscription
  extends Promise<AsyncIterator<PostTagLng>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  tags: <T = Promise<AsyncIterator<PostTagSubscription>>>(
    args?: {
      where?: PostTagWhereInput;
      orderBy?: PostTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePostLng {
  count: Int;
}

export interface AggregatePostLngPromise
  extends Promise<AggregatePostLng>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostLngSubscription
  extends Promise<AsyncIterator<AggregatePostLng>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectTagContentSubscriptionPayload {
  mutation: MutationType;
  node: ProjectTagContent;
  updatedFields: String[];
  previousValues: ProjectTagContentPreviousValues;
}

export interface ProjectTagContentSubscriptionPayloadPromise
  extends Promise<ProjectTagContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectTagContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectTagContentPreviousValuesPromise>() => T;
}

export interface ProjectTagContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectTagContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectTagContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectTagContentPreviousValuesSubscription>() => T;
}

export interface PostTag {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  color: String;
}

export interface PostTagPromise extends Promise<PostTag>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  color: () => Promise<String>;
  language: <T = PostTagLngPromise>() => T;
  contents: <T = PostTagContentPromise>() => T;
}

export interface PostTagSubscription
  extends Promise<AsyncIterator<PostTag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  color: () => Promise<AsyncIterator<String>>;
  language: <T = PostTagLngSubscription>() => T;
  contents: <T = PostTagContentSubscription>() => T;
}

export interface ProjectTagPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  color?: String;
}

export interface ProjectTagPreviousValuesPromise
  extends Promise<ProjectTagPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  color: () => Promise<String>;
}

export interface ProjectTagPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectTagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  color: () => Promise<AsyncIterator<String>>;
}

export interface ProjectTagSubscriptionPayload {
  mutation: MutationType;
  node: ProjectTag;
  updatedFields: String[];
  previousValues: ProjectTagPreviousValues;
}

export interface ProjectTagSubscriptionPayloadPromise
  extends Promise<ProjectTagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectTagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectTagPreviousValuesPromise>() => T;
}

export interface ProjectTagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectTagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectTagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectTagPreviousValuesSubscription>() => T;
}

export interface PostLng {
  id: UUID;
  country: String;
  locale?: String;
}

export interface PostLngPromise extends Promise<PostLng>, Fragmentable {
  id: () => Promise<UUID>;
  posts: <T = FragmentableArray<PostContent>>(
    args?: {
      where?: PostContentWhereInput;
      orderBy?: PostContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<String>;
  locale: () => Promise<String>;
}

export interface PostLngSubscription
  extends Promise<AsyncIterator<PostLng>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  posts: <T = Promise<AsyncIterator<PostContentSubscription>>>(
    args?: {
      where?: PostContentWhereInput;
      orderBy?: PostContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  country: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
}

export interface PostTagLngConnection {
  pageInfo: PageInfo;
  edges: PostTagLngEdge[];
}

export interface PostTagLngConnectionPromise
  extends Promise<PostTagLngConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostTagLngEdge>>() => T;
  aggregate: <T = AggregatePostTagLngPromise>() => T;
}

export interface PostTagLngConnectionSubscription
  extends Promise<AsyncIterator<PostTagLngConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostTagLngEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostTagLngSubscription>() => T;
}

export interface ProjectCategoryEdge {
  node: ProjectCategory;
  cursor: String;
}

export interface ProjectCategoryEdgePromise
  extends Promise<ProjectCategoryEdge>,
    Fragmentable {
  node: <T = ProjectCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectCategoryEdgeSubscription
  extends Promise<AsyncIterator<ProjectCategoryEdge>>,
    Fragmentable {
  node: <T = ProjectCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectImageContentEdge {
  node: ProjectImageContent;
  cursor: String;
}

export interface ProjectImageContentEdgePromise
  extends Promise<ProjectImageContentEdge>,
    Fragmentable {
  node: <T = ProjectImageContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectImageContentEdgeSubscription
  extends Promise<AsyncIterator<ProjectImageContentEdge>>,
    Fragmentable {
  node: <T = ProjectImageContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type UUID = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "PostContent",
    embedded: false
  },
  {
    name: "PostLng",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "PostTag",
    embedded: false
  },
  {
    name: "PostTagContent",
    embedded: false
  },
  {
    name: "PostTagLng",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Profile",
    embedded: false
  },
  {
    name: "Avatar",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "ProjectContent",
    embedded: false
  },
  {
    name: "ProjectLng",
    embedded: false
  },
  {
    name: "ProjectTag",
    embedded: false
  },
  {
    name: "ProjectTagContent",
    embedded: false
  },
  {
    name: "ProjectTagLng",
    embedded: false
  },
  {
    name: "ProjectCategory",
    embedded: false
  },
  {
    name: "ProjectCategoryContent",
    embedded: false
  },
  {
    name: "ProjectCategoryLng",
    embedded: false
  },
  {
    name: "ProjectAlbum",
    embedded: false
  },
  {
    name: "ProjectImage",
    embedded: false
  },
  {
    name: "ProjectImageContent",
    embedded: false
  },
  {
    name: "ProjectImageLng",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466/default/default`,
  secret: `${process.env["APP_SECRET"]}`
});
export const prisma = new Prisma();
